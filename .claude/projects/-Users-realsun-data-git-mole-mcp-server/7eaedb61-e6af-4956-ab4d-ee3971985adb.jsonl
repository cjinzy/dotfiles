{"type":"summary","summary":"API Codebase Review: Params, Structure, CLAUDE.md","leafUuid":"b3ebcbb0-794b-4f96-a848-c17a9263f4d6"}
{"parentUuid":null,"isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"7eaedb61-e6af-4956-ab4d-ee3971985adb","version":"1.0.58","gitBranch":"main","type":"user","message":{"role":"user","content":"기본적으로 1년 검색되게 해줘 "},"uuid":"18640608-2adb-446d-bad6-e689ea4befc7","timestamp":"2025-07-24T01:49:06.354Z"}
{"parentUuid":"18640608-2adb-446d-bad6-e689ea4befc7","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"7eaedb61-e6af-4956-ab4d-ee3971985adb","version":"1.0.58","gitBranch":"main","message":{"id":"msg_01BtD6aNNm3zyKcrrFSr2bjf","type":"message","role":"assistant","model":"claude-opus-4-20250514","content":[{"type":"text","text":"기본적으로 1년 검색되도록 수정하겠습니다."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":16138,"cache_read_input_tokens":0,"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CRR19KNu3eiUpNJwa86UR","type":"assistant","uuid":"aa3a35d0-d2f0-48ad-8b66-3445e43a80bf","timestamp":"2025-07-24T01:49:10.108Z"}
{"parentUuid":"aa3a35d0-d2f0-48ad-8b66-3445e43a80bf","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"7eaedb61-e6af-4956-ab4d-ee3971985adb","version":"1.0.58","gitBranch":"main","message":{"id":"msg_01BtD6aNNm3zyKcrrFSr2bjf","type":"message","role":"assistant","model":"claude-opus-4-20250514","content":[{"type":"tool_use","id":"toolu_01PUqvHPmT8nQv7SPnHa7G1P","name":"Read","input":{"file_path":"/Users/realsun/data/git/mole-mcp-server/src/stealthmole_mcp/server.py","offset":152,"limit":30}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":16138,"cache_read_input_tokens":0,"output_tokens":144,"service_tier":"standard"}},"requestId":"req_011CRR19KNu3eiUpNJwa86UR","type":"assistant","uuid":"1f780d07-028a-4b32-9fc0-ef2f9f37b5e6","timestamp":"2025-07-24T01:49:11.382Z"}
{"parentUuid":"1f780d07-028a-4b32-9fc0-ef2f9f37b5e6","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"7eaedb61-e6af-4956-ab4d-ee3971985adb","version":"1.0.58","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PUqvHPmT8nQv7SPnHa7G1P","type":"tool_result","content":"   152→                                \"url\",\n   153→                                \"iol\",\n   154→                            ],\n   155→                        },\n   156→                        \"text\": {\n   157→                            \"type\": \"string\",\n   158→                            \"description\": \"Search keyword or data to find. Supports AND, OR, NOT operators (max 3 OR, 5 total operators)\",\n   159→                        },\n   160→                        \"target\": {\n   161→                            \"type\": \"string\",\n   162→                            \"description\": \"Target type to search (default: 'all'). Use comma-separated values for multiple targets\",\n   163→                            \"default\": \"all\",\n   164→                        },\n   165→                        \"limit\": {\n   166→                            \"type\": \"integer\",\n   167→                            \"description\": \"Maximum number of results (default: 50)\",\n   168→                            \"default\": 50,\n   169→                            \"minimum\": 1,\n   170→                            \"maximum\": 50,\n   171→                        },\n   172→                        \"orderType\": {\n   173→                            \"type\": \"string\",\n   174→                            \"description\": \"Ordering type\",\n   175→                            \"enum\": [\"createDate\", \"value\"],\n   176→                            \"default\": \"createDate\",\n   177→                        },\n   178→                        \"order\": {\n   179→                            \"type\": \"string\",\n   180→                            \"description\": \"Sort order\",\n   181→                            \"enum\": [\"asc\", \"desc\"],\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"7c80a0f8-eda0-41eb-bebd-c4d297618be6","timestamp":"2025-07-24T01:49:11.402Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/realsun/data/git/mole-mcp-server/src/stealthmole_mcp/server.py","content":"                                \"url\",\n                                \"iol\",\n                            ],\n                        },\n                        \"text\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search keyword or data to find. Supports AND, OR, NOT operators (max 3 OR, 5 total operators)\",\n                        },\n                        \"target\": {\n                            \"type\": \"string\",\n                            \"description\": \"Target type to search (default: 'all'). Use comma-separated values for multiple targets\",\n                            \"default\": \"all\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Ordering type\",\n                            \"enum\": [\"createDate\", \"value\"],\n                            \"default\": \"createDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],","numLines":30,"startLine":152,"totalLines":1005}}}
{"parentUuid":"7c80a0f8-eda0-41eb-bebd-c4d297618be6","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"7eaedb61-e6af-4956-ab4d-ee3971985adb","version":"1.0.58","gitBranch":"main","message":{"id":"msg_01HJPEG576xxrYwkQfRc1bJY","type":"message","role":"assistant","model":"claude-opus-4-20250514","content":[{"type":"tool_use","id":"toolu_01CgTUxtNymydcuzKQC5ibPb","name":"Grep","input":{"pattern":"Add date range defaults based on prompt context","path":"/Users/realsun/data/git/mole-mcp-server/src/stealthmole_mcp/server.py","output_mode":"content","-B":5,"-A":20}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":600,"cache_read_input_tokens":16138,"output_tokens":162,"service_tier":"standard"}},"requestId":"req_011CRR19g6ay474xStKPfYsZ","type":"assistant","uuid":"c1886cdf-923a-4094-ae53-ced1c4855e58","timestamp":"2025-07-24T01:49:16.403Z"}
{"parentUuid":"c1886cdf-923a-4094-ae53-ced1c4855e58","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"7eaedb61-e6af-4956-ab4d-ee3971985adb","version":"1.0.58","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CgTUxtNymydcuzKQC5ibPb","type":"tool_result","content":"else:\n                    modified_args[\"indicator\"] = \"keyword\"\n            else:\n                modified_args[\"indicator\"] = \"keyword\"\n    \n    # Add date range defaults based on prompt context\n    if prompt and \"start_date\" not in modified_args:\n        if \"recent\" in prompt.lower() or \"latest\" in prompt.lower():\n            # Set start_date to 7 days ago for recent searches\n            from datetime import datetime, timedelta\n            start_date = (datetime.now() - timedelta(days=7)).strftime(\"%Y-%m-%d\")\n            modified_args[\"start_date\"] = start_date\n        elif \"last month\" in prompt.lower():\n            from datetime import datetime, timedelta\n            start_date = (datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%d\")\n            modified_args[\"start_date\"] = start_date\n    \n    return modified_args\ndef removal_empty(result: dict[str, Any]) -> dict[str, Any]:\n    \"\"\"Remove empty keys from result.\"\"\"\n    keys_to_remove = [key for key in result.keys() if result[key].get(\"totalCount\") == 0]\n    for key in keys_to_remove:\n        del result[key]\n    return result"}]},"uuid":"03ca84d9-6928-4ee7-b5a3-04468a530799","timestamp":"2025-07-24T01:49:16.620Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"else:\n                    modified_args[\"indicator\"] = \"keyword\"\n            else:\n                modified_args[\"indicator\"] = \"keyword\"\n    \n    # Add date range defaults based on prompt context\n    if prompt and \"start_date\" not in modified_args:\n        if \"recent\" in prompt.lower() or \"latest\" in prompt.lower():\n            # Set start_date to 7 days ago for recent searches\n            from datetime import datetime, timedelta\n            start_date = (datetime.now() - timedelta(days=7)).strftime(\"%Y-%m-%d\")\n            modified_args[\"start_date\"] = start_date\n        elif \"last month\" in prompt.lower():\n            from datetime import datetime, timedelta\n            start_date = (datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%d\")\n            modified_args[\"start_date\"] = start_date\n    \n    return modified_args\ndef removal_empty(result: dict[str, Any]) -> dict[str, Any]:\n    \"\"\"Remove empty keys from result.\"\"\"\n    keys_to_remove = [key for key in result.keys() if result[key].get(\"totalCount\") == 0]\n    for key in keys_to_remove:\n        del result[key]\n    return result","numLines":24}}
{"parentUuid":"03ca84d9-6928-4ee7-b5a3-04468a530799","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"7eaedb61-e6af-4956-ab4d-ee3971985adb","version":"1.0.58","gitBranch":"main","message":{"id":"msg_01ScNmNeiXzZ9qr7Xb9qTqi6","type":"message","role":"assistant","model":"claude-opus-4-20250514","content":[{"type":"tool_use","id":"toolu_01KwuAfeUU9bPq4yAdfbywy4","name":"Edit","input":{"file_path":"/Users/realsun/data/git/mole-mcp-server/src/stealthmole_mcp/server.py","old_string":"    # Add date range defaults based on prompt context\n    if prompt and \"start_date\" not in modified_args:\n        if \"recent\" in prompt.lower() or \"latest\" in prompt.lower():\n            # Set start_date to 7 days ago for recent searches\n            from datetime import datetime, timedelta\n            start_date = (datetime.now() - timedelta(days=7)).strftime(\"%Y-%m-%d\")\n            modified_args[\"start_date\"] = start_date\n        elif \"last month\" in prompt.lower():\n            from datetime import datetime, timedelta\n            start_date = (datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%d\")\n            modified_args[\"start_date\"] = start_date","new_string":"    # Add date range defaults based on prompt context\n    if \"start_date\" not in modified_args:\n        from datetime import datetime, timedelta\n        if prompt and (\"recent\" in prompt.lower() or \"latest\" in prompt.lower()):\n            # Set start_date to 7 days ago for recent searches\n            start_date = (datetime.now() - timedelta(days=7)).strftime(\"%Y-%m-%d\")\n            modified_args[\"start_date\"] = start_date\n        elif prompt and \"last month\" in prompt.lower():\n            start_date = (datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%d\")\n            modified_args[\"start_date\"] = start_date\n        else:\n            # Default to 1 year ago\n            start_date = (datetime.now() - timedelta(days=365)).strftime(\"%Y-%m-%d\")\n            modified_args[\"start_date\"] = start_date"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":475,"cache_read_input_tokens":16738,"output_tokens":522,"service_tier":"standard"}},"requestId":"req_011CRR1A52j7564exBUiYHXA","type":"assistant","uuid":"dff1bde2-5ba4-4061-8139-fbf6d7efecb1","timestamp":"2025-07-24T01:49:28.380Z"}
{"parentUuid":"dff1bde2-5ba4-4061-8139-fbf6d7efecb1","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"7eaedb61-e6af-4956-ab4d-ee3971985adb","version":"1.0.58","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KwuAfeUU9bPq4yAdfbywy4","type":"tool_result","content":"The file /Users/realsun/data/git/mole-mcp-server/src/stealthmole_mcp/server.py has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   714→                    modified_args[\"indicator\"] = \"keyword\"\n   715→            else:\n   716→                modified_args[\"indicator\"] = \"keyword\"\n   717→    \n   718→    # Add date range defaults based on prompt context\n   719→    if \"start_date\" not in modified_args:\n   720→        from datetime import datetime, timedelta\n   721→        if prompt and (\"recent\" in prompt.lower() or \"latest\" in prompt.lower()):\n   722→            # Set start_date to 7 days ago for recent searches\n   723→            start_date = (datetime.now() - timedelta(days=7)).strftime(\"%Y-%m-%d\")\n   724→            modified_args[\"start_date\"] = start_date\n   725→        elif prompt and \"last month\" in prompt.lower():\n   726→            start_date = (datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%d\")\n   727→            modified_args[\"start_date\"] = start_date\n   728→        else:\n   729→            # Default to 1 year ago\n   730→            start_date = (datetime.now() - timedelta(days=365)).strftime(\"%Y-%m-%d\")\n   731→            modified_args[\"start_date\"] = start_date\n   732→    \n   733→    return modified_args\n   734→\n   735→"}]},"uuid":"a43133b4-13d5-4fc1-bd19-429416c54302","timestamp":"2025-07-24T01:49:35.716Z","toolUseResult":{"filePath":"/Users/realsun/data/git/mole-mcp-server/src/stealthmole_mcp/server.py","oldString":"    # Add date range defaults based on prompt context\n    if prompt and \"start_date\" not in modified_args:\n        if \"recent\" in prompt.lower() or \"latest\" in prompt.lower():\n            # Set start_date to 7 days ago for recent searches\n            from datetime import datetime, timedelta\n            start_date = (datetime.now() - timedelta(days=7)).strftime(\"%Y-%m-%d\")\n            modified_args[\"start_date\"] = start_date\n        elif \"last month\" in prompt.lower():\n            from datetime import datetime, timedelta\n            start_date = (datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%d\")\n            modified_args[\"start_date\"] = start_date","newString":"    # Add date range defaults based on prompt context\n    if \"start_date\" not in modified_args:\n        from datetime import datetime, timedelta\n        if prompt and (\"recent\" in prompt.lower() or \"latest\" in prompt.lower()):\n            # Set start_date to 7 days ago for recent searches\n            start_date = (datetime.now() - timedelta(days=7)).strftime(\"%Y-%m-%d\")\n            modified_args[\"start_date\"] = start_date\n        elif prompt and \"last month\" in prompt.lower():\n            start_date = (datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%d\")\n            modified_args[\"start_date\"] = start_date\n        else:\n            # Default to 1 year ago\n            start_date = (datetime.now() - timedelta(days=365)).strftime(\"%Y-%m-%d\")\n            modified_args[\"start_date\"] = start_date","originalFile":"\"\"\"StealthMole MCP Server implementation.\"\"\"\n\nimport asyncio\nimport os\nimport sys\nfrom typing import Any, Optional, Sequence\n\nfrom click import prompt\nfrom dotenv import load_dotenv\nfrom mcp.server import NotificationOptions, Server\nfrom mcp.server.models import InitializationOptions\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import (\n    GetPromptResult,\n    Prompt,\n    PromptArgument,\n    PromptMessage,\n    Resource,\n    TextContent,\n    Tool,\n)\nfrom pydantic import AnyUrl\n\nfrom .tools import *\n\nload_dotenv()\n\nprompts_path = os.path.join(os.path.dirname(__file__), \"prompt\")\n\nserver: Server = Server(\n    \"stealthmole-mcp\",\n    \"250715\",\n)\n\n\n@server.list_resources()\nasync def handle_list_resources() -> list[Resource]:\n    \"\"\"List available resources.\"\"\"\n    return []\n\n\n@server.read_resource()\nasync def handle_read_resource(uri: AnyUrl) -> str:\n    \"\"\"Read a specific resource.\"\"\"\n    raise ValueError(f\"Unknown resource: {uri}\")\n\n\n@server.list_prompts()\nasync def handle_list_prompts() -> list[Prompt]:\n    \"\"\"List available prompts.\"\"\"\n    return [\n        Prompt(\n            name=\"stealthmole_default_prompt\",\n            description=\"Default behavior guidelines for StealthMole MCP\",\n            arguments=[\n                PromptArgument(\n                    name=\"context\",\n                    description=\"Current search context\",\n                    required=False,\n                )\n            ],\n        )\n    ]\n\n\n@server.get_prompt()\nasync def handle_get_prompt(\n    name: str, arguments: dict[str, str] | None = None\n) -> GetPromptResult:\n    \"\"\"Get a specific prompt.\"\"\"\n    if name == \"stealthmole_default_prompt\":\n        return GetPromptResult(\n            messages=[\n                PromptMessage(\n                    role=\"assistant\",\n                    content=TextContent(\n                        type=\"text\",\n                        text=open(f\"{prompts_path}/default_prompt.md\").read(),\n                    ),\n                )\n            ]\n        )\n    else:\n        raise ValueError(f\"Unknown prompt: {name}\")\n\n\n@server.list_tools()\nasync def handle_list_tools() -> list[Tool]:\n    \"\"\"List available StealthMole tools.\"\"\"\n    try:\n        print(\"Returning StealthMole tools list\", file=sys.stderr)\n        return [\n            Tool(\n                name=\"search_darkweb\",\n                description=\"Search dark web content for indicators like domains, IPs, emails, etc.\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type to search for\",\n                            \"enum\": [\n                                \"adsense\",\n                                \"analyticsid\",\n                                \"band\",\n                                \"bitcoin\",\n                                \"blueprint\",\n                                \"creditcard\",\n                                \"cve\",\n                                \"discord\",\n                                \"document\",\n                                \"domain\",\n                                \"email\",\n                                \"ethereum\",\n                                \"exefile\",\n                                \"facebook\",\n                                \"filehosting\",\n                                \"googledrive\",\n                                \"gps\",\n                                \"hash\",\n                                \"hashstring\",\n                                \"i2p\",\n                                \"i2purl\",\n                                \"id\",\n                                \"image\",\n                                \"instagram\",\n                                \"ioc\",\n                                \"ip\",\n                                \"kakaotalk\",\n                                \"keyword\",\n                                \"kssn\",\n                                \"leakedaudio\",\n                                \"leakedemailfile\",\n                                \"leakedvideo\",\n                                \"line\",\n                                \"linkedin\",\n                                \"malware\",\n                                \"monero\",\n                                \"otherfile\",\n                                \"pastebin\",\n                                \"pgp\",\n                                \"serverstatus\",\n                                \"session\",\n                                \"shorten\",\n                                \"sshkey\",\n                                \"sslkey\",\n                                \"tel\",\n                                \"telegram\",\n                                \"tor\",\n                                \"torurl\",\n                                \"twitter\",\n                                \"url\",\n                                \"iol\",\n                            ],\n                        },\n                        \"text\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search keyword or data to find. Supports AND, OR, NOT operators (max 3 OR, 5 total operators)\",\n                        },\n                        \"target\": {\n                            \"type\": \"string\",\n                            \"description\": \"Target type to search (default: 'all'). Use comma-separated values for multiple targets\",\n                            \"default\": \"all\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Ordering type\",\n                            \"enum\": [\"createDate\", \"value\"],\n                            \"default\": \"createDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\", \"text\"],\n                },\n            ),\n            Tool(\n                name=\"search_telegram\",\n                description=\"Search Telegram content for indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type to search for\",\n                            \"enum\": [\n                                \"band\",\n                                \"bitcoin\",\n                                \"creditcard\",\n                                \"cve\",\n                                \"discord\",\n                                \"document\",\n                                \"domain\",\n                                \"email\",\n                                \"ethereum\",\n                                \"exefile\",\n                                \"facebook\",\n                                \"filehosting\",\n                                \"googledrive\",\n                                \"gps\",\n                                \"hash\",\n                                \"hashstring\",\n                                \"i2p\",\n                                \"i2purl\",\n                                \"id\",\n                                \"image\",\n                                \"instagram\",\n                                \"ip\",\n                                \"kakaotalk\",\n                                \"keyword\",\n                                \"kssn\",\n                                \"line\",\n                                \"monero\",\n                                \"otherfile\",\n                                \"pastebin\",\n                                \"pgp\",\n                                \"tel\",\n                                \"session\",\n                                \"shorten\",\n                                \"telegram\",\n                                \"telegram.channel\",\n                                \"telegram.message\",\n                                \"telegram.user\",\n                                \"tor\",\n                                \"torurl\",\n                                \"tox\",\n                                \"twitter\",\n                                \"url\",\n                            ],\n                        },\n                        \"text\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search keyword or data to find. Supports AND, OR, NOT operators (max 3 OR, 5 total operators)\",\n                        },\n                        \"target\": {\n                            \"type\": \"string\",\n                            \"description\": \"Target type to search (default: 'all'). Use comma-separated values for multiple targets\",\n                            \"default\": \"all\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Ordering type\",\n                            \"enum\": [\"createDate\", \"value\"],\n                            \"default\": \"createDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\", \"text\"],\n                },\n            ),\n            Tool(\n                name=\"search_credentials\",\n                description=\"Search for leaked credentials using keywords or specific indicators (domain:, email:, id:, password:, after:, before:)\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - can use indicators like 'domain:example.com', 'email:user@domain.com', 'id:username', 'password:pass123', 'after:2023-01', 'before:2024-01' or plain keywords\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\n                                \"leakedDate\",\n                                \"domain\",\n                                \"email\",\n                                \"password\",\n                                \"leakedFrom\",\n                            ],\n                            \"default\": \"leakedDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                        \"start\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Filter data added to the system after start time (UTC timestamp)\",\n                        },\n                        \"end\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Filter data added to the system before end time (UTC timestamp)\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_ransomware\",\n                description=\"Search ransomware monitoring data using torurl: or domain: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'torurl:site.onion' to search ransomware sites or 'domain:victim.com' to search victim websites. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"victim\", \"attackGroup\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"get_node_details\",\n                description=\"Get detailed information about a specific node\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"node_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Node ID to get details for\",\n                        },\n                        \"pid\": {\n                            \"type\": \"string\",\n                            \"description\": \"Parent node ID (optional)\",\n                        },\n                        \"data_from\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Import data source list (default: False)\",\n                            \"default\": False,\n                        },\n                        \"include_url\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Import included URL list (default: False)\",\n                            \"default\": False,\n                        },\n                        \"include_contents\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Include HTML source contents for torurl, i2purl, url (default: True)\",\n                            \"default\": True,\n                        },\n                    },\n                    \"required\": [\"service\", \"node_id\"],\n                },\n            ),\n            Tool(\n                name=\"get_targets\",\n                description=\"Get available search targets for a service and indicator\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type\",\n                        },\n                    },\n                    \"required\": [\"service\", \"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_data\",\n                description=\"Export search results in specified format\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"service\", \"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_compromised_dataset\",\n                description=\"Search compromised data set information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"get_compromised_dataset_node\",\n                description=\"Get detailed compromised data set node information (Cyber Security Edition required)\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"node_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Node ID to get details for\",\n                        }\n                    },\n                    \"required\": [\"node_id\"],\n                },\n            ),\n            Tool(\n                name=\"search_combo_binder\",\n                description=\"Search leaked ID/Password combo information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_ulp_binder\",\n                description=\"Search URL-Login-Password combination information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_government_monitoring\",\n                description=\"Search government sector threat monitoring data using url: or id: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'url:hackersite.com' to search threat event URLs or 'id:hacker123' to search actor IDs. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"title\", \"author\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_leaked_monitoring\",\n                description=\"Search enterprise sector threat monitoring data using url: or id: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'url:hackersite.com' to search threat event URLs or 'id:hacker123' to search actor IDs. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"title\", \"author\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"download_file\",\n                description=\"Download file by hash from dt or tt service\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt or tt)\",\n                            \"enum\": [\"dt\", \"tt\"],\n                        },\n                        \"file_hash\": {\n                            \"type\": \"string\",\n                            \"description\": \"File hash to download\",\n                        },\n                    },\n                    \"required\": [\"service\", \"file_hash\"],\n                },\n            ),\n            Tool(\n                name=\"search_pagination\",\n                description=\"Pagination search using search ID for dt or tt service\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt or tt)\",\n                            \"enum\": [\"dt\", \"tt\"],\n                        },\n                        \"search_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search ID from previous search\",\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                    },\n                    \"required\": [\"service\", \"search_id\"],\n                },\n            ),\n            Tool(\n                name=\"get_user_quotas\",\n                description=\"Get API usage quotas by service\",\n                inputSchema={\"type\": \"object\", \"properties\": {}, \"required\": []},\n            ),\n        ]\n    except Exception as e:\n        print(f\"Error in handle_list_tools: {e}\", file=sys.stderr)\n        import traceback\n\n        traceback.print_exc(file=sys.stderr)\n        return []\n\n\ndef apply_default_behavior(name: str, arguments: dict[str, Any], prompt: Optional[str] = None) -> dict[str, Any]:\n    \"\"\"Apply default behavior rules to tool arguments based on tool name and optional prompt context.\n    \n    Args:\n        name: The tool name being called\n        arguments: The original arguments dictionary\n        prompt: Optional prompt context to influence behavior\n        \n    Returns:\n        Modified arguments dictionary with defaults applied\n    \"\"\"\n    # Create a copy to avoid mutating the original\n    modified_args = arguments.copy()\n    \n    # Apply limit defaults based on tool type\n    if \"limit\" in modified_args:\n        if name in [\"search_darkweb\", \"search_telegram\"]:\n            # For general searches, use smaller limit unless prompt suggests otherwise\n            if prompt and (\"detailed\" in prompt.lower() or \"comprehensive\" in prompt.lower()):\n                modified_args[\"limit\"] = 20\n            else:\n                modified_args[\"limit\"] = 10\n        elif name in [\n            \"search_credentials\",\n            \"search_ransomware\", \n            \"search_compromised_dataset\",\n            \"search_combo_binder\",\n            \"search_ulp_binder\",\n            \"search_government_monitoring\",\n            \"search_leaked_monitoring\",\n        ]:\n            # For sensitive data searches, use larger limit by default\n            if prompt and \"quick\" in prompt.lower():\n                modified_args[\"limit\"] = 20\n            else:\n                modified_args[\"limit\"] = 50\n\n    # Handle indicator defaults for search tools\n    if name in [\"search_darkweb\", \"search_telegram\"]:\n        if \"indicator\" not in modified_args or not modified_args[\"indicator\"]:\n            # Default to keyword search unless prompt suggests otherwise\n            if prompt:\n                if \"domain\" in prompt.lower():\n                    modified_args[\"indicator\"] = \"domain\"\n                elif \"ip\" in prompt.lower() or \"address\" in prompt.lower():\n                    modified_args[\"indicator\"] = \"ip\"\n                elif \"email\" in prompt.lower():\n                    modified_args[\"indicator\"] = \"email\"\n                else:\n                    modified_args[\"indicator\"] = \"keyword\"\n            else:\n                modified_args[\"indicator\"] = \"keyword\"\n    \n    # Add date range defaults based on prompt context\n    if prompt and \"start_date\" not in modified_args:\n        if \"recent\" in prompt.lower() or \"latest\" in prompt.lower():\n            # Set start_date to 7 days ago for recent searches\n            from datetime import datetime, timedelta\n            start_date = (datetime.now() - timedelta(days=7)).strftime(\"%Y-%m-%d\")\n            modified_args[\"start_date\"] = start_date\n        elif \"last month\" in prompt.lower():\n            from datetime import datetime, timedelta\n            start_date = (datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%d\")\n            modified_args[\"start_date\"] = start_date\n    \n    return modified_args\n\n\ndef removal_empty(result: dict[str, Any]) -> dict[str, Any]:\n    \"\"\"Remove empty keys from result.\"\"\"\n    keys_to_remove = [key for key in result.keys() if result[key].get(\"totalCount\") == 0]\n    for key in keys_to_remove:\n        del result[key]\n    return result\n    \n\ndef removal_highlight(result: dict[str, Any]) -> dict[str, Any]:\n    \"\"\"Remove highlight from result.\"\"\"\n    for key in list(result.keys()):\n        if len(result[key][\"data\"]) > 0:\n            for contents in result[key][\"data\"]:\n                if \"highlight\" in contents:\n                    del contents[\"highlight\"]\n    return result\n\ndef removal_empty_metadata(result: dict[str, Any]) -> dict[str, Any]:\n    \"\"\"Remove metadata from result.\"\"\"\n    for key in list(result.keys()):\n        if len(result[key][\"data\"]) > 0:\n            for contents in result[key][\"data\"]:\n                if bool(contents.get(\"metadata\")) == False:\n                    del contents[\"metadata\"]\n    return result\n\n@server.call_tool()\nasync def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:\n    \"\"\"Handle tool calls with default behavior applied.\"\"\"\n\n    # Extract prompt from arguments if provided (for context-aware defaults)\n    prompt = arguments.pop(\"_prompt\", None) if \"_prompt\" in arguments else None\n    \n    # Apply default behavior rules with prompt context\n    arguments = apply_default_behavior(name, arguments, prompt)\n\n    try:\n        if name == \"search_darkweb\":\n            result = await search_darkweb(\n                indicator=arguments[\"indicator\"],\n                text=arguments[\"text\"],\n                target=arguments.get(\"target\", \"all\"),\n                limit=arguments.get(\"limit\", 10),\n                orderType=arguments.get(\"orderType\", \"createDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n\n            if type(result) == dict:\n                result = removal_empty(result)\n                result = removal_highlight(result)\n                result = removal_empty_metadata(result)\n\n        elif name == \"search_telegram\":\n            result = await search_telegram(\n                indicator=arguments[\"indicator\"],\n                text=arguments[\"text\"],\n                target=arguments.get(\"target\", \"all\"),\n                limit=arguments.get(\"limit\", 10),\n                orderType=arguments.get(\"orderType\", \"createDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n\n            if type(result) == dict:\n                result = removal_empty(result)\n                result = removal_highlight(result)\n                result = removal_empty_metadata(result)\n\n        elif name == \"search_credentials\":\n            result = await search_credentials(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"leakedDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n                start=arguments.get(\"start\"),\n                end=arguments.get(\"end\"),\n            )\n        elif name == \"search_ransomware\":\n            result = await search_ransomware(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"get_node_details\":\n            result = await get_node_details(\n                service=arguments[\"service\"],\n                node_id=arguments[\"node_id\"],\n                pid=arguments.get(\"pid\"),\n                data_from=arguments.get(\"data_from\", False),\n                include_url=arguments.get(\"include_url\", False),\n                include_contents=arguments.get(\"include_contents\", True),\n            )\n        elif name == \"get_targets\":\n            result = await get_targets(\n                service=arguments[\"service\"], indicator=arguments[\"indicator\"]\n            )\n        elif name == \"export_data\":\n            result = await export_data(\n                service=arguments[\"service\"],\n                indicator=arguments[\"indicator\"],\n                format=arguments.get(\"format\", \"json\"),\n            )\n        elif name == \"search_compromised_dataset\":\n            result = await search_compromised_dataset(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"get_compromised_dataset_node\":\n            result = await get_compromised_dataset_node(\n                node_id=arguments[\"node_id\"]\n            )\n        elif name == \"search_combo_binder\":\n            result = await search_combo_binder(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"search_ulp_binder\":\n            result = await search_ulp_binder(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"search_government_monitoring\":\n            result = await search_government_monitoring(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_leaked_monitoring\":\n            result = await search_leaked_monitoring(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"download_file\":\n            file_content = await download_file(\n                service=arguments[\"service\"], file_hash=arguments[\"file_hash\"]\n            )\n            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"Downloaded file {arguments['file_hash']} from {arguments['service']} service. File size: {len(file_content)} bytes\",\n                )\n            ]\n        elif name == \"search_pagination\":\n            result = await search_pagination(\n                service=arguments[\"service\"],\n                search_id=arguments[\"search_id\"],\n                cursor=arguments.get(\"cursor\", 0),\n                limit=arguments.get(\"limit\", 50),\n            )\n        elif name == \"get_user_quotas\":\n            result = await get_user_quotas()\n        else:\n            return [TextContent(type=\"text\", text=f\"Unknown tool: {name}\")]\n\n        # Format response\n        # result remove whitespace\n        response_text = f\"{result}\"\n        return [\n            TextContent(\n                type=\"text\",\n                text=response_text,\n            )\n        ]\n\n    except asyncio.TimeoutError:\n        return [\n            TextContent(\n                type=\"text\",\n                text=\"Request timed out. The API request took too long to complete.\",\n            )\n        ]\n    except Exception as e:\n        error_msg = str(e)\n        if \"timeout\" in error_msg.lower():\n            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"Timeout error: {error_msg}. Try reducing the result limit or check your network connection.\",\n                )\n            ]\n        return [\n            TextContent(\n                type=\"text\",\n                text=f\"Error calling StealthMole API: {error_msg}\",\n            )\n        ]\n\n\nasync def run_server():\n    \"\"\"Run the MCP server.\"\"\"\n    try:\n        print(\"Starting StealthMole MCP server...\", file=sys.stderr)\n\n        # Check environment variables\n        access_key = os.getenv(\"STEALTHMOLE_ACCESS_KEY\")\n        secret_key = os.getenv(\"STEALTHMOLE_SECRET_KEY\")\n\n        print(f\"Access key: {'SET' if access_key else 'NOT SET'}\", file=sys.stderr)\n        print(f\"Secret key: {'SET' if secret_key else 'NOT SET'}\", file=sys.stderr)\n\n        if not access_key or not secret_key:\n            print(\n                \"Warning: STEALTHMOLE_ACCESS_KEY and STEALTHMOLE_SECRET_KEY environment variables not set\",\n                file=sys.stderr,\n            )\n            print(\"MCP server will start but tools will not function\", file=sys.stderr)\n        else:\n            try:\n                # API 연결 테스트 (타임아웃 없이 간단히)\n                try:\n                    quotas = await get_user_quotas()\n                    print(\n                        f\"✓ API connection successful. Available quotas: {quotas}\",\n                        file=sys.stderr,\n                    )\n                except Exception as api_error:\n                    print(f\"Warning: API test failed: {api_error}\", file=sys.stderr)\n                    print(\"Continuing with server startup...\", file=sys.stderr)\n\n            except Exception as e:\n                print(\n                    f\"Warning: Error testing API connection: {e}\", file=sys.stderr\n                )\n                print(\n                    \"MCP server will start but tools may not function properly\",\n                    file=sys.stderr,\n                )\n                import traceback\n\n                traceback.print_exc(file=sys.stderr)\n\n        print(\"Creating stdio server...\", file=sys.stderr)\n        async with stdio_server() as (read_stream, write_stream):\n            print(\"Starting MCP server...\", file=sys.stderr)\n            try:\n                await server.run(\n                    read_stream,\n                    write_stream,\n                    InitializationOptions(\n                        server_name=\"stealthmole-mcp\",\n                        server_version=\"1.0.0\",\n                        capabilities=server.get_capabilities(\n                            notification_options=NotificationOptions(),\n                            experimental_capabilities={},\n                        ),\n                    ),\n                )\n                print(\"MCP server completed normally\", file=sys.stderr)\n            except Exception as e:\n                print(f\"Error in MCP server.run: {e}\", file=sys.stderr)\n                import traceback\n\n                traceback.print_exc(file=sys.stderr)\n                raise\n    except Exception as e:\n        print(f\"Error in run_server: {e}\", file=sys.stderr)\n        import traceback\n\n        traceback.print_exc(file=sys.stderr)\n\n\ndef main():\n    \"\"\"Main entry point for the MCP server.\"\"\"\n    asyncio.run(run_server())\n\n\nif __name__ == \"__main__\":\n    main()\n","structuredPatch":[{"oldStart":716,"oldLines":16,"newStart":716,"newLines":19,"lines":["                 modified_args[\"indicator\"] = \"keyword\"","     ","     # Add date range defaults based on prompt context","-    if prompt and \"start_date\" not in modified_args:","-        if \"recent\" in prompt.lower() or \"latest\" in prompt.lower():","+    if \"start_date\" not in modified_args:","+        from datetime import datetime, timedelta","+        if prompt and (\"recent\" in prompt.lower() or \"latest\" in prompt.lower()):","             # Set start_date to 7 days ago for recent searches","-            from datetime import datetime, timedelta","             start_date = (datetime.now() - timedelta(days=7)).strftime(\"%Y-%m-%d\")","             modified_args[\"start_date\"] = start_date","-        elif \"last month\" in prompt.lower():","-            from datetime import datetime, timedelta","+        elif prompt and \"last month\" in prompt.lower():","             start_date = (datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%d\")","             modified_args[\"start_date\"] = start_date","+        else:","+            # Default to 1 year ago","+            start_date = (datetime.now() - timedelta(days=365)).strftime(\"%Y-%m-%d\")","+            modified_args[\"start_date\"] = start_date","     ","     return modified_args"," "]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"a43133b4-13d5-4fc1-bd19-429416c54302","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"7eaedb61-e6af-4956-ab4d-ee3971985adb","version":"1.0.58","gitBranch":"main","message":{"id":"msg_015KHTnKf4833hMhs7QEN8fQ","type":"message","role":"assistant","model":"claude-opus-4-20250514","content":[{"type":"text","text":"기본 검색 기간을 1년으로 설정했습니다. 이제 `start_date`가 지정되지 않은 경우:\n- \"recent\" 또는 \"latest\" 키워드가 있으면: 7일 전부터 검색\n- \"last month\" 키워드가 있으면: 30일 전부터 검색  \n- 그 외의 경우: **1년 전부터 검색** (기본값)"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":925,"cache_read_input_tokens":17213,"output_tokens":133,"service_tier":"standard"}},"requestId":"req_011CRR1BUbbBD9URj9JU113w","type":"assistant","uuid":"b2daada4-0ffb-435a-990b-6ecfc4ac5db2","timestamp":"2025-07-24T01:49:40.367Z"}
{"parentUuid":"b2daada4-0ffb-435a-990b-6ecfc4ac5db2","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"7eaedb61-e6af-4956-ab4d-ee3971985adb","version":"1.0.58","gitBranch":"main","type":"user","message":{"role":"user","content":"아니야 날짜 제한은 없는게 더 좋을꺼 같아 "},"uuid":"e19f9582-38f9-4f20-bf4f-f53e9398662f","timestamp":"2025-07-24T01:51:45.721Z"}
{"parentUuid":"e19f9582-38f9-4f20-bf4f-f53e9398662f","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"7eaedb61-e6af-4956-ab4d-ee3971985adb","version":"1.0.58","gitBranch":"main","message":{"id":"msg_01TJ5UpLravWcYhS8JbSKZQk","type":"message","role":"assistant","model":"claude-opus-4-20250514","content":[{"type":"text","text":"날짜 제한을 제거하겠습니다."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":869,"cache_read_input_tokens":18138,"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CRR1M3pMU26hyjUUnuRBS","type":"assistant","uuid":"07440f8c-2ce5-4aa6-8238-be13913f88c4","timestamp":"2025-07-24T01:51:49.311Z"}
{"parentUuid":"07440f8c-2ce5-4aa6-8238-be13913f88c4","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"7eaedb61-e6af-4956-ab4d-ee3971985adb","version":"1.0.58","gitBranch":"main","message":{"id":"msg_01TJ5UpLravWcYhS8JbSKZQk","type":"message","role":"assistant","model":"claude-opus-4-20250514","content":[{"type":"tool_use","id":"toolu_01X1R45TuW4ZK5Pu73rU9FWf","name":"Edit","input":{"file_path":"/Users/realsun/data/git/mole-mcp-server/src/stealthmole_mcp/server.py","old_string":"    # Add date range defaults based on prompt context\n    if \"start_date\" not in modified_args:\n        if prompt and \"last month\" in prompt.lower():\n            start_date = (datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%d\")\n            modified_args[\"start_date\"] = start_date\n        else:\n            # Default to 1 year ago\n            start_date = (datetime.now() - timedelta(days=365)).strftime(\"%Y-%m-%d\")\n            modified_args[\"start_date\"] = start_date","new_string":"    # Add date range defaults based on prompt context\n    if prompt and \"start_date\" not in modified_args:\n        if \"recent\" in prompt.lower() or \"latest\" in prompt.lower():\n            # Set start_date to 7 days ago for recent searches\n            start_date = (datetime.now() - timedelta(days=7)).strftime(\"%Y-%m-%d\")\n            modified_args[\"start_date\"] = start_date\n        elif \"last month\" in prompt.lower():\n            start_date = (datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%d\")\n            modified_args[\"start_date\"] = start_date"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":869,"cache_read_input_tokens":18138,"output_tokens":433,"service_tier":"standard"}},"requestId":"req_011CRR1M3pMU26hyjUUnuRBS","type":"assistant","uuid":"8c16ba34-e06d-465f-b938-9b5bd262cbb2","timestamp":"2025-07-24T01:51:54.201Z"}
{"parentUuid":"8c16ba34-e06d-465f-b938-9b5bd262cbb2","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"7eaedb61-e6af-4956-ab4d-ee3971985adb","version":"1.0.58","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01X1R45TuW4ZK5Pu73rU9FWf","type":"tool_result","content":"The file /Users/realsun/data/git/mole-mcp-server/src/stealthmole_mcp/server.py has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   715→                    modified_args[\"indicator\"] = \"keyword\"\n   716→            else:\n   717→                modified_args[\"indicator\"] = \"keyword\"\n   718→    \n   719→    # Add date range defaults based on prompt context\n   720→    if prompt and \"start_date\" not in modified_args:\n   721→        if \"recent\" in prompt.lower() or \"latest\" in prompt.lower():\n   722→            # Set start_date to 7 days ago for recent searches\n   723→            start_date = (datetime.now() - timedelta(days=7)).strftime(\"%Y-%m-%d\")\n   724→            modified_args[\"start_date\"] = start_date\n   725→        elif \"last month\" in prompt.lower():\n   726→            start_date = (datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%d\")\n   727→            modified_args[\"start_date\"] = start_date\n   728→    \n   729→    return modified_args\n   730→\n   731→"}]},"uuid":"702cd292-6296-467e-b6e7-0c950c810281","timestamp":"2025-07-24T01:51:54.242Z","toolUseResult":{"filePath":"/Users/realsun/data/git/mole-mcp-server/src/stealthmole_mcp/server.py","oldString":"    # Add date range defaults based on prompt context\n    if \"start_date\" not in modified_args:\n        if prompt and \"last month\" in prompt.lower():\n            start_date = (datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%d\")\n            modified_args[\"start_date\"] = start_date\n        else:\n            # Default to 1 year ago\n            start_date = (datetime.now() - timedelta(days=365)).strftime(\"%Y-%m-%d\")\n            modified_args[\"start_date\"] = start_date","newString":"    # Add date range defaults based on prompt context\n    if prompt and \"start_date\" not in modified_args:\n        if \"recent\" in prompt.lower() or \"latest\" in prompt.lower():\n            # Set start_date to 7 days ago for recent searches\n            start_date = (datetime.now() - timedelta(days=7)).strftime(\"%Y-%m-%d\")\n            modified_args[\"start_date\"] = start_date\n        elif \"last month\" in prompt.lower():\n            start_date = (datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%d\")\n            modified_args[\"start_date\"] = start_date","originalFile":"\"\"\"StealthMole MCP Server implementation.\"\"\"\n\nimport asyncio\nimport os\nimport sys\nfrom datetime import datetime, timedelta\nfrom typing import Any, Optional, Sequence\n\nfrom click import prompt\nfrom dotenv import load_dotenv\nfrom mcp.server import NotificationOptions, Server\nfrom mcp.server.models import InitializationOptions\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import (\n    GetPromptResult,\n    Prompt,\n    PromptArgument,\n    PromptMessage,\n    Resource,\n    TextContent,\n    Tool,\n)\nfrom pydantic import AnyUrl\n\nfrom .tools import *\n\nload_dotenv()\n\nprompts_path = os.path.join(os.path.dirname(__file__), \"prompt\")\n\nserver: Server = Server(\n    \"stealthmole-mcp\",\n    \"250715\",\n)\n\n\n@server.list_resources()\nasync def handle_list_resources() -> list[Resource]:\n    \"\"\"List available resources.\"\"\"\n    return []\n\n\n@server.read_resource()\nasync def handle_read_resource(uri: AnyUrl) -> str:\n    \"\"\"Read a specific resource.\"\"\"\n    raise ValueError(f\"Unknown resource: {uri}\")\n\n\n@server.list_prompts()\nasync def handle_list_prompts() -> list[Prompt]:\n    \"\"\"List available prompts.\"\"\"\n    return [\n        Prompt(\n            name=\"stealthmole_default_prompt\",\n            description=\"Default behavior guidelines for StealthMole MCP\",\n            arguments=[\n                PromptArgument(\n                    name=\"context\",\n                    description=\"Current search context\",\n                    required=False,\n                )\n            ],\n        )\n    ]\n\n\n@server.get_prompt()\nasync def handle_get_prompt(\n    name: str, arguments: dict[str, str] | None = None\n) -> GetPromptResult:\n    \"\"\"Get a specific prompt.\"\"\"\n    if name == \"stealthmole_default_prompt\":\n        return GetPromptResult(\n            messages=[\n                PromptMessage(\n                    role=\"assistant\",\n                    content=TextContent(\n                        type=\"text\",\n                        text=open(f\"{prompts_path}/default_prompt.md\").read(),\n                    ),\n                )\n            ]\n        )\n    else:\n        raise ValueError(f\"Unknown prompt: {name}\")\n\n\n@server.list_tools()\nasync def handle_list_tools() -> list[Tool]:\n    \"\"\"List available StealthMole tools.\"\"\"\n    try:\n        print(\"Returning StealthMole tools list\", file=sys.stderr)\n        return [\n            Tool(\n                name=\"search_darkweb\",\n                description=\"Search dark web content for indicators like domains, IPs, emails, etc.\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type to search for\",\n                            \"enum\": [\n                                \"adsense\",\n                                \"analyticsid\",\n                                \"band\",\n                                \"bitcoin\",\n                                \"blueprint\",\n                                \"creditcard\",\n                                \"cve\",\n                                \"discord\",\n                                \"document\",\n                                \"domain\",\n                                \"email\",\n                                \"ethereum\",\n                                \"exefile\",\n                                \"facebook\",\n                                \"filehosting\",\n                                \"googledrive\",\n                                \"gps\",\n                                \"hash\",\n                                \"hashstring\",\n                                \"i2p\",\n                                \"i2purl\",\n                                \"id\",\n                                \"image\",\n                                \"instagram\",\n                                \"ioc\",\n                                \"ip\",\n                                \"kakaotalk\",\n                                \"keyword\",\n                                \"kssn\",\n                                \"leakedaudio\",\n                                \"leakedemailfile\",\n                                \"leakedvideo\",\n                                \"line\",\n                                \"linkedin\",\n                                \"malware\",\n                                \"monero\",\n                                \"otherfile\",\n                                \"pastebin\",\n                                \"pgp\",\n                                \"serverstatus\",\n                                \"session\",\n                                \"shorten\",\n                                \"sshkey\",\n                                \"sslkey\",\n                                \"tel\",\n                                \"telegram\",\n                                \"tor\",\n                                \"torurl\",\n                                \"twitter\",\n                                \"url\",\n                                \"iol\",\n                            ],\n                        },\n                        \"text\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search keyword or data to find. Supports AND, OR, NOT operators (max 3 OR, 5 total operators)\",\n                        },\n                        \"target\": {\n                            \"type\": \"string\",\n                            \"description\": \"Target type to search (default: 'all'). Use comma-separated values for multiple targets\",\n                            \"default\": \"all\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Ordering type\",\n                            \"enum\": [\"createDate\", \"value\"],\n                            \"default\": \"createDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\", \"text\"],\n                },\n            ),\n            Tool(\n                name=\"search_telegram\",\n                description=\"Search Telegram content for indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type to search for\",\n                            \"enum\": [\n                                \"band\",\n                                \"bitcoin\",\n                                \"creditcard\",\n                                \"cve\",\n                                \"discord\",\n                                \"document\",\n                                \"domain\",\n                                \"email\",\n                                \"ethereum\",\n                                \"exefile\",\n                                \"facebook\",\n                                \"filehosting\",\n                                \"googledrive\",\n                                \"gps\",\n                                \"hash\",\n                                \"hashstring\",\n                                \"i2p\",\n                                \"i2purl\",\n                                \"id\",\n                                \"image\",\n                                \"instagram\",\n                                \"ip\",\n                                \"kakaotalk\",\n                                \"keyword\",\n                                \"kssn\",\n                                \"line\",\n                                \"monero\",\n                                \"otherfile\",\n                                \"pastebin\",\n                                \"pgp\",\n                                \"tel\",\n                                \"session\",\n                                \"shorten\",\n                                \"telegram\",\n                                \"telegram.channel\",\n                                \"telegram.message\",\n                                \"telegram.user\",\n                                \"tor\",\n                                \"torurl\",\n                                \"tox\",\n                                \"twitter\",\n                                \"url\",\n                            ],\n                        },\n                        \"text\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search keyword or data to find. Supports AND, OR, NOT operators (max 3 OR, 5 total operators)\",\n                        },\n                        \"target\": {\n                            \"type\": \"string\",\n                            \"description\": \"Target type to search (default: 'all'). Use comma-separated values for multiple targets\",\n                            \"default\": \"all\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Ordering type\",\n                            \"enum\": [\"createDate\", \"value\"],\n                            \"default\": \"createDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\", \"text\"],\n                },\n            ),\n            Tool(\n                name=\"search_credentials\",\n                description=\"Search for leaked credentials using keywords or specific indicators (domain:, email:, id:, password:, after:, before:)\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - can use indicators like 'domain:example.com', 'email:user@domain.com', 'id:username', 'password:pass123', 'after:2023-01', 'before:2024-01' or plain keywords\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\n                                \"leakedDate\",\n                                \"domain\",\n                                \"email\",\n                                \"password\",\n                                \"leakedFrom\",\n                            ],\n                            \"default\": \"leakedDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                        \"start\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Filter data added to the system after start time (UTC timestamp)\",\n                        },\n                        \"end\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Filter data added to the system before end time (UTC timestamp)\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_ransomware\",\n                description=\"Search ransomware monitoring data using torurl: or domain: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'torurl:site.onion' to search ransomware sites or 'domain:victim.com' to search victim websites. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"victim\", \"attackGroup\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"get_node_details\",\n                description=\"Get detailed information about a specific node\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"node_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Node ID to get details for\",\n                        },\n                        \"pid\": {\n                            \"type\": \"string\",\n                            \"description\": \"Parent node ID (optional)\",\n                        },\n                        \"data_from\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Import data source list (default: False)\",\n                            \"default\": False,\n                        },\n                        \"include_url\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Import included URL list (default: False)\",\n                            \"default\": False,\n                        },\n                        \"include_contents\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Include HTML source contents for torurl, i2purl, url (default: True)\",\n                            \"default\": True,\n                        },\n                    },\n                    \"required\": [\"service\", \"node_id\"],\n                },\n            ),\n            Tool(\n                name=\"get_targets\",\n                description=\"Get available search targets for a service and indicator\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type\",\n                        },\n                    },\n                    \"required\": [\"service\", \"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_data\",\n                description=\"Export search results in specified format\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"service\", \"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_compromised_dataset\",\n                description=\"Search compromised data set information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"get_compromised_dataset_node\",\n                description=\"Get detailed compromised data set node information (Cyber Security Edition required)\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"node_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Node ID to get details for\",\n                        }\n                    },\n                    \"required\": [\"node_id\"],\n                },\n            ),\n            Tool(\n                name=\"search_combo_binder\",\n                description=\"Search leaked ID/Password combo information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_ulp_binder\",\n                description=\"Search URL-Login-Password combination information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_government_monitoring\",\n                description=\"Search government sector threat monitoring data using url: or id: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'url:hackersite.com' to search threat event URLs or 'id:hacker123' to search actor IDs. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"title\", \"author\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_leaked_monitoring\",\n                description=\"Search enterprise sector threat monitoring data using url: or id: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'url:hackersite.com' to search threat event URLs or 'id:hacker123' to search actor IDs. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"title\", \"author\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"download_file\",\n                description=\"Download file by hash from dt or tt service\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt or tt)\",\n                            \"enum\": [\"dt\", \"tt\"],\n                        },\n                        \"file_hash\": {\n                            \"type\": \"string\",\n                            \"description\": \"File hash to download\",\n                        },\n                    },\n                    \"required\": [\"service\", \"file_hash\"],\n                },\n            ),\n            Tool(\n                name=\"search_pagination\",\n                description=\"Pagination search using search ID for dt or tt service\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt or tt)\",\n                            \"enum\": [\"dt\", \"tt\"],\n                        },\n                        \"search_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search ID from previous search\",\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                    },\n                    \"required\": [\"service\", \"search_id\"],\n                },\n            ),\n            Tool(\n                name=\"get_user_quotas\",\n                description=\"Get API usage quotas by service\",\n                inputSchema={\"type\": \"object\", \"properties\": {}, \"required\": []},\n            ),\n        ]\n    except Exception as e:\n        print(f\"Error in handle_list_tools: {e}\", file=sys.stderr)\n        import traceback\n\n        traceback.print_exc(file=sys.stderr)\n        return []\n\n\ndef apply_default_behavior(name: str, arguments: dict[str, Any], prompt: Optional[str] = None) -> dict[str, Any]:\n    \"\"\"Apply default behavior rules to tool arguments based on tool name and optional prompt context.\n    \n    Args:\n        name: The tool name being called\n        arguments: The original arguments dictionary\n        prompt: Optional prompt context to influence behavior\n        \n    Returns:\n        Modified arguments dictionary with defaults applied\n    \"\"\"\n    # Create a copy to avoid mutating the original\n    modified_args = arguments.copy()\n    \n    # Apply limit defaults based on tool type\n    if \"limit\" in modified_args:\n        if name in [\"search_darkweb\", \"search_telegram\"]:\n            # For general searches, use smaller limit unless prompt suggests otherwise\n            if prompt and (\"detailed\" in prompt.lower() or \"comprehensive\" in prompt.lower()):\n                modified_args[\"limit\"] = 20\n            else:\n                modified_args[\"limit\"] = 10\n        elif name in [\n            \"search_credentials\",\n            \"search_ransomware\", \n            \"search_compromised_dataset\",\n            \"search_combo_binder\",\n            \"search_ulp_binder\",\n            \"search_government_monitoring\",\n            \"search_leaked_monitoring\",\n        ]:\n            # For sensitive data searches, use larger limit by default\n            if prompt and \"quick\" in prompt.lower():\n                modified_args[\"limit\"] = 20\n            else:\n                modified_args[\"limit\"] = 50\n\n    # Handle indicator defaults for search tools\n    if name in [\"search_darkweb\", \"search_telegram\"]:\n        if \"indicator\" not in modified_args or not modified_args[\"indicator\"]:\n            # Default to keyword search unless prompt suggests otherwise\n            if prompt:\n                if \"domain\" in prompt.lower():\n                    modified_args[\"indicator\"] = \"domain\"\n                elif \"ip\" in prompt.lower() or \"address\" in prompt.lower():\n                    modified_args[\"indicator\"] = \"ip\"\n                elif \"email\" in prompt.lower():\n                    modified_args[\"indicator\"] = \"email\"\n                else:\n                    modified_args[\"indicator\"] = \"keyword\"\n            else:\n                modified_args[\"indicator\"] = \"keyword\"\n    \n    # Add date range defaults based on prompt context\n    if \"start_date\" not in modified_args:\n        if prompt and \"last month\" in prompt.lower():\n            start_date = (datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%d\")\n            modified_args[\"start_date\"] = start_date\n        else:\n            # Default to 1 year ago\n            start_date = (datetime.now() - timedelta(days=365)).strftime(\"%Y-%m-%d\")\n            modified_args[\"start_date\"] = start_date\n    \n    return modified_args\n\n\ndef removal_empty(result: dict[str, Any]) -> dict[str, Any]:\n    \"\"\"Remove empty keys from result.\"\"\"\n    keys_to_remove = [key for key in result.keys() if result[key].get(\"totalCount\") == 0]\n    for key in keys_to_remove:\n        del result[key]\n    return result\n    \n\ndef removal_highlight(result: dict[str, Any]) -> dict[str, Any]:\n    \"\"\"Remove highlight from result.\"\"\"\n    for key in list(result.keys()):\n        if len(result[key][\"data\"]) > 0:\n            for contents in result[key][\"data\"]:\n                if \"highlight\" in contents:\n                    del contents[\"highlight\"]\n    return result\n\ndef removal_empty_metadata(result: dict[str, Any]) -> dict[str, Any]:\n    \"\"\"Remove metadata from result.\"\"\"\n    for key in list(result.keys()):\n        if len(result[key][\"data\"]) > 0:\n            for contents in result[key][\"data\"]:\n                if bool(contents.get(\"metadata\")) == False:\n                    del contents[\"metadata\"]\n    return result\n\n@server.call_tool()\nasync def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:\n    \"\"\"Handle tool calls with default behavior applied.\"\"\"\n\n    # Extract prompt from arguments if provided (for context-aware defaults)\n    prompt = arguments.pop(\"_prompt\", None) if \"_prompt\" in arguments else None\n    \n    # Apply default behavior rules with prompt context\n    arguments = apply_default_behavior(name, arguments, prompt)\n\n    try:\n        if name == \"search_darkweb\":\n            result = await search_darkweb(\n                indicator=arguments[\"indicator\"],\n                text=arguments[\"text\"],\n                target=arguments.get(\"target\", \"all\"),\n                limit=arguments.get(\"limit\", 10),\n                orderType=arguments.get(\"orderType\", \"createDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n\n            if type(result) == dict:\n                result = removal_empty(result)\n                result = removal_highlight(result)\n                result = removal_empty_metadata(result)\n\n        elif name == \"search_telegram\":\n            result = await search_telegram(\n                indicator=arguments[\"indicator\"],\n                text=arguments[\"text\"],\n                target=arguments.get(\"target\", \"all\"),\n                limit=arguments.get(\"limit\", 10),\n                orderType=arguments.get(\"orderType\", \"createDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n\n            if type(result) == dict:\n                result = removal_empty(result)\n                result = removal_highlight(result)\n                result = removal_empty_metadata(result)\n\n        elif name == \"search_credentials\":\n            result = await search_credentials(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"leakedDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n                start=arguments.get(\"start\"),\n                end=arguments.get(\"end\"),\n            )\n        elif name == \"search_ransomware\":\n            result = await search_ransomware(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"get_node_details\":\n            result = await get_node_details(\n                service=arguments[\"service\"],\n                node_id=arguments[\"node_id\"],\n                pid=arguments.get(\"pid\"),\n                data_from=arguments.get(\"data_from\", False),\n                include_url=arguments.get(\"include_url\", False),\n                include_contents=arguments.get(\"include_contents\", True),\n            )\n        elif name == \"get_targets\":\n            result = await get_targets(\n                service=arguments[\"service\"], indicator=arguments[\"indicator\"]\n            )\n        elif name == \"export_data\":\n            result = await export_data(\n                service=arguments[\"service\"],\n                indicator=arguments[\"indicator\"],\n                format=arguments.get(\"format\", \"json\"),\n            )\n        elif name == \"search_compromised_dataset\":\n            result = await search_compromised_dataset(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"get_compromised_dataset_node\":\n            result = await get_compromised_dataset_node(\n                node_id=arguments[\"node_id\"]\n            )\n        elif name == \"search_combo_binder\":\n            result = await search_combo_binder(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"search_ulp_binder\":\n            result = await search_ulp_binder(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"search_government_monitoring\":\n            result = await search_government_monitoring(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_leaked_monitoring\":\n            result = await search_leaked_monitoring(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"download_file\":\n            file_content = await download_file(\n                service=arguments[\"service\"], file_hash=arguments[\"file_hash\"]\n            )\n            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"Downloaded file {arguments['file_hash']} from {arguments['service']} service. File size: {len(file_content)} bytes\",\n                )\n            ]\n        elif name == \"search_pagination\":\n            result = await search_pagination(\n                service=arguments[\"service\"],\n                search_id=arguments[\"search_id\"],\n                cursor=arguments.get(\"cursor\", 0),\n                limit=arguments.get(\"limit\", 50),\n            )\n        elif name == \"get_user_quotas\":\n            result = await get_user_quotas()\n        else:\n            return [TextContent(type=\"text\", text=f\"Unknown tool: {name}\")]\n\n        # Format response\n        # result remove whitespace\n        response_text = f\"{result}\"\n        return [\n            TextContent(\n                type=\"text\",\n                text=response_text,\n            )\n        ]\n\n    except asyncio.TimeoutError:\n        return [\n            TextContent(\n                type=\"text\",\n                text=\"Request timed out. The API request took too long to complete.\",\n            )\n        ]\n    except Exception as e:\n        error_msg = str(e)\n        if \"timeout\" in error_msg.lower():\n            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"Timeout error: {error_msg}. Try reducing the result limit or check your network connection.\",\n                )\n            ]\n        return [\n            TextContent(\n                type=\"text\",\n                text=f\"Error calling StealthMole API: {error_msg}\",\n            )\n        ]\n\n\nasync def run_server():\n    \"\"\"Run the MCP server.\"\"\"\n    try:\n        print(\"Starting StealthMole MCP server...\", file=sys.stderr)\n\n        # Check environment variables\n        access_key = os.getenv(\"STEALTHMOLE_ACCESS_KEY\")\n        secret_key = os.getenv(\"STEALTHMOLE_SECRET_KEY\")\n\n        print(f\"Access key: {'SET' if access_key else 'NOT SET'}\", file=sys.stderr)\n        print(f\"Secret key: {'SET' if secret_key else 'NOT SET'}\", file=sys.stderr)\n\n        if not access_key or not secret_key:\n            print(\n                \"Warning: STEALTHMOLE_ACCESS_KEY and STEALTHMOLE_SECRET_KEY environment variables not set\",\n                file=sys.stderr,\n            )\n            print(\"MCP server will start but tools will not function\", file=sys.stderr)\n        else:\n            try:\n                # API 연결 테스트 (타임아웃 없이 간단히)\n                try:\n                    quotas = await get_user_quotas()\n                    print(\n                        f\"✓ API connection successful. Available quotas: {quotas}\",\n                        file=sys.stderr,\n                    )\n                except Exception as api_error:\n                    print(f\"Warning: API test failed: {api_error}\", file=sys.stderr)\n                    print(\"Continuing with server startup...\", file=sys.stderr)\n\n            except Exception as e:\n                print(\n                    f\"Warning: Error testing API connection: {e}\", file=sys.stderr\n                )\n                print(\n                    \"MCP server will start but tools may not function properly\",\n                    file=sys.stderr,\n                )\n                import traceback\n\n                traceback.print_exc(file=sys.stderr)\n\n        print(\"Creating stdio server...\", file=sys.stderr)\n        async with stdio_server() as (read_stream, write_stream):\n            print(\"Starting MCP server...\", file=sys.stderr)\n            try:\n                await server.run(\n                    read_stream,\n                    write_stream,\n                    InitializationOptions(\n                        server_name=\"stealthmole-mcp\",\n                        server_version=\"1.0.0\",\n                        capabilities=server.get_capabilities(\n                            notification_options=NotificationOptions(),\n                            experimental_capabilities={},\n                        ),\n                    ),\n                )\n                print(\"MCP server completed normally\", file=sys.stderr)\n            except Exception as e:\n                print(f\"Error in MCP server.run: {e}\", file=sys.stderr)\n                import traceback\n\n                traceback.print_exc(file=sys.stderr)\n                raise\n    except Exception as e:\n        print(f\"Error in run_server: {e}\", file=sys.stderr)\n        import traceback\n\n        traceback.print_exc(file=sys.stderr)\n\n\ndef main():\n    \"\"\"Main entry point for the MCP server.\"\"\"\n    asyncio.run(run_server())\n\n\nif __name__ == \"__main__\":\n    main()\n","structuredPatch":[{"oldStart":717,"oldLines":14,"newStart":717,"newLines":14,"lines":["                 modified_args[\"indicator\"] = \"keyword\"","     ","     # Add date range defaults based on prompt context","-    if \"start_date\" not in modified_args:","-        if prompt and \"last month\" in prompt.lower():","+    if prompt and \"start_date\" not in modified_args:","+        if \"recent\" in prompt.lower() or \"latest\" in prompt.lower():","+            # Set start_date to 7 days ago for recent searches","+            start_date = (datetime.now() - timedelta(days=7)).strftime(\"%Y-%m-%d\")","+            modified_args[\"start_date\"] = start_date","+        elif \"last month\" in prompt.lower():","             start_date = (datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%d\")","             modified_args[\"start_date\"] = start_date","-        else:","-            # Default to 1 year ago","-            start_date = (datetime.now() - timedelta(days=365)).strftime(\"%Y-%m-%d\")","-            modified_args[\"start_date\"] = start_date","     ","     return modified_args"," "]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"702cd292-6296-467e-b6e7-0c950c810281","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"7eaedb61-e6af-4956-ab4d-ee3971985adb","version":"1.0.58","gitBranch":"main","message":{"id":"msg_01MCYBSKG7dsttamcFWj6nTW","type":"message","role":"assistant","model":"claude-opus-4-20250514","content":[{"type":"text","text":"날짜 제한을 제거했습니다. 이제:\n- 특별한 키워드가 없으면 날짜 제한 없이 전체 기간 검색\n- \"recent\" 또는 \"latest\": 7일 전부터\n- \"last month\": 30일 전부터"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":750,"cache_read_input_tokens":19007,"output_tokens":88,"service_tier":"standard"}},"requestId":"req_011CRR1MgD7iuteEobQ4i6iG","type":"assistant","uuid":"0bb3bd8c-a347-44ae-9df1-2799622964b6","timestamp":"2025-07-24T01:51:57.886Z"}
{"parentUuid":"0bb3bd8c-a347-44ae-9df1-2799622964b6","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"7eaedb61-e6af-4956-ab4d-ee3971985adb","version":"1.0.58","gitBranch":"main","type":"user","message":{"role":"user","content":"<command-message>review is running…</command-message>\n<command-name>/review</command-name>"},"uuid":"6bae79df-ea99-4dcd-88f0-d9f3fdc4e04c","timestamp":"2025-07-24T01:52:20.625Z"}
{"parentUuid":"6bae79df-ea99-4dcd-88f0-d9f3fdc4e04c","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"7eaedb61-e6af-4956-ab4d-ee3971985adb","version":"1.0.58","gitBranch":"main","type":"user","message":{"role":"user","content":[{"type":"text","text":"# Code Review\nReview the $ARGUMENTS code for bugs, security problems and performance issues. Be specific about what could go wrong.\n"}]},"isMeta":true,"uuid":"f9966c2d-031d-4678-bdef-e8eb5e2208a8","timestamp":"2025-07-24T01:52:20.625Z"}
{"parentUuid":"f9966c2d-031d-4678-bdef-e8eb5e2208a8","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"7eaedb61-e6af-4956-ab4d-ee3971985adb","version":"1.0.58","gitBranch":"main","message":{"id":"msg_01FTHpvvJUnszwjQskTExseV","type":"message","role":"assistant","model":"claude-opus-4-20250514","content":[{"type":"tool_use","id":"toolu_01CY4vtm9rkZuoVk325EKaXq","name":"TodoWrite","input":{"todos":[{"id":"1","content":"Review server.py imports and apply_default_behavior function","status":"in_progress","priority":"high"},{"id":"2","content":"Check for security vulnerabilities","status":"pending","priority":"high"},{"id":"3","content":"Identify performance issues","status":"pending","priority":"medium"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":580,"cache_read_input_tokens":19757,"output_tokens":189,"service_tier":"standard"}},"requestId":"req_011CRR1Pczh442RAYXKRXTi8","type":"assistant","uuid":"95e08637-c768-4fa9-a4f2-1415f4e9ad4a","timestamp":"2025-07-24T01:52:26.849Z"}
{"parentUuid":"95e08637-c768-4fa9-a4f2-1415f4e9ad4a","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"7eaedb61-e6af-4956-ab4d-ee3971985adb","version":"1.0.58","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CY4vtm9rkZuoVk325EKaXq","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"e1b4c21c-51f6-4b1f-9f02-14ca7af9ec60","timestamp":"2025-07-24T01:52:26.889Z","toolUseResult":{"oldTodos":[],"newTodos":[{"content":"Review server.py imports and apply_default_behavior function","status":"in_progress","priority":"high","id":"1"},{"content":"Check for security vulnerabilities","status":"pending","priority":"high","id":"2"},{"content":"Identify performance issues","status":"pending","priority":"medium","id":"3"}]}}
{"parentUuid":"e1b4c21c-51f6-4b1f-9f02-14ca7af9ec60","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"7eaedb61-e6af-4956-ab4d-ee3971985adb","version":"1.0.58","gitBranch":"main","message":{"id":"msg_01JmQWXmDcAeEUkW4w92yimY","type":"message","role":"assistant","model":"claude-opus-4-20250514","content":[{"type":"tool_use","id":"toolu_01WFnQsxNr9QNuQ5tZyUiXgo","name":"Read","input":{"file_path":"/Users/realsun/data/git/mole-mcp-server/src/stealthmole_mcp/server.py","limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":309,"cache_read_input_tokens":20337,"output_tokens":101,"service_tier":"standard"}},"requestId":"req_011CRR1Q5pz6iRZcLXmUu5Ei","type":"assistant","uuid":"2ad48e99-5286-4075-a26e-1db023084315","timestamp":"2025-07-24T01:52:30.484Z"}
{"parentUuid":"2ad48e99-5286-4075-a26e-1db023084315","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"7eaedb61-e6af-4956-ab4d-ee3971985adb","version":"1.0.58","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WFnQsxNr9QNuQ5tZyUiXgo","type":"tool_result","content":"     1→\"\"\"StealthMole MCP Server implementation.\"\"\"\n     2→\n     3→import asyncio\n     4→import os\n     5→import sys\n     6→from datetime import datetime, timedelta\n     7→from typing import Any, Optional, Sequence\n     8→\n     9→from click import prompt\n    10→from dotenv import load_dotenv\n    11→from mcp.server import NotificationOptions, Server\n    12→from mcp.server.models import InitializationOptions\n    13→from mcp.server.stdio import stdio_server\n    14→from mcp.types import (\n    15→    GetPromptResult,\n    16→    Prompt,\n    17→    PromptArgument,\n    18→    PromptMessage,\n    19→    Resource,\n    20→    TextContent,\n    21→    Tool,\n    22→)\n    23→from pydantic import AnyUrl\n    24→\n    25→from .tools import *\n    26→\n    27→load_dotenv()\n    28→\n    29→prompts_path = os.path.join(os.path.dirname(__file__), \"prompt\")\n    30→\n    31→server: Server = Server(\n    32→    \"stealthmole-mcp\",\n    33→    \"250715\",\n    34→)\n    35→\n    36→\n    37→@server.list_resources()\n    38→async def handle_list_resources() -> list[Resource]:\n    39→    \"\"\"List available resources.\"\"\"\n    40→    return []\n    41→\n    42→\n    43→@server.read_resource()\n    44→async def handle_read_resource(uri: AnyUrl) -> str:\n    45→    \"\"\"Read a specific resource.\"\"\"\n    46→    raise ValueError(f\"Unknown resource: {uri}\")\n    47→\n    48→\n    49→@server.list_prompts()\n    50→async def handle_list_prompts() -> list[Prompt]:\n    51→    \"\"\"List available prompts.\"\"\"\n    52→    return [\n    53→        Prompt(\n    54→            name=\"stealthmole_default_prompt\",\n    55→            description=\"Default behavior guidelines for StealthMole MCP\",\n    56→            arguments=[\n    57→                PromptArgument(\n    58→                    name=\"context\",\n    59→                    description=\"Current search context\",\n    60→                    required=False,\n    61→                )\n    62→            ],\n    63→        )\n    64→    ]\n    65→\n    66→\n    67→@server.get_prompt()\n    68→async def handle_get_prompt(\n    69→    name: str, arguments: dict[str, str] | None = None\n    70→) -> GetPromptResult:\n    71→    \"\"\"Get a specific prompt.\"\"\"\n    72→    if name == \"stealthmole_default_prompt\":\n    73→        return GetPromptResult(\n    74→            messages=[\n    75→                PromptMessage(\n    76→                    role=\"assistant\",\n    77→                    content=TextContent(\n    78→                        type=\"text\",\n    79→                        text=open(f\"{prompts_path}/default_prompt.md\").read(),\n    80→                    ),\n    81→                )\n    82→            ]\n    83→        )\n    84→    else:\n    85→        raise ValueError(f\"Unknown prompt: {name}\")\n    86→\n    87→\n    88→@server.list_tools()\n    89→async def handle_list_tools() -> list[Tool]:\n    90→    \"\"\"List available StealthMole tools.\"\"\"\n    91→    try:\n    92→        print(\"Returning StealthMole tools list\", file=sys.stderr)\n    93→        return [\n    94→            Tool(\n    95→                name=\"search_darkweb\",\n    96→                description=\"Search dark web content for indicators like domains, IPs, emails, etc.\",\n    97→                inputSchema={\n    98→                    \"type\": \"object\",\n    99→                    \"properties\": {\n   100→                        \"indicator\": {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"f37960f2-ed76-48dd-b97b-5dab1cfce866","timestamp":"2025-07-24T01:52:30.511Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/realsun/data/git/mole-mcp-server/src/stealthmole_mcp/server.py","content":"\"\"\"StealthMole MCP Server implementation.\"\"\"\n\nimport asyncio\nimport os\nimport sys\nfrom datetime import datetime, timedelta\nfrom typing import Any, Optional, Sequence\n\nfrom click import prompt\nfrom dotenv import load_dotenv\nfrom mcp.server import NotificationOptions, Server\nfrom mcp.server.models import InitializationOptions\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import (\n    GetPromptResult,\n    Prompt,\n    PromptArgument,\n    PromptMessage,\n    Resource,\n    TextContent,\n    Tool,\n)\nfrom pydantic import AnyUrl\n\nfrom .tools import *\n\nload_dotenv()\n\nprompts_path = os.path.join(os.path.dirname(__file__), \"prompt\")\n\nserver: Server = Server(\n    \"stealthmole-mcp\",\n    \"250715\",\n)\n\n\n@server.list_resources()\nasync def handle_list_resources() -> list[Resource]:\n    \"\"\"List available resources.\"\"\"\n    return []\n\n\n@server.read_resource()\nasync def handle_read_resource(uri: AnyUrl) -> str:\n    \"\"\"Read a specific resource.\"\"\"\n    raise ValueError(f\"Unknown resource: {uri}\")\n\n\n@server.list_prompts()\nasync def handle_list_prompts() -> list[Prompt]:\n    \"\"\"List available prompts.\"\"\"\n    return [\n        Prompt(\n            name=\"stealthmole_default_prompt\",\n            description=\"Default behavior guidelines for StealthMole MCP\",\n            arguments=[\n                PromptArgument(\n                    name=\"context\",\n                    description=\"Current search context\",\n                    required=False,\n                )\n            ],\n        )\n    ]\n\n\n@server.get_prompt()\nasync def handle_get_prompt(\n    name: str, arguments: dict[str, str] | None = None\n) -> GetPromptResult:\n    \"\"\"Get a specific prompt.\"\"\"\n    if name == \"stealthmole_default_prompt\":\n        return GetPromptResult(\n            messages=[\n                PromptMessage(\n                    role=\"assistant\",\n                    content=TextContent(\n                        type=\"text\",\n                        text=open(f\"{prompts_path}/default_prompt.md\").read(),\n                    ),\n                )\n            ]\n        )\n    else:\n        raise ValueError(f\"Unknown prompt: {name}\")\n\n\n@server.list_tools()\nasync def handle_list_tools() -> list[Tool]:\n    \"\"\"List available StealthMole tools.\"\"\"\n    try:\n        print(\"Returning StealthMole tools list\", file=sys.stderr)\n        return [\n            Tool(\n                name=\"search_darkweb\",\n                description=\"Search dark web content for indicators like domains, IPs, emails, etc.\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {","numLines":100,"startLine":1,"totalLines":994}}}
{"parentUuid":"f37960f2-ed76-48dd-b97b-5dab1cfce866","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"7eaedb61-e6af-4956-ab4d-ee3971985adb","version":"1.0.58","gitBranch":"main","message":{"id":"msg_01Dp4vCdEht2iTvdm6EPRBG1","type":"message","role":"assistant","model":"claude-opus-4-20250514","content":[{"type":"tool_use","id":"toolu_01A2vrXsQ4iCWWWDDpBzGMim","name":"Read","input":{"file_path":"/Users/realsun/data/git/mole-mcp-server/src/stealthmole_mcp/server.py","offset":650,"limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":1184,"cache_read_input_tokens":20646,"output_tokens":118,"service_tier":"standard"}},"requestId":"req_011CRR1QMGvC9Xvzw3Rtgvno","type":"assistant","uuid":"fe8fd626-62b3-430b-89ef-e82f0f6a7070","timestamp":"2025-07-24T01:52:35.569Z"}
{"parentUuid":"fe8fd626-62b3-430b-89ef-e82f0f6a7070","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"7eaedb61-e6af-4956-ab4d-ee3971985adb","version":"1.0.58","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01A2vrXsQ4iCWWWDDpBzGMim","type":"tool_result","content":"   650→                },\n   651→            ),\n   652→            Tool(\n   653→                name=\"get_user_quotas\",\n   654→                description=\"Get API usage quotas by service\",\n   655→                inputSchema={\"type\": \"object\", \"properties\": {}, \"required\": []},\n   656→            ),\n   657→        ]\n   658→    except Exception as e:\n   659→        print(f\"Error in handle_list_tools: {e}\", file=sys.stderr)\n   660→        import traceback\n   661→\n   662→        traceback.print_exc(file=sys.stderr)\n   663→        return []\n   664→\n   665→\n   666→def apply_default_behavior(name: str, arguments: dict[str, Any], prompt: Optional[str] = None) -> dict[str, Any]:\n   667→    \"\"\"Apply default behavior rules to tool arguments based on tool name and optional prompt context.\n   668→    \n   669→    Args:\n   670→        name: The tool name being called\n   671→        arguments: The original arguments dictionary\n   672→        prompt: Optional prompt context to influence behavior\n   673→        \n   674→    Returns:\n   675→        Modified arguments dictionary with defaults applied\n   676→    \"\"\"\n   677→    # Create a copy to avoid mutating the original\n   678→    modified_args = arguments.copy()\n   679→    \n   680→    # Apply limit defaults based on tool type\n   681→    if \"limit\" in modified_args:\n   682→        if name in [\"search_darkweb\", \"search_telegram\"]:\n   683→            # For general searches, use smaller limit unless prompt suggests otherwise\n   684→            if prompt and (\"detailed\" in prompt.lower() or \"comprehensive\" in prompt.lower()):\n   685→                modified_args[\"limit\"] = 20\n   686→            else:\n   687→                modified_args[\"limit\"] = 10\n   688→        elif name in [\n   689→            \"search_credentials\",\n   690→            \"search_ransomware\", \n   691→            \"search_compromised_dataset\",\n   692→            \"search_combo_binder\",\n   693→            \"search_ulp_binder\",\n   694→            \"search_government_monitoring\",\n   695→            \"search_leaked_monitoring\",\n   696→        ]:\n   697→            # For sensitive data searches, use larger limit by default\n   698→            if prompt and \"quick\" in prompt.lower():\n   699→                modified_args[\"limit\"] = 20\n   700→            else:\n   701→                modified_args[\"limit\"] = 50\n   702→\n   703→    # Handle indicator defaults for search tools\n   704→    if name in [\"search_darkweb\", \"search_telegram\"]:\n   705→        if \"indicator\" not in modified_args or not modified_args[\"indicator\"]:\n   706→            # Default to keyword search unless prompt suggests otherwise\n   707→            if prompt:\n   708→                if \"domain\" in prompt.lower():\n   709→                    modified_args[\"indicator\"] = \"domain\"\n   710→                elif \"ip\" in prompt.lower() or \"address\" in prompt.lower():\n   711→                    modified_args[\"indicator\"] = \"ip\"\n   712→                elif \"email\" in prompt.lower():\n   713→                    modified_args[\"indicator\"] = \"email\"\n   714→                else:\n   715→                    modified_args[\"indicator\"] = \"keyword\"\n   716→            else:\n   717→                modified_args[\"indicator\"] = \"keyword\"\n   718→    \n   719→    return modified_args\n   720→\n   721→\n   722→def removal_empty(result: dict[str, Any]) -> dict[str, Any]:\n   723→    \"\"\"Remove empty keys from result.\"\"\"\n   724→    keys_to_remove = [key for key in result.keys() if result[key].get(\"totalCount\") == 0]\n   725→    for key in keys_to_remove:\n   726→        del result[key]\n   727→    return result\n   728→    \n   729→\n   730→def removal_highlight(result: dict[str, Any]) -> dict[str, Any]:\n   731→    \"\"\"Remove highlight from result.\"\"\"\n   732→    for key in list(result.keys()):\n   733→        if len(result[key][\"data\"]) > 0:\n   734→            for contents in result[key][\"data\"]:\n   735→                if \"highlight\" in contents:\n   736→                    del contents[\"highlight\"]\n   737→    return result\n   738→\n   739→def removal_empty_metadata(result: dict[str, Any]) -> dict[str, Any]:\n   740→    \"\"\"Remove metadata from result.\"\"\"\n   741→    for key in list(result.keys()):\n   742→        if len(result[key][\"data\"]) > 0:\n   743→            for contents in result[key][\"data\"]:\n   744→                if bool(contents.get(\"metadata\")) == False:\n   745→                    del contents[\"metadata\"]\n   746→    return result\n   747→\n   748→@server.call_tool()\n   749→async def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"7ad859c9-4bca-48c5-86df-d931146f5feb","timestamp":"2025-07-24T01:52:35.587Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/realsun/data/git/mole-mcp-server/src/stealthmole_mcp/server.py","content":"                },\n            ),\n            Tool(\n                name=\"get_user_quotas\",\n                description=\"Get API usage quotas by service\",\n                inputSchema={\"type\": \"object\", \"properties\": {}, \"required\": []},\n            ),\n        ]\n    except Exception as e:\n        print(f\"Error in handle_list_tools: {e}\", file=sys.stderr)\n        import traceback\n\n        traceback.print_exc(file=sys.stderr)\n        return []\n\n\ndef apply_default_behavior(name: str, arguments: dict[str, Any], prompt: Optional[str] = None) -> dict[str, Any]:\n    \"\"\"Apply default behavior rules to tool arguments based on tool name and optional prompt context.\n    \n    Args:\n        name: The tool name being called\n        arguments: The original arguments dictionary\n        prompt: Optional prompt context to influence behavior\n        \n    Returns:\n        Modified arguments dictionary with defaults applied\n    \"\"\"\n    # Create a copy to avoid mutating the original\n    modified_args = arguments.copy()\n    \n    # Apply limit defaults based on tool type\n    if \"limit\" in modified_args:\n        if name in [\"search_darkweb\", \"search_telegram\"]:\n            # For general searches, use smaller limit unless prompt suggests otherwise\n            if prompt and (\"detailed\" in prompt.lower() or \"comprehensive\" in prompt.lower()):\n                modified_args[\"limit\"] = 20\n            else:\n                modified_args[\"limit\"] = 10\n        elif name in [\n            \"search_credentials\",\n            \"search_ransomware\", \n            \"search_compromised_dataset\",\n            \"search_combo_binder\",\n            \"search_ulp_binder\",\n            \"search_government_monitoring\",\n            \"search_leaked_monitoring\",\n        ]:\n            # For sensitive data searches, use larger limit by default\n            if prompt and \"quick\" in prompt.lower():\n                modified_args[\"limit\"] = 20\n            else:\n                modified_args[\"limit\"] = 50\n\n    # Handle indicator defaults for search tools\n    if name in [\"search_darkweb\", \"search_telegram\"]:\n        if \"indicator\" not in modified_args or not modified_args[\"indicator\"]:\n            # Default to keyword search unless prompt suggests otherwise\n            if prompt:\n                if \"domain\" in prompt.lower():\n                    modified_args[\"indicator\"] = \"domain\"\n                elif \"ip\" in prompt.lower() or \"address\" in prompt.lower():\n                    modified_args[\"indicator\"] = \"ip\"\n                elif \"email\" in prompt.lower():\n                    modified_args[\"indicator\"] = \"email\"\n                else:\n                    modified_args[\"indicator\"] = \"keyword\"\n            else:\n                modified_args[\"indicator\"] = \"keyword\"\n    \n    return modified_args\n\n\ndef removal_empty(result: dict[str, Any]) -> dict[str, Any]:\n    \"\"\"Remove empty keys from result.\"\"\"\n    keys_to_remove = [key for key in result.keys() if result[key].get(\"totalCount\") == 0]\n    for key in keys_to_remove:\n        del result[key]\n    return result\n    \n\ndef removal_highlight(result: dict[str, Any]) -> dict[str, Any]:\n    \"\"\"Remove highlight from result.\"\"\"\n    for key in list(result.keys()):\n        if len(result[key][\"data\"]) > 0:\n            for contents in result[key][\"data\"]:\n                if \"highlight\" in contents:\n                    del contents[\"highlight\"]\n    return result\n\ndef removal_empty_metadata(result: dict[str, Any]) -> dict[str, Any]:\n    \"\"\"Remove metadata from result.\"\"\"\n    for key in list(result.keys()):\n        if len(result[key][\"data\"]) > 0:\n            for contents in result[key][\"data\"]:\n                if bool(contents.get(\"metadata\")) == False:\n                    del contents[\"metadata\"]\n    return result\n\n@server.call_tool()\nasync def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:","numLines":100,"startLine":650,"totalLines":994}}}
{"parentUuid":"7ad859c9-4bca-48c5-86df-d931146f5feb","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"7eaedb61-e6af-4956-ab4d-ee3971985adb","version":"1.0.58","gitBranch":"main","message":{"id":"msg_0132VEXPnbZv6CP64s6qe8YN","type":"message","role":"assistant","model":"claude-opus-4-20250514","content":[{"type":"tool_use","id":"toolu_01P2c9oRHC9tm7SsoujXtjH5","name":"TodoWrite","input":{"todos":[{"id":"1","content":"Review server.py imports and apply_default_behavior function","status":"completed","priority":"high"},{"id":"2","content":"Check for security vulnerabilities","status":"in_progress","priority":"high"},{"id":"3","content":"Identify performance issues","status":"pending","priority":"medium"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":1470,"cache_read_input_tokens":21830,"output_tokens":147,"service_tier":"standard"}},"requestId":"req_011CRR1QiyPcWt1Djj7MxnHD","type":"assistant","uuid":"e93cf6c8-f372-48cc-bc3f-73f6d8d53d5a","timestamp":"2025-07-24T01:52:41.401Z"}
{"parentUuid":"e93cf6c8-f372-48cc-bc3f-73f6d8d53d5a","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"7eaedb61-e6af-4956-ab4d-ee3971985adb","version":"1.0.58","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01P2c9oRHC9tm7SsoujXtjH5","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"6bc06c49-b816-44e7-ad91-da1859a08dad","timestamp":"2025-07-24T01:52:41.425Z","toolUseResult":{"oldTodos":[{"content":"Review server.py imports and apply_default_behavior function","status":"in_progress","priority":"high","id":"1"},{"content":"Check for security vulnerabilities","status":"pending","priority":"high","id":"2"},{"content":"Identify performance issues","status":"pending","priority":"medium","id":"3"}],"newTodos":[{"content":"Review server.py imports and apply_default_behavior function","status":"completed","priority":"high","id":"1"},{"content":"Check for security vulnerabilities","status":"in_progress","priority":"high","id":"2"},{"content":"Identify performance issues","status":"pending","priority":"medium","id":"3"}]}}
{"parentUuid":"6bc06c49-b816-44e7-ad91-da1859a08dad","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"7eaedb61-e6af-4956-ab4d-ee3971985adb","version":"1.0.58","gitBranch":"main","message":{"id":"msg_01Jh14gsPrptpD8oMY9p9EU8","type":"message","role":"assistant","model":"claude-opus-4-20250514","content":[{"type":"tool_use","id":"toolu_01MAeLAvE583X69fftt6eESX","name":"Read","input":{"file_path":"/Users/realsun/data/git/mole-mcp-server/src/stealthmole_mcp/tools/_request.py","limit":50}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":311,"cache_read_input_tokens":23300,"output_tokens":103,"service_tier":"standard"}},"requestId":"req_011CRR1R9wozqrkAnsMqqZgg","type":"assistant","uuid":"bc35e816-3f34-4726-a6be-6cab64da635d","timestamp":"2025-07-24T01:52:47.516Z"}
{"parentUuid":"bc35e816-3f34-4726-a6be-6cab64da635d","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"7eaedb61-e6af-4956-ab4d-ee3971985adb","version":"1.0.58","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MAeLAvE583X69fftt6eESX","type":"tool_result","content":"     1→import asyncio\n     2→import os\n     3→import time\n     4→import uuid\n     5→from typing import Any, Dict, Optional\n     6→\n     7→import httpx\n     8→import jwt\n     9→from dotenv import load_dotenv\n    10→\n    11→load_dotenv()\n    12→\n    13→# Global configuration\n    14→BASE_URL = \"https://api.stealthmole.com\"\n    15→TIMEOUT = 600.0\n    16→DOWNLOAD_TIMEOUT = 600.0\n    17→MAX_RETRIES = 3\n    18→RETRY_DELAY = 1.0\n    19→\n    20→\n    21→async def _make_request(endpoint: str, params: Optional[Dict] = None) -> Dict[str, Any]:\n    22→    \"\"\"Make authenticated request to StealthMole API with retry logic.\"\"\"\n    23→    url = f\"{BASE_URL}{endpoint}\"\n    24→\n    25→    async with httpx.AsyncClient(timeout=TIMEOUT) as client:\n    26→        for attempt in range(MAX_RETRIES):\n    27→            try:\n    28→                headers = _get_headers()\n    29→                response = await client.get(url, headers=headers, params=params or {})\n    30→                response.raise_for_status()\n    31→                data = response.json()\n    32→                if data is None:\n    33→                    # response가 null인 경우 재요청\n    34→                    await asyncio.sleep(RETRY_DELAY)\n    35→                    response = await client.get(url, headers=headers, params=params or {})\n    36→                    response.raise_for_status()\n    37→                    data = response.json()\n    38→                return data\n    39→            except (httpx.TimeoutException, httpx.ConnectError, httpx.ReadTimeout) as e:\n    40→                if attempt == MAX_RETRIES - 1:\n    41→                    raise httpx.TimeoutException(\n    42→                        f\"Request timed out after {MAX_RETRIES} attempts: {str(e)}\"\n    43→                    )\n    44→                await asyncio.sleep(RETRY_DELAY * (2**attempt))\n    45→            except httpx.HTTPStatusError as e:\n    46→                if e.response.status_code >= 500 and attempt < MAX_RETRIES - 1:\n    47→                    await asyncio.sleep(RETRY_DELAY * (2**attempt))\n    48→                    continue\n    49→                raise\n    50→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"b161bde6-300d-4b64-a36a-6d7fcd699617","timestamp":"2025-07-24T01:52:47.534Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/realsun/data/git/mole-mcp-server/src/stealthmole_mcp/tools/_request.py","content":"import asyncio\nimport os\nimport time\nimport uuid\nfrom typing import Any, Dict, Optional\n\nimport httpx\nimport jwt\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\n# Global configuration\nBASE_URL = \"https://api.stealthmole.com\"\nTIMEOUT = 600.0\nDOWNLOAD_TIMEOUT = 600.0\nMAX_RETRIES = 3\nRETRY_DELAY = 1.0\n\n\nasync def _make_request(endpoint: str, params: Optional[Dict] = None) -> Dict[str, Any]:\n    \"\"\"Make authenticated request to StealthMole API with retry logic.\"\"\"\n    url = f\"{BASE_URL}{endpoint}\"\n\n    async with httpx.AsyncClient(timeout=TIMEOUT) as client:\n        for attempt in range(MAX_RETRIES):\n            try:\n                headers = _get_headers()\n                response = await client.get(url, headers=headers, params=params or {})\n                response.raise_for_status()\n                data = response.json()\n                if data is None:\n                    # response가 null인 경우 재요청\n                    await asyncio.sleep(RETRY_DELAY)\n                    response = await client.get(url, headers=headers, params=params or {})\n                    response.raise_for_status()\n                    data = response.json()\n                return data\n            except (httpx.TimeoutException, httpx.ConnectError, httpx.ReadTimeout) as e:\n                if attempt == MAX_RETRIES - 1:\n                    raise httpx.TimeoutException(\n                        f\"Request timed out after {MAX_RETRIES} attempts: {str(e)}\"\n                    )\n                await asyncio.sleep(RETRY_DELAY * (2**attempt))\n            except httpx.HTTPStatusError as e:\n                if e.response.status_code >= 500 and attempt < MAX_RETRIES - 1:\n                    await asyncio.sleep(RETRY_DELAY * (2**attempt))\n                    continue\n                raise\n","numLines":50,"startLine":1,"totalLines":102}}}
{"parentUuid":"b161bde6-300d-4b64-a36a-6d7fcd699617","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"7eaedb61-e6af-4956-ab4d-ee3971985adb","version":"1.0.58","gitBranch":"main","message":{"id":"msg_01WEARNUgHTLTDv59FvHVAAe","type":"message","role":"assistant","model":"claude-opus-4-20250514","content":[{"type":"tool_use","id":"toolu_01TPecKCEH28tUz2AJik8ZBf","name":"Read","input":{"file_path":"/Users/realsun/data/git/mole-mcp-server/src/stealthmole_mcp/tools/_request.py","offset":50,"limit":50}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":830,"cache_read_input_tokens":23611,"output_tokens":120,"service_tier":"standard"}},"requestId":"req_011CRR1Rc4SV9YX4oEmqrn7c","type":"assistant","uuid":"f01fe5cd-40d8-41f3-9006-b6216f2497ac","timestamp":"2025-07-24T01:52:51.925Z"}
{"parentUuid":"f01fe5cd-40d8-41f3-9006-b6216f2497ac","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"7eaedb61-e6af-4956-ab4d-ee3971985adb","version":"1.0.58","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TPecKCEH28tUz2AJik8ZBf","type":"tool_result","content":"    50→\n    51→    # This should never be reached due to the raise statements above\n    52→    raise RuntimeError(\"Request failed after all retry attempts\")\n    53→\n    54→\n    55→async def _download_file(service: str, file_hash: str) -> bytes:\n    56→    \"\"\"Download file by hash from dt or tt service with extended timeout.\"\"\"\n    57→    url = f\"{BASE_URL}/v2/api/file/{service}/f/{file_hash}\"\n    58→\n    59→    async with httpx.AsyncClient(timeout=DOWNLOAD_TIMEOUT) as client:\n    60→        for attempt in range(MAX_RETRIES):\n    61→            try:\n    62→                headers = _get_headers()\n    63→                response = await client.get(url, headers=headers)\n    64→                response.raise_for_status()\n    65→                return response.content\n    66→            except (httpx.TimeoutException, httpx.ConnectError, httpx.ReadTimeout) as e:\n    67→                if attempt == MAX_RETRIES - 1:\n    68→                    raise httpx.TimeoutException(\n    69→                        f\"File download timed out after {MAX_RETRIES} attempts: {str(e)}\"\n    70→                    )\n    71→                await asyncio.sleep(RETRY_DELAY * (2**attempt))\n    72→            except httpx.HTTPStatusError as e:\n    73→                if e.response.status_code >= 500 and attempt < MAX_RETRIES - 1:\n    74→                    await asyncio.sleep(RETRY_DELAY * (2**attempt))\n    75→                    continue\n    76→                raise\n    77→\n    78→    # This should never be reached due to the raise statements above\n    79→    raise RuntimeError(\"File download failed after all retry attempts\")\n    80→\n    81→\n    82→def _generate_jwt_token() -> str:\n    83→    \"\"\"Generate JWT token for authentication.\"\"\"\n    84→    access_key = os.getenv(\"STEALTHMOLE_ACCESS_KEY\", \"\")\n    85→    secret_key = os.getenv(\"STEALTHMOLE_SECRET_KEY\", \"\")\n    86→    \n    87→    if not access_key or not secret_key:\n    88→        raise ValueError(\"STEALTHMOLE_ACCESS_KEY and STEALTHMOLE_SECRET_KEY environment variables are required\")\n    89→    \n    90→    payload = {\n    91→        \"access_key\": access_key,\n    92→        \"nonce\": str(uuid.uuid4()),\n    93→        \"iat\": int(time.time()),\n    94→    }\n    95→    return jwt.encode(payload, secret_key, algorithm=\"HS256\")\n    96→\n    97→\n    98→def _get_headers() -> Dict[str, str]:\n    99→    \"\"\"Get headers with JWT authentication.\"\"\"\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"bd40133f-4a31-4a17-9b15-688e1e506c62","timestamp":"2025-07-24T01:52:51.951Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/realsun/data/git/mole-mcp-server/src/stealthmole_mcp/tools/_request.py","content":"\n    # This should never be reached due to the raise statements above\n    raise RuntimeError(\"Request failed after all retry attempts\")\n\n\nasync def _download_file(service: str, file_hash: str) -> bytes:\n    \"\"\"Download file by hash from dt or tt service with extended timeout.\"\"\"\n    url = f\"{BASE_URL}/v2/api/file/{service}/f/{file_hash}\"\n\n    async with httpx.AsyncClient(timeout=DOWNLOAD_TIMEOUT) as client:\n        for attempt in range(MAX_RETRIES):\n            try:\n                headers = _get_headers()\n                response = await client.get(url, headers=headers)\n                response.raise_for_status()\n                return response.content\n            except (httpx.TimeoutException, httpx.ConnectError, httpx.ReadTimeout) as e:\n                if attempt == MAX_RETRIES - 1:\n                    raise httpx.TimeoutException(\n                        f\"File download timed out after {MAX_RETRIES} attempts: {str(e)}\"\n                    )\n                await asyncio.sleep(RETRY_DELAY * (2**attempt))\n            except httpx.HTTPStatusError as e:\n                if e.response.status_code >= 500 and attempt < MAX_RETRIES - 1:\n                    await asyncio.sleep(RETRY_DELAY * (2**attempt))\n                    continue\n                raise\n\n    # This should never be reached due to the raise statements above\n    raise RuntimeError(\"File download failed after all retry attempts\")\n\n\ndef _generate_jwt_token() -> str:\n    \"\"\"Generate JWT token for authentication.\"\"\"\n    access_key = os.getenv(\"STEALTHMOLE_ACCESS_KEY\", \"\")\n    secret_key = os.getenv(\"STEALTHMOLE_SECRET_KEY\", \"\")\n    \n    if not access_key or not secret_key:\n        raise ValueError(\"STEALTHMOLE_ACCESS_KEY and STEALTHMOLE_SECRET_KEY environment variables are required\")\n    \n    payload = {\n        \"access_key\": access_key,\n        \"nonce\": str(uuid.uuid4()),\n        \"iat\": int(time.time()),\n    }\n    return jwt.encode(payload, secret_key, algorithm=\"HS256\")\n\n\ndef _get_headers() -> Dict[str, str]:\n    \"\"\"Get headers with JWT authentication.\"\"\"","numLines":50,"startLine":50,"totalLines":102}}}
{"parentUuid":"bd40133f-4a31-4a17-9b15-688e1e506c62","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"7eaedb61-e6af-4956-ab4d-ee3971985adb","version":"1.0.58","gitBranch":"main","message":{"id":"msg_017KiVzB3p3UVNescBvAm3qt","type":"message","role":"assistant","model":"claude-opus-4-20250514","content":[{"type":"tool_use","id":"toolu_01JwRcvUbAgdJ4Mkj2GkaBqz","name":"TodoWrite","input":{"todos":[{"id":"1","content":"Review server.py imports and apply_default_behavior function","status":"completed","priority":"high"},{"id":"2","content":"Check for security vulnerabilities","status":"completed","priority":"high"},{"id":"3","content":"Identify performance issues","status":"in_progress","priority":"medium"}]}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":917,"cache_read_input_tokens":24441,"output_tokens":147,"service_tier":"standard"}},"requestId":"req_011CRR1Rw1UF9r4EHM49H83s","type":"assistant","uuid":"f18974b8-ceb7-49f3-b00a-af3ed1bf8853","timestamp":"2025-07-24T01:52:57.246Z"}
{"parentUuid":"f18974b8-ceb7-49f3-b00a-af3ed1bf8853","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"7eaedb61-e6af-4956-ab4d-ee3971985adb","version":"1.0.58","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JwRcvUbAgdJ4Mkj2GkaBqz","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"afee36af-9724-432f-90ea-b0249e1f06ca","timestamp":"2025-07-24T01:52:57.270Z","toolUseResult":{"oldTodos":[{"content":"Review server.py imports and apply_default_behavior function","status":"completed","priority":"high","id":"1"},{"content":"Check for security vulnerabilities","status":"in_progress","priority":"high","id":"2"},{"content":"Identify performance issues","status":"pending","priority":"medium","id":"3"}],"newTodos":[{"content":"Review server.py imports and apply_default_behavior function","status":"completed","priority":"high","id":"1"},{"content":"Check for security vulnerabilities","status":"completed","priority":"high","id":"2"},{"content":"Identify performance issues","status":"in_progress","priority":"medium","id":"3"}]}}
{"parentUuid":"afee36af-9724-432f-90ea-b0249e1f06ca","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"7eaedb61-e6af-4956-ab4d-ee3971985adb","version":"1.0.58","gitBranch":"main","message":{"id":"msg_01BgfrneM6XRFDFXPijdub85","type":"message","role":"assistant","model":"claude-opus-4-20250514","content":[{"type":"tool_use","id":"toolu_019w9LxUnXbaAPbkfZqNXyzy","name":"TodoWrite","input":{"todos":[{"id":"1","content":"Review server.py imports and apply_default_behavior function","status":"completed","priority":"high"},{"id":"2","content":"Check for security vulnerabilities","status":"completed","priority":"high"},{"id":"3","content":"Identify performance issues","status":"completed","priority":"medium"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":311,"cache_read_input_tokens":25358,"output_tokens":145,"service_tier":"standard"}},"requestId":"req_011CRR1SKgUyk3XTbkPpuQak","type":"assistant","uuid":"74658d9e-3b00-4e64-b8ff-efb9b5aab13e","timestamp":"2025-07-24T01:53:02.517Z"}
{"parentUuid":"74658d9e-3b00-4e64-b8ff-efb9b5aab13e","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"7eaedb61-e6af-4956-ab4d-ee3971985adb","version":"1.0.58","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019w9LxUnXbaAPbkfZqNXyzy","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"1c737672-db7b-4c5f-811f-ec5b290ffe7f","timestamp":"2025-07-24T01:53:02.550Z","toolUseResult":{"oldTodos":[{"content":"Review server.py imports and apply_default_behavior function","status":"completed","priority":"high","id":"1"},{"content":"Check for security vulnerabilities","status":"completed","priority":"high","id":"2"},{"content":"Identify performance issues","status":"in_progress","priority":"medium","id":"3"}],"newTodos":[{"content":"Review server.py imports and apply_default_behavior function","status":"completed","priority":"high","id":"1"},{"content":"Check for security vulnerabilities","status":"completed","priority":"high","id":"2"},{"content":"Identify performance issues","status":"completed","priority":"medium","id":"3"}]}}
{"parentUuid":"1c737672-db7b-4c5f-811f-ec5b290ffe7f","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"7eaedb61-e6af-4956-ab4d-ee3971985adb","version":"1.0.58","gitBranch":"main","message":{"id":"msg_013CkLoVcX8SLpKy7JT1yrnb","type":"message","role":"assistant","model":"claude-opus-4-20250514","content":[{"type":"text","text":"## Code Review Summary\n\n### 🔍 Issues Found:\n\n**1. Import Issues (Pylance warnings)**\n- Line 6: Unused imports `datetime`, `timedelta` - 날짜 관련 코드를 제거했지만 import가 남아있음\n- Line 9: Unused import `prompt` from click - 실제로 사용되지 않음\n\n**2. Security Considerations**\n- **JWT Token Security**: 환경 변수에서 API 키를 읽어 JWT 토큰을 생성하는 방식은 적절함\n- **Timeout Protection**: 600초 타임아웃 설정으로 무한 대기 방지\n- **Retry Logic**: 지수 백오프로 재시도하여 서버 부하 최소화\n- **Input Validation**: 사용자 입력을 직접 SQL이나 시스템 명령에 사용하지 않음\n\n**3. Performance Issues**\n- **Dictionary Comprehension**: `removal_empty` 함수에서 `list(result.keys())`를 사용하는데, 이는 불필요함\n- **Repeated Dictionary Access**: `removal_highlight`와 `removal_empty_metadata`에서 동일한 키를 반복 접근\n- **날짜 계산 제거**: 날짜 제한을 제거했으므로 더 많은 데이터를 검색할 수 있어 응답 시간이 늘어날 수 있음\n\n**4. Logic Issues**\n- Line 744: `bool(contents.get(\"metadata\")) == False` 대신 `not contents.get(\"metadata\")` 사용 권장\n- 날짜 제한 제거로 인해 API 할당량을 더 빨리 소진할 가능성\n\n### ✅ 개선 제안:\n1. 사용하지 않는 import 제거\n2. `removal_*` 함수들의 성능 최적화\n3. API 호출 시 결과 크기 모니터링 추가 고려"}],"stop_reason":"end_turn","stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":307,"cache_read_input_tokens":25669,"output_tokens":556,"service_tier":"standard"}},"requestId":"req_011CRR1SiHX9Ncnn6NYgs1fQ","type":"assistant","uuid":"b99d436f-e2e8-4a24-a21b-89d741c51727","timestamp":"2025-07-24T01:53:19.343Z"}
{"parentUuid":"b99d436f-e2e8-4a24-a21b-89d741c51727","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"7eaedb61-e6af-4956-ab4d-ee3971985adb","version":"1.0.58","gitBranch":"main","type":"user","message":{"role":"user","content":"@src/stealthmole_mcp/tools/_request.py 에서 httpx.asyncClient를 이용하는데 동기로 작성하는것보다 장점이 뭐야?"},"uuid":"c00b7098-34bb-4f75-8ae3-d9f4d695e1db","timestamp":"2025-07-24T03:00:12.100Z"}
{"parentUuid":"c00b7098-34bb-4f75-8ae3-d9f4d695e1db","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"7eaedb61-e6af-4956-ab4d-ee3971985adb","version":"1.0.58","gitBranch":"main","message":{"id":"msg_01KdgkjVWbTmkD9wXpCTYAHV","type":"message","role":"assistant","model":"claude-opus-4-20250514","content":[{"type":"text","text":"`httpx.AsyncClient`를 사용하는 비동기 방식은 동기 방식에 비해 다음과 같은 장점이 있습니다:\n\n## 1. **동시성 (Concurrency)**\n- 여러 API 요청을 동시에 처리 가능\n- I/O 대기 시간 동안 다른 작업 수행\n- MCP 서버가 여러 클라이언트 요청을 동시에 처리\n\n## 2. **효율적인 리소스 사용**\n- 블로킹 없이 CPU 활용도 향상\n- 스레드 생성 오버헤드 없음\n- 메모리 효율성 증가\n\n## 3. **확장성 (Scalability)**\n```python\n# 비동기: 동시에 여러 요청 처리\nasync def handle_multiple_requests():\n    tasks = [\n        search_darkweb(...),\n        search_telegram(...),\n        search_credentials(...)\n    ]\n    results = await asyncio.gather(*tasks)\n```\n\n## 4. **MCP 프로토콜과의 호환성**\n- MCP 서버 자체가 비동기로 구현됨\n- `stdio_server()`가 비동기 스트림 사용\n- 전체 아키텍처가 비동기 기반\n\n## 5. **타임아웃 처리**\n- 600초 같은 긴 타임아웃도 효율적으로 처리\n- 다른 요청을 블로킹하지 않음\n\n## 6. **재시도 로직**\n```python\nawait asyncio.sleep(RETRY_DELAY * (2**attempt))\n```\n- 지수 백오프 중에도 다른 작업 가능\n- 시스템 전체가 대기하지 않음\n\n특히 StealthMole API처럼 응답 시간이 긴 외부 API와 통신할 때는 비동기 방식이 필수적입니다."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":39057,"cache_read_input_tokens":0,"output_tokens":567,"service_tier":"standard"}},"requestId":"req_011CRR6ZkZDqUPZnawuVeaza","type":"assistant","uuid":"4667476d-1015-4c11-91da-5e5550732255","timestamp":"2025-07-24T03:00:28.512Z"}
