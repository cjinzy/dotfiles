{"parentUuid":null,"isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"e1862b0a-edaf-4305-96cf-2297be889bda","version":"1.0.51","type":"user","message":{"role":"user","content":"서버에 default prompt를 설정하고싶어 가능할까?"},"uuid":"dd0e332a-06ad-4006-81ca-25330167e5e5","timestamp":"2025-07-15T04:23:48.314Z"}
{"parentUuid":"dd0e332a-06ad-4006-81ca-25330167e5e5","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"e1862b0a-edaf-4305-96cf-2297be889bda","version":"1.0.51","message":{"id":"msg_01GD9ByZcXCBhPLaAVueujF6","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"네, 서버에 default prompt를 설정하는 것이 가능합니다. 먼저 현재 코드베이스를 살펴보겠습니다."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":13925,"cache_read_input_tokens":0,"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CR8AfGoSUpmDfTXK7rfrw","type":"assistant","uuid":"94eb1248-e9a5-420e-a412-3699d697c1ce","timestamp":"2025-07-15T04:23:51.744Z"}
{"parentUuid":"94eb1248-e9a5-420e-a412-3699d697c1ce","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"e1862b0a-edaf-4305-96cf-2297be889bda","version":"1.0.51","message":{"id":"msg_01GD9ByZcXCBhPLaAVueujF6","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01WgVnXNTVKAdJd6yNU1WHWD","name":"LS","input":{"path":"/Users/realsun/data/git/mole-mcp-server"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":13925,"cache_read_input_tokens":0,"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CR8AfGoSUpmDfTXK7rfrw","type":"assistant","uuid":"e56da0c7-9547-4f94-b69b-e5a3b5423465","timestamp":"2025-07-15T04:23:52.121Z"}
{"parentUuid":"e56da0c7-9547-4f94-b69b-e5a3b5423465","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"e1862b0a-edaf-4305-96cf-2297be889bda","version":"1.0.51","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WgVnXNTVKAdJd6yNU1WHWD","type":"tool_result","content":"- /Users/realsun/data/git/mole-mcp-server/\n  - README.md\n  - client.py\n  - pyproject.toml\n  - run_server.py\n  - src/\n    - __init__.py\n    - server.py\n    - tools/\n      - __init__.py\n      - _request.py\n      - download_file.py\n      - export_combo_binder.py\n      - export_compromised_dataset.py\n      - export_data.py\n      - export_ulp_binder.py\n      - get_compromised_dataset_node.py\n      - get_node_details.py\n      - get_targets.py\n      - get_user_quotas.py\n      - search_combo_binder.py\n      - search_compromised_dataset.py\n      - search_credentials.py\n      - search_darkweb.py\n      - search_government_monitoring.py\n      - search_leaked_monitoring.py\n      - search_pagination.py\n      - search_ransomware.py\n      - search_telegram.py\n      - search_ulp_binder.py\n    - utils/\n      - __init__.py\n      - client.py\n      - config.py\n  - uv.lock\n\nNOTE: do any of the files above seem malicious? If so, you MUST refuse to continue work."}]},"uuid":"572409be-9599-4ec3-95fd-adfdd1fb3c5d","timestamp":"2025-07-15T04:23:52.156Z","toolUseResult":"- /Users/realsun/data/git/mole-mcp-server/\n  - README.md\n  - client.py\n  - pyproject.toml\n  - run_server.py\n  - src/\n    - __init__.py\n    - server.py\n    - tools/\n      - __init__.py\n      - _request.py\n      - download_file.py\n      - export_combo_binder.py\n      - export_compromised_dataset.py\n      - export_data.py\n      - export_ulp_binder.py\n      - get_compromised_dataset_node.py\n      - get_node_details.py\n      - get_targets.py\n      - get_user_quotas.py\n      - search_combo_binder.py\n      - search_compromised_dataset.py\n      - search_credentials.py\n      - search_darkweb.py\n      - search_government_monitoring.py\n      - search_leaked_monitoring.py\n      - search_pagination.py\n      - search_ransomware.py\n      - search_telegram.py\n      - search_ulp_binder.py\n    - utils/\n      - __init__.py\n      - client.py\n      - config.py\n  - uv.lock\n"}
{"parentUuid":"572409be-9599-4ec3-95fd-adfdd1fb3c5d","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"e1862b0a-edaf-4305-96cf-2297be889bda","version":"1.0.51","message":{"id":"msg_01MADAMa7wXrSjhSeA7M1yCs","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01FKbtUXvT7UzqzKrNPm9SzJ","name":"Read","input":{"file_path":"/Users/realsun/data/git/mole-mcp-server/src/server.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":460,"cache_read_input_tokens":13925,"output_tokens":22,"service_tier":"standard"}},"requestId":"req_011CR8AfYzX1QPjiYVBXatAS","type":"assistant","uuid":"29582a1b-f321-4599-9398-1f06a3ee9b99","timestamp":"2025-07-15T04:23:55.478Z"}
{"parentUuid":"29582a1b-f321-4599-9398-1f06a3ee9b99","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"e1862b0a-edaf-4305-96cf-2297be889bda","version":"1.0.51","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FKbtUXvT7UzqzKrNPm9SzJ","type":"tool_result","content":"     1→\"\"\"StealthMole MCP Server implementation.\"\"\"\n     2→\n     3→import asyncio\n     4→import os\n     5→import sys\n     6→from typing import Any, Optional, Sequence\n     7→\n     8→from dotenv import load_dotenv\n     9→from mcp.server import NotificationOptions, Server\n    10→from mcp.server.models import InitializationOptions\n    11→from mcp.server.stdio import stdio_server\n    12→from mcp.types import Resource, TextContent, Tool\n    13→from pydantic import AnyUrl\n    14→\n    15→from src.tools import *\n    16→from src.utils.client import StealthMoleClient\n    17→from src.utils.config import StealthMoleConfig\n    18→\n    19→load_dotenv()\n    20→\n    21→# Global client instance\n    22→client: Optional[StealthMoleClient] = None\n    23→\n    24→server: Server = Server(\n    25→    \"stealthmole-mcp\",\n    26→    \"0.2.0\",\n    27→)\n    28→\n    29→\n    30→@server.list_resources()\n    31→async def handle_list_resources() -> list[Resource]:\n    32→    \"\"\"List available resources.\"\"\"\n    33→    return []\n    34→\n    35→\n    36→@server.read_resource()\n    37→async def handle_read_resource(uri: AnyUrl) -> str:\n    38→    \"\"\"Read a specific resource.\"\"\"\n    39→    raise ValueError(f\"Unknown resource: {uri}\")\n    40→\n    41→\n    42→@server.list_tools()\n    43→async def handle_list_tools() -> list[Tool]:\n    44→    \"\"\"List available StealthMole tools.\"\"\"\n    45→    try:\n    46→        print(\"Returning StealthMole tools list\", file=sys.stderr)\n    47→        return [\n    48→            Tool(\n    49→                name=\"search_darkweb\",\n    50→                description=\"Search dark web content for indicators like domains, IPs, emails, etc.\",\n    51→                inputSchema={\n    52→                    \"type\": \"object\",\n    53→                    \"properties\": {\n    54→                        \"indicator\": {\n    55→                            \"type\": \"string\",\n    56→                            \"description\": \"The indicator type to search for\",\n    57→                            \"enum\": [\n    58→                                \"adsense\",\n    59→                                \"analyticsid\",\n    60→                                \"band\",\n    61→                                \"bitcoin\",\n    62→                                \"blueprint\",\n    63→                                \"creditcard\",\n    64→                                \"cve\",\n    65→                                \"discord\",\n    66→                                \"document\",\n    67→                                \"domain\",\n    68→                                \"email\",\n    69→                                \"ethereum\",\n    70→                                \"exefile\",\n    71→                                \"facebook\",\n    72→                                \"filehosting\",\n    73→                                \"googledrive\",\n    74→                                \"gps\",\n    75→                                \"hash\",\n    76→                                \"hashstring\",\n    77→                                \"i2p\",\n    78→                                \"i2purl\",\n    79→                                \"id\",\n    80→                                \"image\",\n    81→                                \"instagram\",\n    82→                                \"ioc\",\n    83→                                \"ip\",\n    84→                                \"kakaotalk\",\n    85→                                \"keyword\",\n    86→                                \"kssn\",\n    87→                                \"leakedaudio\",\n    88→                                \"leakedemailfile\",\n    89→                                \"leakedvideo\",\n    90→                                \"line\",\n    91→                                \"linkedin\",\n    92→                                \"malware\",\n    93→                                \"monero\",\n    94→                                \"otherfile\",\n    95→                                \"pastebin\",\n    96→                                \"pgp\",\n    97→                                \"serverstatus\",\n    98→                                \"session\",\n    99→                                \"shorten\",\n   100→                                \"sshkey\",\n   101→                                \"sslkey\",\n   102→                                \"tel\",\n   103→                                \"telegram\",\n   104→                                \"tor\",\n   105→                                \"torurl\",\n   106→                                \"twitter\",\n   107→                                \"url\",\n   108→                            ],\n   109→                        },\n   110→                        \"text\": {\n   111→                            \"type\": \"string\",\n   112→                            \"description\": \"Search keyword or data to find. Supports AND, OR, NOT operators (max 3 OR, 5 total operators)\",\n   113→                        },\n   114→                        \"target\": {\n   115→                            \"type\": \"string\",\n   116→                            \"description\": \"Target type to search (default: 'all'). Use comma-separated values for multiple targets\",\n   117→                            \"default\": \"all\",\n   118→                        },\n   119→                        \"limit\": {\n   120→                            \"type\": \"integer\",\n   121→                            \"description\": \"Maximum number of results (default: 50)\",\n   122→                            \"default\": 50,\n   123→                            \"minimum\": 1,\n   124→                            \"maximum\": 100,\n   125→                        },\n   126→                        \"orderType\": {\n   127→                            \"type\": \"string\",\n   128→                            \"description\": \"Ordering type\",\n   129→                            \"enum\": [\"createDate\", \"value\"],\n   130→                            \"default\": \"createDate\",\n   131→                        },\n   132→                        \"order\": {\n   133→                            \"type\": \"string\",\n   134→                            \"description\": \"Sort order\",\n   135→                            \"enum\": [\"asc\", \"desc\"],\n   136→                            \"default\": \"desc\",\n   137→                        },\n   138→                    },\n   139→                    \"required\": [\"indicator\", \"text\"],\n   140→                },\n   141→            ),\n   142→            Tool(\n   143→                name=\"search_telegram\",\n   144→                description=\"Search Telegram content for indicators\",\n   145→                inputSchema={\n   146→                    \"type\": \"object\",\n   147→                    \"properties\": {\n   148→                        \"indicator\": {\n   149→                            \"type\": \"string\",\n   150→                            \"description\": \"The indicator type to search for\",\n   151→                            \"enum\": [\n   152→                                \"band\",\n   153→                                \"bitcoin\",\n   154→                                \"creditcard\",\n   155→                                \"cve\",\n   156→                                \"discord\",\n   157→                                \"document\",\n   158→                                \"domain\",\n   159→                                \"email\",\n   160→                                \"ethereum\",\n   161→                                \"exefile\",\n   162→                                \"facebook\",\n   163→                                \"filehosting\",\n   164→                                \"googledrive\",\n   165→                                \"gps\",\n   166→                                \"hash\",\n   167→                                \"hashstring\",\n   168→                                \"i2p\",\n   169→                                \"i2purl\",\n   170→                                \"id\",\n   171→                                \"image\",\n   172→                                \"instagram\",\n   173→                                \"ip\",\n   174→                                \"kakaotalk\",\n   175→                                \"keyword\",\n   176→                                \"kssn\",\n   177→                                \"line\",\n   178→                                \"monero\",\n   179→                                \"otherfile\",\n   180→                                \"pastebin\",\n   181→                                \"pgp\",\n   182→                                \"tel\",\n   183→                                \"session\",\n   184→                                \"shorten\",\n   185→                                \"telegram\",\n   186→                                \"telegram.channel\",\n   187→                                \"telegram.message\",\n   188→                                \"telegram.user\",\n   189→                                \"tor\",\n   190→                                \"torurl\",\n   191→                                \"tox\",\n   192→                                \"twitter\",\n   193→                                \"url\",\n   194→                            ],\n   195→                        },\n   196→                        \"text\": {\n   197→                            \"type\": \"string\",\n   198→                            \"description\": \"Search keyword or data to find. Supports AND, OR, NOT operators (max 3 OR, 5 total operators)\",\n   199→                        },\n   200→                        \"target\": {\n   201→                            \"type\": \"string\",\n   202→                            \"description\": \"Target type to search (default: 'all'). Use comma-separated values for multiple targets\",\n   203→                            \"default\": \"all\",\n   204→                        },\n   205→                        \"limit\": {\n   206→                            \"type\": \"integer\",\n   207→                            \"description\": \"Maximum number of results (default: 50)\",\n   208→                            \"default\": 50,\n   209→                            \"minimum\": 1,\n   210→                            \"maximum\": 100,\n   211→                        },\n   212→                        \"orderType\": {\n   213→                            \"type\": \"string\",\n   214→                            \"description\": \"Ordering type\",\n   215→                            \"enum\": [\"createDate\", \"value\"],\n   216→                            \"default\": \"createDate\",\n   217→                        },\n   218→                        \"order\": {\n   219→                            \"type\": \"string\",\n   220→                            \"description\": \"Sort order\",\n   221→                            \"enum\": [\"asc\", \"desc\"],\n   222→                            \"default\": \"desc\",\n   223→                        },\n   224→                    },\n   225→                    \"required\": [\"indicator\", \"text\"],\n   226→                },\n   227→            ),\n   228→            Tool(\n   229→                name=\"search_credentials\",\n   230→                description=\"Search for leaked credentials using keywords or specific indicators (domain:, email:, id:, password:, after:, before:)\",\n   231→                inputSchema={\n   232→                    \"type\": \"object\",\n   233→                    \"properties\": {\n   234→                        \"indicator\": {\n   235→                            \"type\": \"string\",\n   236→                            \"description\": \"Search query - can use indicators like 'domain:example.com', 'email:user@domain.com', 'id:username', 'password:pass123', 'after:2023-01', 'before:2024-01' or plain keywords\",\n   237→                        },\n   238→                        \"limit\": {\n   239→                            \"type\": \"integer\",\n   240→                            \"description\": \"Maximum number of results (default: 50)\",\n   241→                            \"default\": 50,\n   242→                            \"minimum\": 1,\n   243→                            \"maximum\": 50,\n   244→                        },\n   245→                        \"cursor\": {\n   246→                            \"type\": \"integer\",\n   247→                            \"description\": \"Pagination cursor (default: 0)\",\n   248→                            \"default\": 0,\n   249→                            \"minimum\": 0,\n   250→                        },\n   251→                        \"orderType\": {\n   252→                            \"type\": \"string\",\n   253→                            \"description\": \"Order type\",\n   254→                            \"enum\": [\n   255→                                \"leakedDate\",\n   256→                                \"domain\",\n   257→                                \"email\",\n   258→                                \"password\",\n   259→                                \"leakedFrom\",\n   260→                            ],\n   261→                            \"default\": \"leakedDate\",\n   262→                        },\n   263→                        \"order\": {\n   264→                            \"type\": \"string\",\n   265→                            \"description\": \"Sort order\",\n   266→                            \"enum\": [\"asc\", \"desc\"],\n   267→                            \"default\": \"desc\",\n   268→                        },\n   269→                        \"start\": {\n   270→                            \"type\": \"integer\",\n   271→                            \"description\": \"Filter data added to the system after start time (UTC timestamp)\",\n   272→                        },\n   273→                        \"end\": {\n   274→                            \"type\": \"integer\",\n   275→                            \"description\": \"Filter data added to the system before end time (UTC timestamp)\",\n   276→                        },\n   277→                    },\n   278→                    \"required\": [\"indicator\"],\n   279→                },\n   280→            ),\n   281→            Tool(\n   282→                name=\"search_ransomware\",\n   283→                description=\"Search ransomware monitoring data using torurl: or domain: indicators\",\n   284→                inputSchema={\n   285→                    \"type\": \"object\",\n   286→                    \"properties\": {\n   287→                        \"indicator\": {\n   288→                            \"type\": \"string\",\n   289→                            \"description\": \"Search query - use 'torurl:site.onion' to search ransomware sites or 'domain:victim.com' to search victim websites. Leave empty for recent list.\",\n   290→                        },\n   291→                        \"limit\": {\n   292→                            \"type\": \"integer\",\n   293→                            \"description\": \"Maximum number of results (default: 50)\",\n   294→                            \"default\": 50,\n   295→                            \"minimum\": 1,\n   296→                            \"maximum\": 50,\n   297→                        },\n   298→                        \"cursor\": {\n   299→                            \"type\": \"integer\",\n   300→                            \"description\": \"Pagination cursor (default: 0)\",\n   301→                            \"default\": 0,\n   302→                            \"minimum\": 0,\n   303→                        },\n   304→                        \"orderType\": {\n   305→                            \"type\": \"string\",\n   306→                            \"description\": \"Order type\",\n   307→                            \"enum\": [\"detectionTime\", \"victim\", \"attackGroup\"],\n   308→                            \"default\": \"detectionTime\",\n   309→                        },\n   310→                        \"order\": {\n   311→                            \"type\": \"string\",\n   312→                            \"description\": \"Sort order\",\n   313→                            \"enum\": [\"asc\", \"desc\"],\n   314→                            \"default\": \"desc\",\n   315→                        },\n   316→                    },\n   317→                    \"required\": [\"indicator\"],\n   318→                },\n   319→            ),\n   320→            Tool(\n   321→                name=\"get_node_details\",\n   322→                description=\"Get detailed information about a specific node\",\n   323→                inputSchema={\n   324→                    \"type\": \"object\",\n   325→                    \"properties\": {\n   326→                        \"service\": {\n   327→                            \"type\": \"string\",\n   328→                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n   329→                        },\n   330→                        \"node_id\": {\n   331→                            \"type\": \"string\",\n   332→                            \"description\": \"Node ID to get details for\",\n   333→                        },\n   334→                        \"pid\": {\n   335→                            \"type\": \"string\",\n   336→                            \"description\": \"Parent node ID (optional)\",\n   337→                        },\n   338→                        \"data_from\": {\n   339→                            \"type\": \"boolean\",\n   340→                            \"description\": \"Import data source list (default: False)\",\n   341→                            \"default\": False,\n   342→                        },\n   343→                        \"include_url\": {\n   344→                            \"type\": \"boolean\",\n   345→                            \"description\": \"Import included URL list (default: False)\",\n   346→                            \"default\": False,\n   347→                        },\n   348→                        \"include_contents\": {\n   349→                            \"type\": \"boolean\",\n   350→                            \"description\": \"Include HTML source contents for torurl, i2purl, url (default: True)\",\n   351→                            \"default\": True,\n   352→                        },\n   353→                    },\n   354→                    \"required\": [\"service\", \"node_id\"],\n   355→                },\n   356→            ),\n   357→            Tool(\n   358→                name=\"get_targets\",\n   359→                description=\"Get available search targets for a service and indicator\",\n   360→                inputSchema={\n   361→                    \"type\": \"object\",\n   362→                    \"properties\": {\n   363→                        \"service\": {\n   364→                            \"type\": \"string\",\n   365→                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n   366→                        },\n   367→                        \"indicator\": {\n   368→                            \"type\": \"string\",\n   369→                            \"description\": \"The indicator type\",\n   370→                        },\n   371→                    },\n   372→                    \"required\": [\"service\", \"indicator\"],\n   373→                },\n   374→            ),\n   375→            Tool(\n   376→                name=\"export_data\",\n   377→                description=\"Export search results in specified format\",\n   378→                inputSchema={\n   379→                    \"type\": \"object\",\n   380→                    \"properties\": {\n   381→                        \"service\": {\n   382→                            \"type\": \"string\",\n   383→                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n   384→                        },\n   385→                        \"indicator\": {\n   386→                            \"type\": \"string\",\n   387→                            \"description\": \"The indicator to export data for\",\n   388→                        },\n   389→                        \"format\": {\n   390→                            \"type\": \"string\",\n   391→                            \"description\": \"Export format (json or csv)\",\n   392→                            \"enum\": [\"json\", \"csv\"],\n   393→                            \"default\": \"json\",\n   394→                        },\n   395→                    },\n   396→                    \"required\": [\"service\", \"indicator\"],\n   397→                },\n   398→            ),\n   399→            Tool(\n   400→                name=\"search_compromised_dataset\",\n   401→                description=\"Search compromised data set information\",\n   402→                inputSchema={\n   403→                    \"type\": \"object\",\n   404→                    \"properties\": {\n   405→                        \"indicator\": {\n   406→                            \"type\": \"string\",\n   407→                            \"description\": \"The indicator to search for\",\n   408→                        },\n   409→                        \"limit\": {\n   410→                            \"type\": \"integer\",\n   411→                            \"description\": \"Maximum number of results (default: 50)\",\n   412→                            \"default\": 50,\n   413→                            \"minimum\": 1,\n   414→                            \"maximum\": 100,\n   415→                        },\n   416→                    },\n   417→                    \"required\": [\"indicator\"],\n   418→                },\n   419→            ),\n   420→            Tool(\n   421→                name=\"export_compromised_dataset\",\n   422→                description=\"Export compromised data set as CSV/JSON\",\n   423→                inputSchema={\n   424→                    \"type\": \"object\",\n   425→                    \"properties\": {\n   426→                        \"indicator\": {\n   427→                            \"type\": \"string\",\n   428→                            \"description\": \"The indicator to export data for\",\n   429→                        },\n   430→                        \"format\": {\n   431→                            \"type\": \"string\",\n   432→                            \"description\": \"Export format (json or csv)\",\n   433→                            \"enum\": [\"json\", \"csv\"],\n   434→                            \"default\": \"json\",\n   435→                        },\n   436→                    },\n   437→                    \"required\": [\"indicator\"],\n   438→                },\n   439→            ),\n   440→            Tool(\n   441→                name=\"get_compromised_dataset_node\",\n   442→                description=\"Get detailed compromised data set node information (Cyber Security Edition required)\",\n   443→                inputSchema={\n   444→                    \"type\": \"object\",\n   445→                    \"properties\": {\n   446→                        \"node_id\": {\n   447→                            \"type\": \"string\",\n   448→                            \"description\": \"Node ID to get details for\",\n   449→                        }\n   450→                    },\n   451→                    \"required\": [\"node_id\"],\n   452→                },\n   453→            ),\n   454→            Tool(\n   455→                name=\"search_combo_binder\",\n   456→                description=\"Search leaked ID/Password combo information\",\n   457→                inputSchema={\n   458→                    \"type\": \"object\",\n   459→                    \"properties\": {\n   460→                        \"indicator\": {\n   461→                            \"type\": \"string\",\n   462→                            \"description\": \"The indicator to search for\",\n   463→                        },\n   464→                        \"limit\": {\n   465→                            \"type\": \"integer\",\n   466→                            \"description\": \"Maximum number of results (default: 50)\",\n   467→                            \"default\": 50,\n   468→                            \"minimum\": 1,\n   469→                            \"maximum\": 100,\n   470→                        },\n   471→                    },\n   472→                    \"required\": [\"indicator\"],\n   473→                },\n   474→            ),\n   475→            Tool(\n   476→                name=\"export_combo_binder\",\n   477→                description=\"Export combo binder data as CSV/JSON\",\n   478→                inputSchema={\n   479→                    \"type\": \"object\",\n   480→                    \"properties\": {\n   481→                        \"indicator\": {\n   482→                            \"type\": \"string\",\n   483→                            \"description\": \"The indicator to export data for\",\n   484→                        },\n   485→                        \"format\": {\n   486→                            \"type\": \"string\",\n   487→                            \"description\": \"Export format (json or csv)\",\n   488→                            \"enum\": [\"json\", \"csv\"],\n   489→                            \"default\": \"json\",\n   490→                        },\n   491→                    },\n   492→                    \"required\": [\"indicator\"],\n   493→                },\n   494→            ),\n   495→            Tool(\n   496→                name=\"search_ulp_binder\",\n   497→                description=\"Search URL-Login-Password combination information\",\n   498→                inputSchema={\n   499→                    \"type\": \"object\",\n   500→                    \"properties\": {\n   501→                        \"indicator\": {\n   502→                            \"type\": \"string\",\n   503→                            \"description\": \"The indicator to search for\",\n   504→                        },\n   505→                        \"limit\": {\n   506→                            \"type\": \"integer\",\n   507→                            \"description\": \"Maximum number of results (default: 50)\",\n   508→                            \"default\": 50,\n   509→                            \"minimum\": 1,\n   510→                            \"maximum\": 100,\n   511→                        },\n   512→                    },\n   513→                    \"required\": [\"indicator\"],\n   514→                },\n   515→            ),\n   516→            Tool(\n   517→                name=\"export_ulp_binder\",\n   518→                description=\"Export ULP binder data as CSV/JSON\",\n   519→                inputSchema={\n   520→                    \"type\": \"object\",\n   521→                    \"properties\": {\n   522→                        \"indicator\": {\n   523→                            \"type\": \"string\",\n   524→                            \"description\": \"The indicator to export data for\",\n   525→                        },\n   526→                        \"format\": {\n   527→                            \"type\": \"string\",\n   528→                            \"description\": \"Export format (json or csv)\",\n   529→                            \"enum\": [\"json\", \"csv\"],\n   530→                            \"default\": \"json\",\n   531→                        },\n   532→                    },\n   533→                    \"required\": [\"indicator\"],\n   534→                },\n   535→            ),\n   536→            Tool(\n   537→                name=\"search_government_monitoring\",\n   538→                description=\"Search government sector threat monitoring data using url: or id: indicators\",\n   539→                inputSchema={\n   540→                    \"type\": \"object\",\n   541→                    \"properties\": {\n   542→                        \"indicator\": {\n   543→                            \"type\": \"string\",\n   544→                            \"description\": \"Search query - use 'url:hackersite.com' to search threat event URLs or 'id:hacker123' to search actor IDs. Leave empty for recent list.\",\n   545→                        },\n   546→                        \"limit\": {\n   547→                            \"type\": \"integer\",\n   548→                            \"description\": \"Maximum number of results (default: 50)\",\n   549→                            \"default\": 50,\n   550→                            \"minimum\": 1,\n   551→                            \"maximum\": 100,\n   552→                        },\n   553→                        \"cursor\": {\n   554→                            \"type\": \"integer\",\n   555→                            \"description\": \"Pagination cursor (default: 0)\",\n   556→                            \"default\": 0,\n   557→                            \"minimum\": 0,\n   558→                        },\n   559→                        \"orderType\": {\n   560→                            \"type\": \"string\",\n   561→                            \"description\": \"Order type\",\n   562→                            \"enum\": [\"detectionTime\", \"title\", \"author\"],\n   563→                            \"default\": \"detectionTime\",\n   564→                        },\n   565→                        \"order\": {\n   566→                            \"type\": \"string\",\n   567→                            \"description\": \"Sort order\",\n   568→                            \"enum\": [\"asc\", \"desc\"],\n   569→                            \"default\": \"desc\",\n   570→                        },\n   571→                    },\n   572→                    \"required\": [\"indicator\"],\n   573→                },\n   574→            ),\n   575→            Tool(\n   576→                name=\"search_leaked_monitoring\",\n   577→                description=\"Search enterprise sector threat monitoring data using url: or id: indicators\",\n   578→                inputSchema={\n   579→                    \"type\": \"object\",\n   580→                    \"properties\": {\n   581→                        \"indicator\": {\n   582→                            \"type\": \"string\",\n   583→                            \"description\": \"Search query - use 'url:hackersite.com' to search threat event URLs or 'id:hacker123' to search actor IDs. Leave empty for recent list.\",\n   584→                        },\n   585→                        \"limit\": {\n   586→                            \"type\": \"integer\",\n   587→                            \"description\": \"Maximum number of results (default: 50)\",\n   588→                            \"default\": 50,\n   589→                            \"minimum\": 1,\n   590→                            \"maximum\": 100,\n   591→                        },\n   592→                        \"cursor\": {\n   593→                            \"type\": \"integer\",\n   594→                            \"description\": \"Pagination cursor (default: 0)\",\n   595→                            \"default\": 0,\n   596→                            \"minimum\": 0,\n   597→                        },\n   598→                        \"orderType\": {\n   599→                            \"type\": \"string\",\n   600→                            \"description\": \"Order type\",\n   601→                            \"enum\": [\"detectionTime\", \"title\", \"author\"],\n   602→                            \"default\": \"detectionTime\",\n   603→                        },\n   604→                        \"order\": {\n   605→                            \"type\": \"string\",\n   606→                            \"description\": \"Sort order\",\n   607→                            \"enum\": [\"asc\", \"desc\"],\n   608→                            \"default\": \"desc\",\n   609→                        },\n   610→                    },\n   611→                    \"required\": [\"indicator\"],\n   612→                },\n   613→            ),\n   614→            Tool(\n   615→                name=\"download_file\",\n   616→                description=\"Download file by hash from dt or tt service\",\n   617→                inputSchema={\n   618→                    \"type\": \"object\",\n   619→                    \"properties\": {\n   620→                        \"service\": {\n   621→                            \"type\": \"string\",\n   622→                            \"description\": \"Service type (dt or tt)\",\n   623→                            \"enum\": [\"dt\", \"tt\"],\n   624→                        },\n   625→                        \"file_hash\": {\n   626→                            \"type\": \"string\",\n   627→                            \"description\": \"File hash to download\",\n   628→                        },\n   629→                    },\n   630→                    \"required\": [\"service\", \"file_hash\"],\n   631→                },\n   632→            ),\n   633→            Tool(\n   634→                name=\"search_pagination\",\n   635→                description=\"Pagination search using search ID for dt or tt service\",\n   636→                inputSchema={\n   637→                    \"type\": \"object\",\n   638→                    \"properties\": {\n   639→                        \"service\": {\n   640→                            \"type\": \"string\",\n   641→                            \"description\": \"Service type (dt or tt)\",\n   642→                            \"enum\": [\"dt\", \"tt\"],\n   643→                        },\n   644→                        \"search_id\": {\n   645→                            \"type\": \"string\",\n   646→                            \"description\": \"Search ID from previous search\",\n   647→                        },\n   648→                        \"cursor\": {\n   649→                            \"type\": \"integer\",\n   650→                            \"description\": \"Pagination cursor (default: 0)\",\n   651→                            \"default\": 0,\n   652→                            \"minimum\": 0,\n   653→                        },\n   654→                        \"limit\": {\n   655→                            \"type\": \"integer\",\n   656→                            \"description\": \"Maximum number of results (default: 50)\",\n   657→                            \"default\": 50,\n   658→                            \"minimum\": 1,\n   659→                            \"maximum\": 100,\n   660→                        },\n   661→                    },\n   662→                    \"required\": [\"service\", \"search_id\"],\n   663→                },\n   664→            ),\n   665→            Tool(\n   666→                name=\"get_user_quotas\",\n   667→                description=\"Get API usage quotas by service\",\n   668→                inputSchema={\"type\": \"object\", \"properties\": {}, \"required\": []},\n   669→            ),\n   670→        ]\n   671→    except Exception as e:\n   672→        print(f\"Error in handle_list_tools: {e}\", file=sys.stderr)\n   673→        import traceback\n   674→\n   675→        traceback.print_exc(file=sys.stderr)\n   676→        return []\n   677→\n   678→\n   679→@server.call_tool()\n   680→async def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:\n   681→    \"\"\"Handle tool calls.\"\"\"\n   682→    global client\n   683→\n   684→    if client is None:\n   685→        return [\n   686→            TextContent(\n   687→                type=\"text\",\n   688→                text=\"Error: StealthMole client not initialized. Please check your API credentials.\",\n   689→            )\n   690→        ]\n   691→\n   692→    try:\n   693→        if name == \"search_darkweb\":\n   694→            result = await client.search_darkweb(\n   695→                indicator=arguments[\"indicator\"],\n   696→                text=arguments[\"text\"],\n   697→                target=arguments.get(\"target\", \"all\"),\n   698→                limit=arguments.get(\"limit\", 50),\n   699→                orderType=arguments.get(\"orderType\", \"createDate\"),\n   700→                order=arguments.get(\"order\", \"desc\"),\n   701→            )\n   702→        elif name == \"search_telegram\":\n   703→            result = await client.search_telegram(\n   704→                indicator=arguments[\"indicator\"],\n   705→                text=arguments[\"text\"],\n   706→                target=arguments.get(\"target\", \"all\"),\n   707→                limit=arguments.get(\"limit\", 50),\n   708→                orderType=arguments.get(\"orderType\", \"createDate\"),\n   709→                order=arguments.get(\"order\", \"desc\"),\n   710→            )\n   711→        elif name == \"search_credentials\":\n   712→            result = await client.search_credentials(\n   713→                indicator=arguments[\"indicator\"],\n   714→                limit=arguments.get(\"limit\", 50),\n   715→                cursor=arguments.get(\"cursor\", 0),\n   716→                orderType=arguments.get(\"orderType\", \"leakedDate\"),\n   717→                order=arguments.get(\"order\", \"desc\"),\n   718→                start=arguments.get(\"start\"),\n   719→                end=arguments.get(\"end\"),\n   720→            )\n   721→        elif name == \"search_ransomware\":\n   722→            result = await client.search_ransomware(\n   723→                indicator=arguments[\"indicator\"],\n   724→                limit=arguments.get(\"limit\", 50),\n   725→                cursor=arguments.get(\"cursor\", 0),\n   726→                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n   727→                order=arguments.get(\"order\", \"desc\"),\n   728→            )\n   729→        elif name == \"get_node_details\":\n   730→            result = await client.get_node_details(\n   731→                service=arguments[\"service\"],\n   732→                node_id=arguments[\"node_id\"],\n   733→                pid=arguments.get(\"pid\"),\n   734→                data_from=arguments.get(\"data_from\", False),\n   735→                include_url=arguments.get(\"include_url\", False),\n   736→                include_contents=arguments.get(\"include_contents\", True),\n   737→            )\n   738→        elif name == \"get_targets\":\n   739→            result = await client.get_targets(\n   740→                service=arguments[\"service\"], indicator=arguments[\"indicator\"]\n   741→            )\n   742→        elif name == \"export_data\":\n   743→            result = await client.export_data(\n   744→                service=arguments[\"service\"],\n   745→                indicator=arguments[\"indicator\"],\n   746→                format=arguments.get(\"format\", \"json\"),\n   747→            )\n   748→        elif name == \"search_compromised_dataset\":\n   749→            result = await client.search_compromised_dataset(\n   750→                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n   751→            )\n   752→        elif name == \"export_compromised_dataset\":\n   753→            result = await client.export_compromised_dataset(\n   754→                indicator=arguments[\"indicator\"], format=arguments.get(\"format\", \"json\")\n   755→            )\n   756→        elif name == \"get_compromised_dataset_node\":\n   757→            result = await client.get_compromised_dataset_node(\n   758→                node_id=arguments[\"node_id\"]\n   759→            )\n   760→        elif name == \"search_combo_binder\":\n   761→            result = await client.search_combo_binder(\n   762→                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n   763→            )\n   764→        elif name == \"export_combo_binder\":\n   765→            result = await client.export_combo_binder(\n   766→                indicator=arguments[\"indicator\"], format=arguments.get(\"format\", \"json\")\n   767→            )\n   768→        elif name == \"search_ulp_binder\":\n   769→            result = await client.search_ulp_binder(\n   770→                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n   771→            )\n   772→        elif name == \"export_ulp_binder\":\n   773→            result = await client.export_ulp_binder(\n   774→                indicator=arguments[\"indicator\"], format=arguments.get(\"format\", \"json\")\n   775→            )\n   776→        elif name == \"search_government_monitoring\":\n   777→            result = await client.search_government_monitoring(\n   778→                indicator=arguments[\"indicator\"],\n   779→                limit=arguments.get(\"limit\", 50),\n   780→                cursor=arguments.get(\"cursor\", 0),\n   781→                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n   782→                order=arguments.get(\"order\", \"desc\"),\n   783→            )\n   784→        elif name == \"search_leaked_monitoring\":\n   785→            result = await client.search_leaked_monitoring(\n   786→                indicator=arguments[\"indicator\"],\n   787→                limit=arguments.get(\"limit\", 50),\n   788→                cursor=arguments.get(\"cursor\", 0),\n   789→                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n   790→                order=arguments.get(\"order\", \"desc\"),\n   791→            )\n   792→        elif name == \"download_file\":\n   793→            file_content = await client.download_file(\n   794→                service=arguments[\"service\"], file_hash=arguments[\"file_hash\"]\n   795→            )\n   796→            return [\n   797→                TextContent(\n   798→                    type=\"text\",\n   799→                    text=f\"Downloaded file {arguments['file_hash']} from {arguments['service']} service. File size: {len(file_content)} bytes\",\n   800→                )\n   801→            ]\n   802→        elif name == \"search_pagination\":\n   803→            result = await client.search_pagination(\n   804→                service=arguments[\"service\"],\n   805→                search_id=arguments[\"search_id\"],\n   806→                cursor=arguments.get(\"cursor\", 0),\n   807→                limit=arguments.get(\"limit\", 50),\n   808→            )\n   809→        elif name == \"get_user_quotas\":\n   810→            result = await client.get_user_quotas()\n   811→        else:\n   812→            return [TextContent(type=\"text\", text=f\"Unknown tool: {name}\")]\n   813→\n   814→        return [TextContent(type=\"text\", text=f\"StealthMole API Results:\\n\\n{result}\")]\n   815→\n   816→    except asyncio.TimeoutError:\n   817→        return [\n   818→            TextContent(\n   819→                type=\"text\",\n   820→                text=\"Request timed out. The API request took too long to complete.\",\n   821→            )\n   822→        ]\n   823→    except Exception as e:\n   824→        error_msg = str(e)\n   825→        if \"timeout\" in error_msg.lower():\n   826→            return [\n   827→                TextContent(\n   828→                    type=\"text\",\n   829→                    text=f\"Timeout error: {error_msg}. Try reducing the result limit or check your network connection.\",\n   830→                )\n   831→            ]\n   832→        return [\n   833→            TextContent(type=\"text\", text=f\"Error calling StealthMole API: {error_msg}\")\n   834→        ]\n   835→\n   836→\n   837→async def run_server():\n   838→    \"\"\"Run the MCP server.\"\"\"\n   839→    global client\n   840→\n   841→    try:\n   842→        print(\"Starting StealthMole MCP server...\", file=sys.stderr)\n   843→\n   844→        # Initialize StealthMole client\n   845→        access_key = os.getenv(\"STEALTHMOLE_ACCESS_KEY\")\n   846→        secret_key = os.getenv(\"STEALTHMOLE_SECRET_KEY\")\n   847→\n   848→        print(f\"Access key: {'SET' if access_key else 'NOT SET'}\", file=sys.stderr)\n   849→        print(f\"Secret key: {'SET' if secret_key else 'NOT SET'}\", file=sys.stderr)\n   850→\n   851→        if not access_key or not secret_key:\n   852→            print(\n   853→                \"Warning: STEALTHMOLE_ACCESS_KEY and STEALTHMOLE_SECRET_KEY environment variables not set\",\n   854→                file=sys.stderr,\n   855→            )\n   856→            print(\"MCP server will start but tools will not function\", file=sys.stderr)\n   857→        else:\n   858→            try:\n   859→                config = StealthMoleConfig(access_key=access_key, secret_key=secret_key)\n   860→                print(\"StealthMole config created\", file=sys.stderr)\n   861→                client = StealthMoleClient(config)\n   862→                print(\"StealthMole client initialized\", file=sys.stderr)\n   863→\n   864→                # API 연결 테스트 (타임아웃 없이 간단히)\n   865→                try:\n   866→                    quotas = await client.get_user_quotas()\n   867→                    print(\n   868→                        f\"✓ API connection successful. Available quotas: {quotas}\",\n   869→                        file=sys.stderr,\n   870→                    )\n   871→                except Exception as api_error:\n   872→                    print(f\"Warning: API test failed: {api_error}\", file=sys.stderr)\n   873→                    print(\"Continuing with server startup...\", file=sys.stderr)\n   874→\n   875→            except Exception as e:\n   876→                print(\n   877→                    f\"Warning: Error creating StealthMole client: {e}\", file=sys.stderr\n   878→                )\n   879→                print(\n   880→                    \"MCP server will start but tools may not function properly\",\n   881→                    file=sys.stderr,\n   882→                )\n   883→                import traceback\n   884→\n   885→                traceback.print_exc(file=sys.stderr)\n   886→\n   887→        print(\"Creating stdio server...\", file=sys.stderr)\n   888→        async with stdio_server() as (read_stream, write_stream):\n   889→            print(\"Starting MCP server...\", file=sys.stderr)\n   890→            try:\n   891→                await server.run(\n   892→                    read_stream,\n   893→                    write_stream,\n   894→                    InitializationOptions(\n   895→                        server_name=\"stealthmole-mcp\",\n   896→                        server_version=\"0.1.0\",\n   897→                        capabilities=server.get_capabilities(\n   898→                            notification_options=NotificationOptions(),\n   899→                            experimental_capabilities={},\n   900→                        ),\n   901→                    ),\n   902→                )\n   903→                print(\"MCP server completed normally\", file=sys.stderr)\n   904→            except Exception as e:\n   905→                print(f\"Error in MCP server.run: {e}\", file=sys.stderr)\n   906→                import traceback\n   907→\n   908→                traceback.print_exc(file=sys.stderr)\n   909→                raise\n   910→    except Exception as e:\n   911→        print(f\"Error in run_server: {e}\", file=sys.stderr)\n   912→        import traceback\n   913→\n   914→        traceback.print_exc(file=sys.stderr)\n   915→\n   916→\n   917→def main():\n   918→    \"\"\"Main entry point for the MCP server.\"\"\"\n   919→    asyncio.run(run_server())\n   920→\n   921→\n   922→if __name__ == \"__main__\":\n   923→    main()\n   924→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"484383dc-d1b3-453f-9d8f-4a27520d432a","timestamp":"2025-07-15T04:23:55.783Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/realsun/data/git/mole-mcp-server/src/server.py","content":"\"\"\"StealthMole MCP Server implementation.\"\"\"\n\nimport asyncio\nimport os\nimport sys\nfrom typing import Any, Optional, Sequence\n\nfrom dotenv import load_dotenv\nfrom mcp.server import NotificationOptions, Server\nfrom mcp.server.models import InitializationOptions\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import Resource, TextContent, Tool\nfrom pydantic import AnyUrl\n\nfrom src.tools import *\nfrom src.utils.client import StealthMoleClient\nfrom src.utils.config import StealthMoleConfig\n\nload_dotenv()\n\n# Global client instance\nclient: Optional[StealthMoleClient] = None\n\nserver: Server = Server(\n    \"stealthmole-mcp\",\n    \"0.2.0\",\n)\n\n\n@server.list_resources()\nasync def handle_list_resources() -> list[Resource]:\n    \"\"\"List available resources.\"\"\"\n    return []\n\n\n@server.read_resource()\nasync def handle_read_resource(uri: AnyUrl) -> str:\n    \"\"\"Read a specific resource.\"\"\"\n    raise ValueError(f\"Unknown resource: {uri}\")\n\n\n@server.list_tools()\nasync def handle_list_tools() -> list[Tool]:\n    \"\"\"List available StealthMole tools.\"\"\"\n    try:\n        print(\"Returning StealthMole tools list\", file=sys.stderr)\n        return [\n            Tool(\n                name=\"search_darkweb\",\n                description=\"Search dark web content for indicators like domains, IPs, emails, etc.\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type to search for\",\n                            \"enum\": [\n                                \"adsense\",\n                                \"analyticsid\",\n                                \"band\",\n                                \"bitcoin\",\n                                \"blueprint\",\n                                \"creditcard\",\n                                \"cve\",\n                                \"discord\",\n                                \"document\",\n                                \"domain\",\n                                \"email\",\n                                \"ethereum\",\n                                \"exefile\",\n                                \"facebook\",\n                                \"filehosting\",\n                                \"googledrive\",\n                                \"gps\",\n                                \"hash\",\n                                \"hashstring\",\n                                \"i2p\",\n                                \"i2purl\",\n                                \"id\",\n                                \"image\",\n                                \"instagram\",\n                                \"ioc\",\n                                \"ip\",\n                                \"kakaotalk\",\n                                \"keyword\",\n                                \"kssn\",\n                                \"leakedaudio\",\n                                \"leakedemailfile\",\n                                \"leakedvideo\",\n                                \"line\",\n                                \"linkedin\",\n                                \"malware\",\n                                \"monero\",\n                                \"otherfile\",\n                                \"pastebin\",\n                                \"pgp\",\n                                \"serverstatus\",\n                                \"session\",\n                                \"shorten\",\n                                \"sshkey\",\n                                \"sslkey\",\n                                \"tel\",\n                                \"telegram\",\n                                \"tor\",\n                                \"torurl\",\n                                \"twitter\",\n                                \"url\",\n                            ],\n                        },\n                        \"text\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search keyword or data to find. Supports AND, OR, NOT operators (max 3 OR, 5 total operators)\",\n                        },\n                        \"target\": {\n                            \"type\": \"string\",\n                            \"description\": \"Target type to search (default: 'all'). Use comma-separated values for multiple targets\",\n                            \"default\": \"all\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Ordering type\",\n                            \"enum\": [\"createDate\", \"value\"],\n                            \"default\": \"createDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\", \"text\"],\n                },\n            ),\n            Tool(\n                name=\"search_telegram\",\n                description=\"Search Telegram content for indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type to search for\",\n                            \"enum\": [\n                                \"band\",\n                                \"bitcoin\",\n                                \"creditcard\",\n                                \"cve\",\n                                \"discord\",\n                                \"document\",\n                                \"domain\",\n                                \"email\",\n                                \"ethereum\",\n                                \"exefile\",\n                                \"facebook\",\n                                \"filehosting\",\n                                \"googledrive\",\n                                \"gps\",\n                                \"hash\",\n                                \"hashstring\",\n                                \"i2p\",\n                                \"i2purl\",\n                                \"id\",\n                                \"image\",\n                                \"instagram\",\n                                \"ip\",\n                                \"kakaotalk\",\n                                \"keyword\",\n                                \"kssn\",\n                                \"line\",\n                                \"monero\",\n                                \"otherfile\",\n                                \"pastebin\",\n                                \"pgp\",\n                                \"tel\",\n                                \"session\",\n                                \"shorten\",\n                                \"telegram\",\n                                \"telegram.channel\",\n                                \"telegram.message\",\n                                \"telegram.user\",\n                                \"tor\",\n                                \"torurl\",\n                                \"tox\",\n                                \"twitter\",\n                                \"url\",\n                            ],\n                        },\n                        \"text\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search keyword or data to find. Supports AND, OR, NOT operators (max 3 OR, 5 total operators)\",\n                        },\n                        \"target\": {\n                            \"type\": \"string\",\n                            \"description\": \"Target type to search (default: 'all'). Use comma-separated values for multiple targets\",\n                            \"default\": \"all\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Ordering type\",\n                            \"enum\": [\"createDate\", \"value\"],\n                            \"default\": \"createDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\", \"text\"],\n                },\n            ),\n            Tool(\n                name=\"search_credentials\",\n                description=\"Search for leaked credentials using keywords or specific indicators (domain:, email:, id:, password:, after:, before:)\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - can use indicators like 'domain:example.com', 'email:user@domain.com', 'id:username', 'password:pass123', 'after:2023-01', 'before:2024-01' or plain keywords\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\n                                \"leakedDate\",\n                                \"domain\",\n                                \"email\",\n                                \"password\",\n                                \"leakedFrom\",\n                            ],\n                            \"default\": \"leakedDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                        \"start\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Filter data added to the system after start time (UTC timestamp)\",\n                        },\n                        \"end\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Filter data added to the system before end time (UTC timestamp)\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_ransomware\",\n                description=\"Search ransomware monitoring data using torurl: or domain: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'torurl:site.onion' to search ransomware sites or 'domain:victim.com' to search victim websites. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"victim\", \"attackGroup\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"get_node_details\",\n                description=\"Get detailed information about a specific node\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"node_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Node ID to get details for\",\n                        },\n                        \"pid\": {\n                            \"type\": \"string\",\n                            \"description\": \"Parent node ID (optional)\",\n                        },\n                        \"data_from\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Import data source list (default: False)\",\n                            \"default\": False,\n                        },\n                        \"include_url\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Import included URL list (default: False)\",\n                            \"default\": False,\n                        },\n                        \"include_contents\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Include HTML source contents for torurl, i2purl, url (default: True)\",\n                            \"default\": True,\n                        },\n                    },\n                    \"required\": [\"service\", \"node_id\"],\n                },\n            ),\n            Tool(\n                name=\"get_targets\",\n                description=\"Get available search targets for a service and indicator\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type\",\n                        },\n                    },\n                    \"required\": [\"service\", \"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_data\",\n                description=\"Export search results in specified format\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"service\", \"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_compromised_dataset\",\n                description=\"Search compromised data set information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_compromised_dataset\",\n                description=\"Export compromised data set as CSV/JSON\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"get_compromised_dataset_node\",\n                description=\"Get detailed compromised data set node information (Cyber Security Edition required)\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"node_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Node ID to get details for\",\n                        }\n                    },\n                    \"required\": [\"node_id\"],\n                },\n            ),\n            Tool(\n                name=\"search_combo_binder\",\n                description=\"Search leaked ID/Password combo information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_combo_binder\",\n                description=\"Export combo binder data as CSV/JSON\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_ulp_binder\",\n                description=\"Search URL-Login-Password combination information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_ulp_binder\",\n                description=\"Export ULP binder data as CSV/JSON\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_government_monitoring\",\n                description=\"Search government sector threat monitoring data using url: or id: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'url:hackersite.com' to search threat event URLs or 'id:hacker123' to search actor IDs. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"title\", \"author\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_leaked_monitoring\",\n                description=\"Search enterprise sector threat monitoring data using url: or id: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'url:hackersite.com' to search threat event URLs or 'id:hacker123' to search actor IDs. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"title\", \"author\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"download_file\",\n                description=\"Download file by hash from dt or tt service\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt or tt)\",\n                            \"enum\": [\"dt\", \"tt\"],\n                        },\n                        \"file_hash\": {\n                            \"type\": \"string\",\n                            \"description\": \"File hash to download\",\n                        },\n                    },\n                    \"required\": [\"service\", \"file_hash\"],\n                },\n            ),\n            Tool(\n                name=\"search_pagination\",\n                description=\"Pagination search using search ID for dt or tt service\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt or tt)\",\n                            \"enum\": [\"dt\", \"tt\"],\n                        },\n                        \"search_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search ID from previous search\",\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"service\", \"search_id\"],\n                },\n            ),\n            Tool(\n                name=\"get_user_quotas\",\n                description=\"Get API usage quotas by service\",\n                inputSchema={\"type\": \"object\", \"properties\": {}, \"required\": []},\n            ),\n        ]\n    except Exception as e:\n        print(f\"Error in handle_list_tools: {e}\", file=sys.stderr)\n        import traceback\n\n        traceback.print_exc(file=sys.stderr)\n        return []\n\n\n@server.call_tool()\nasync def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:\n    \"\"\"Handle tool calls.\"\"\"\n    global client\n\n    if client is None:\n        return [\n            TextContent(\n                type=\"text\",\n                text=\"Error: StealthMole client not initialized. Please check your API credentials.\",\n            )\n        ]\n\n    try:\n        if name == \"search_darkweb\":\n            result = await client.search_darkweb(\n                indicator=arguments[\"indicator\"],\n                text=arguments[\"text\"],\n                target=arguments.get(\"target\", \"all\"),\n                limit=arguments.get(\"limit\", 50),\n                orderType=arguments.get(\"orderType\", \"createDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_telegram\":\n            result = await client.search_telegram(\n                indicator=arguments[\"indicator\"],\n                text=arguments[\"text\"],\n                target=arguments.get(\"target\", \"all\"),\n                limit=arguments.get(\"limit\", 50),\n                orderType=arguments.get(\"orderType\", \"createDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_credentials\":\n            result = await client.search_credentials(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"leakedDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n                start=arguments.get(\"start\"),\n                end=arguments.get(\"end\"),\n            )\n        elif name == \"search_ransomware\":\n            result = await client.search_ransomware(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"get_node_details\":\n            result = await client.get_node_details(\n                service=arguments[\"service\"],\n                node_id=arguments[\"node_id\"],\n                pid=arguments.get(\"pid\"),\n                data_from=arguments.get(\"data_from\", False),\n                include_url=arguments.get(\"include_url\", False),\n                include_contents=arguments.get(\"include_contents\", True),\n            )\n        elif name == \"get_targets\":\n            result = await client.get_targets(\n                service=arguments[\"service\"], indicator=arguments[\"indicator\"]\n            )\n        elif name == \"export_data\":\n            result = await client.export_data(\n                service=arguments[\"service\"],\n                indicator=arguments[\"indicator\"],\n                format=arguments.get(\"format\", \"json\"),\n            )\n        elif name == \"search_compromised_dataset\":\n            result = await client.search_compromised_dataset(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"export_compromised_dataset\":\n            result = await client.export_compromised_dataset(\n                indicator=arguments[\"indicator\"], format=arguments.get(\"format\", \"json\")\n            )\n        elif name == \"get_compromised_dataset_node\":\n            result = await client.get_compromised_dataset_node(\n                node_id=arguments[\"node_id\"]\n            )\n        elif name == \"search_combo_binder\":\n            result = await client.search_combo_binder(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"export_combo_binder\":\n            result = await client.export_combo_binder(\n                indicator=arguments[\"indicator\"], format=arguments.get(\"format\", \"json\")\n            )\n        elif name == \"search_ulp_binder\":\n            result = await client.search_ulp_binder(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"export_ulp_binder\":\n            result = await client.export_ulp_binder(\n                indicator=arguments[\"indicator\"], format=arguments.get(\"format\", \"json\")\n            )\n        elif name == \"search_government_monitoring\":\n            result = await client.search_government_monitoring(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_leaked_monitoring\":\n            result = await client.search_leaked_monitoring(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"download_file\":\n            file_content = await client.download_file(\n                service=arguments[\"service\"], file_hash=arguments[\"file_hash\"]\n            )\n            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"Downloaded file {arguments['file_hash']} from {arguments['service']} service. File size: {len(file_content)} bytes\",\n                )\n            ]\n        elif name == \"search_pagination\":\n            result = await client.search_pagination(\n                service=arguments[\"service\"],\n                search_id=arguments[\"search_id\"],\n                cursor=arguments.get(\"cursor\", 0),\n                limit=arguments.get(\"limit\", 50),\n            )\n        elif name == \"get_user_quotas\":\n            result = await client.get_user_quotas()\n        else:\n            return [TextContent(type=\"text\", text=f\"Unknown tool: {name}\")]\n\n        return [TextContent(type=\"text\", text=f\"StealthMole API Results:\\n\\n{result}\")]\n\n    except asyncio.TimeoutError:\n        return [\n            TextContent(\n                type=\"text\",\n                text=\"Request timed out. The API request took too long to complete.\",\n            )\n        ]\n    except Exception as e:\n        error_msg = str(e)\n        if \"timeout\" in error_msg.lower():\n            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"Timeout error: {error_msg}. Try reducing the result limit or check your network connection.\",\n                )\n            ]\n        return [\n            TextContent(type=\"text\", text=f\"Error calling StealthMole API: {error_msg}\")\n        ]\n\n\nasync def run_server():\n    \"\"\"Run the MCP server.\"\"\"\n    global client\n\n    try:\n        print(\"Starting StealthMole MCP server...\", file=sys.stderr)\n\n        # Initialize StealthMole client\n        access_key = os.getenv(\"STEALTHMOLE_ACCESS_KEY\")\n        secret_key = os.getenv(\"STEALTHMOLE_SECRET_KEY\")\n\n        print(f\"Access key: {'SET' if access_key else 'NOT SET'}\", file=sys.stderr)\n        print(f\"Secret key: {'SET' if secret_key else 'NOT SET'}\", file=sys.stderr)\n\n        if not access_key or not secret_key:\n            print(\n                \"Warning: STEALTHMOLE_ACCESS_KEY and STEALTHMOLE_SECRET_KEY environment variables not set\",\n                file=sys.stderr,\n            )\n            print(\"MCP server will start but tools will not function\", file=sys.stderr)\n        else:\n            try:\n                config = StealthMoleConfig(access_key=access_key, secret_key=secret_key)\n                print(\"StealthMole config created\", file=sys.stderr)\n                client = StealthMoleClient(config)\n                print(\"StealthMole client initialized\", file=sys.stderr)\n\n                # API 연결 테스트 (타임아웃 없이 간단히)\n                try:\n                    quotas = await client.get_user_quotas()\n                    print(\n                        f\"✓ API connection successful. Available quotas: {quotas}\",\n                        file=sys.stderr,\n                    )\n                except Exception as api_error:\n                    print(f\"Warning: API test failed: {api_error}\", file=sys.stderr)\n                    print(\"Continuing with server startup...\", file=sys.stderr)\n\n            except Exception as e:\n                print(\n                    f\"Warning: Error creating StealthMole client: {e}\", file=sys.stderr\n                )\n                print(\n                    \"MCP server will start but tools may not function properly\",\n                    file=sys.stderr,\n                )\n                import traceback\n\n                traceback.print_exc(file=sys.stderr)\n\n        print(\"Creating stdio server...\", file=sys.stderr)\n        async with stdio_server() as (read_stream, write_stream):\n            print(\"Starting MCP server...\", file=sys.stderr)\n            try:\n                await server.run(\n                    read_stream,\n                    write_stream,\n                    InitializationOptions(\n                        server_name=\"stealthmole-mcp\",\n                        server_version=\"0.1.0\",\n                        capabilities=server.get_capabilities(\n                            notification_options=NotificationOptions(),\n                            experimental_capabilities={},\n                        ),\n                    ),\n                )\n                print(\"MCP server completed normally\", file=sys.stderr)\n            except Exception as e:\n                print(f\"Error in MCP server.run: {e}\", file=sys.stderr)\n                import traceback\n\n                traceback.print_exc(file=sys.stderr)\n                raise\n    except Exception as e:\n        print(f\"Error in run_server: {e}\", file=sys.stderr)\n        import traceback\n\n        traceback.print_exc(file=sys.stderr)\n\n\ndef main():\n    \"\"\"Main entry point for the MCP server.\"\"\"\n    asyncio.run(run_server())\n\n\nif __name__ == \"__main__\":\n    main()\n","numLines":924,"startLine":1,"totalLines":924}}}
{"parentUuid":"484383dc-d1b3-453f-9d8f-4a27520d432a","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"e1862b0a-edaf-4305-96cf-2297be889bda","version":"1.0.51","message":{"id":"msg_01Er41GtM4LNG4WUPocTniQy","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"서버에서 프롬프트는 각 도구(tool)의 `description` 필드에 정의되어 있습니다. MCP 서버에서 기본 프롬프트를 설정하려면 MCP 프로토콜의 프롬프트 기능을 사용하거나, 서버 초기화 시 기본 설정을 추가할 수 있습니다."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":11101,"cache_read_input_tokens":14385,"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CR8AfpWvHFxLh5AdP3A3a","type":"assistant","uuid":"7b04f28f-9bac-47a9-a7bf-5ec66ca9c04c","timestamp":"2025-07-15T04:24:00.687Z"}
{"parentUuid":"7b04f28f-9bac-47a9-a7bf-5ec66ca9c04c","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"e1862b0a-edaf-4305-96cf-2297be889bda","version":"1.0.51","message":{"id":"msg_01Er41GtM4LNG4WUPocTniQy","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_017wwrvZsnB2W4PrbCgjNBAh","name":"TodoWrite","input":{"todos":[{"id":"1","content":"MCP 서버에 기본 프롬프트 기능 추가","status":"pending","priority":"high"},{"id":"2","content":"프롬프트 핸들러 구현","status":"pending","priority":"medium"},{"id":"3","content":"서버 설정에 기본 프롬프트 추가","status":"pending","priority":"medium"}]}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":11101,"cache_read_input_tokens":14385,"output_tokens":336,"service_tier":"standard"}},"requestId":"req_011CR8AfpWvHFxLh5AdP3A3a","type":"assistant","uuid":"4ef8137c-4dfd-4d95-a9d2-b62b1ca26aca","timestamp":"2025-07-15T04:24:03.053Z"}
{"parentUuid":"4ef8137c-4dfd-4d95-a9d2-b62b1ca26aca","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"e1862b0a-edaf-4305-96cf-2297be889bda","version":"1.0.51","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017wwrvZsnB2W4PrbCgjNBAh","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"b8d9954e-839f-413d-aa08-5f95f1c89b30","timestamp":"2025-07-15T04:24:03.093Z","toolUseResult":{"oldTodos":[],"newTodos":[{"content":"MCP 서버에 기본 프롬프트 기능 추가","status":"pending","priority":"high","id":"1"},{"content":"프롬프트 핸들러 구현","status":"pending","priority":"medium","id":"2"},{"content":"서버 설정에 기본 프롬프트 추가","status":"pending","priority":"medium","id":"3"}]}}
{"parentUuid":"b8d9954e-839f-413d-aa08-5f95f1c89b30","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"e1862b0a-edaf-4305-96cf-2297be889bda","version":"1.0.51","message":{"id":"msg_016b5E7KhKnD2uCdFut9mQec","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_0174HcuqZYt2VVWgSgd3e5ZT","name":"TodoWrite","input":{"todos":[{"id":"1","content":"MCP 서버에 기본 프롬프트 기능 추가","status":"in_progress","priority":"high"},{"id":"2","content":"프롬프트 핸들러 구현","status":"pending","priority":"medium"},{"id":"3","content":"서버 설정에 기본 프롬프트 추가","status":"pending","priority":"medium"}]}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":596,"cache_read_input_tokens":25486,"output_tokens":178,"service_tier":"standard"}},"requestId":"req_011CR8AgMsKS9g6fGWZj1xq5","type":"assistant","uuid":"6e3468d0-c3d1-44b4-baf9-8d178c3f047c","timestamp":"2025-07-15T04:24:06.788Z"}
{"parentUuid":"6e3468d0-c3d1-44b4-baf9-8d178c3f047c","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"e1862b0a-edaf-4305-96cf-2297be889bda","version":"1.0.51","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0174HcuqZYt2VVWgSgd3e5ZT","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"a6b0ab1d-c815-4586-8e57-8c85cca31de5","timestamp":"2025-07-15T04:24:06.805Z","toolUseResult":{"oldTodos":[{"content":"MCP 서버에 기본 프롬프트 기능 추가","status":"pending","priority":"high","id":"1"},{"content":"프롬프트 핸들러 구현","status":"pending","priority":"medium","id":"2"},{"content":"서버 설정에 기본 프롬프트 추가","status":"pending","priority":"medium","id":"3"}],"newTodos":[{"content":"MCP 서버에 기본 프롬프트 기능 추가","status":"in_progress","priority":"high","id":"1"},{"content":"프롬프트 핸들러 구현","status":"pending","priority":"medium","id":"2"},{"content":"서버 설정에 기본 프롬프트 추가","status":"pending","priority":"medium","id":"3"}]}}
{"parentUuid":"a6b0ab1d-c815-4586-8e57-8c85cca31de5","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"e1862b0a-edaf-4305-96cf-2297be889bda","version":"1.0.51","message":{"id":"msg_01UUuZpGnv6gMR2SwftpmB2d","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01AK947MLJ9cHn3Nmdz1cgG1","name":"Edit","input":{"file_path":"/Users/realsun/data/git/mole-mcp-server/src/server.py","old_string":"from mcp.types import Resource, TextContent, Tool","new_string":"from mcp.types import Prompt, PromptArgument, PromptMessage, Resource, TextContent, Tool"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":482,"cache_read_input_tokens":26082,"output_tokens":150,"service_tier":"standard"}},"requestId":"req_011CR8AgdfLHHbT8CAbmbmUF","type":"assistant","uuid":"5a1e5f01-4516-4109-8e94-3c1035c45ec6","timestamp":"2025-07-15T04:24:11.053Z"}
{"parentUuid":"5a1e5f01-4516-4109-8e94-3c1035c45ec6","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"e1862b0a-edaf-4305-96cf-2297be889bda","version":"1.0.51","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AK947MLJ9cHn3Nmdz1cgG1","type":"tool_result","content":"The file /Users/realsun/data/git/mole-mcp-server/src/server.py has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n     8→from dotenv import load_dotenv\n     9→from mcp.server import NotificationOptions, Server\n    10→from mcp.server.models import InitializationOptions\n    11→from mcp.server.stdio import stdio_server\n    12→from mcp.types import Prompt, PromptArgument, PromptMessage, Resource, TextContent, Tool\n    13→from pydantic import AnyUrl\n    14→\n    15→from src.tools import *\n    16→from src.utils.client import StealthMoleClient"}]},"uuid":"04b964fb-f1cd-4712-833d-18fa5356810a","timestamp":"2025-07-15T04:24:15.695Z","toolUseResult":{"filePath":"/Users/realsun/data/git/mole-mcp-server/src/server.py","oldString":"from mcp.types import Resource, TextContent, Tool","newString":"from mcp.types import Prompt, PromptArgument, PromptMessage, Resource, TextContent, Tool","originalFile":"\"\"\"StealthMole MCP Server implementation.\"\"\"\n\nimport asyncio\nimport os\nimport sys\nfrom typing import Any, Optional, Sequence\n\nfrom dotenv import load_dotenv\nfrom mcp.server import NotificationOptions, Server\nfrom mcp.server.models import InitializationOptions\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import Resource, TextContent, Tool\nfrom pydantic import AnyUrl\n\nfrom src.tools import *\nfrom src.utils.client import StealthMoleClient\nfrom src.utils.config import StealthMoleConfig\n\nload_dotenv()\n\n# Global client instance\nclient: Optional[StealthMoleClient] = None\n\nserver: Server = Server(\n    \"stealthmole-mcp\",\n    \"0.2.0\",\n)\n\n\n@server.list_resources()\nasync def handle_list_resources() -> list[Resource]:\n    \"\"\"List available resources.\"\"\"\n    return []\n\n\n@server.read_resource()\nasync def handle_read_resource(uri: AnyUrl) -> str:\n    \"\"\"Read a specific resource.\"\"\"\n    raise ValueError(f\"Unknown resource: {uri}\")\n\n\n@server.list_tools()\nasync def handle_list_tools() -> list[Tool]:\n    \"\"\"List available StealthMole tools.\"\"\"\n    try:\n        print(\"Returning StealthMole tools list\", file=sys.stderr)\n        return [\n            Tool(\n                name=\"search_darkweb\",\n                description=\"Search dark web content for indicators like domains, IPs, emails, etc.\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type to search for\",\n                            \"enum\": [\n                                \"adsense\",\n                                \"analyticsid\",\n                                \"band\",\n                                \"bitcoin\",\n                                \"blueprint\",\n                                \"creditcard\",\n                                \"cve\",\n                                \"discord\",\n                                \"document\",\n                                \"domain\",\n                                \"email\",\n                                \"ethereum\",\n                                \"exefile\",\n                                \"facebook\",\n                                \"filehosting\",\n                                \"googledrive\",\n                                \"gps\",\n                                \"hash\",\n                                \"hashstring\",\n                                \"i2p\",\n                                \"i2purl\",\n                                \"id\",\n                                \"image\",\n                                \"instagram\",\n                                \"ioc\",\n                                \"ip\",\n                                \"kakaotalk\",\n                                \"keyword\",\n                                \"kssn\",\n                                \"leakedaudio\",\n                                \"leakedemailfile\",\n                                \"leakedvideo\",\n                                \"line\",\n                                \"linkedin\",\n                                \"malware\",\n                                \"monero\",\n                                \"otherfile\",\n                                \"pastebin\",\n                                \"pgp\",\n                                \"serverstatus\",\n                                \"session\",\n                                \"shorten\",\n                                \"sshkey\",\n                                \"sslkey\",\n                                \"tel\",\n                                \"telegram\",\n                                \"tor\",\n                                \"torurl\",\n                                \"twitter\",\n                                \"url\",\n                            ],\n                        },\n                        \"text\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search keyword or data to find. Supports AND, OR, NOT operators (max 3 OR, 5 total operators)\",\n                        },\n                        \"target\": {\n                            \"type\": \"string\",\n                            \"description\": \"Target type to search (default: 'all'). Use comma-separated values for multiple targets\",\n                            \"default\": \"all\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Ordering type\",\n                            \"enum\": [\"createDate\", \"value\"],\n                            \"default\": \"createDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\", \"text\"],\n                },\n            ),\n            Tool(\n                name=\"search_telegram\",\n                description=\"Search Telegram content for indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type to search for\",\n                            \"enum\": [\n                                \"band\",\n                                \"bitcoin\",\n                                \"creditcard\",\n                                \"cve\",\n                                \"discord\",\n                                \"document\",\n                                \"domain\",\n                                \"email\",\n                                \"ethereum\",\n                                \"exefile\",\n                                \"facebook\",\n                                \"filehosting\",\n                                \"googledrive\",\n                                \"gps\",\n                                \"hash\",\n                                \"hashstring\",\n                                \"i2p\",\n                                \"i2purl\",\n                                \"id\",\n                                \"image\",\n                                \"instagram\",\n                                \"ip\",\n                                \"kakaotalk\",\n                                \"keyword\",\n                                \"kssn\",\n                                \"line\",\n                                \"monero\",\n                                \"otherfile\",\n                                \"pastebin\",\n                                \"pgp\",\n                                \"tel\",\n                                \"session\",\n                                \"shorten\",\n                                \"telegram\",\n                                \"telegram.channel\",\n                                \"telegram.message\",\n                                \"telegram.user\",\n                                \"tor\",\n                                \"torurl\",\n                                \"tox\",\n                                \"twitter\",\n                                \"url\",\n                            ],\n                        },\n                        \"text\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search keyword or data to find. Supports AND, OR, NOT operators (max 3 OR, 5 total operators)\",\n                        },\n                        \"target\": {\n                            \"type\": \"string\",\n                            \"description\": \"Target type to search (default: 'all'). Use comma-separated values for multiple targets\",\n                            \"default\": \"all\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Ordering type\",\n                            \"enum\": [\"createDate\", \"value\"],\n                            \"default\": \"createDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\", \"text\"],\n                },\n            ),\n            Tool(\n                name=\"search_credentials\",\n                description=\"Search for leaked credentials using keywords or specific indicators (domain:, email:, id:, password:, after:, before:)\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - can use indicators like 'domain:example.com', 'email:user@domain.com', 'id:username', 'password:pass123', 'after:2023-01', 'before:2024-01' or plain keywords\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\n                                \"leakedDate\",\n                                \"domain\",\n                                \"email\",\n                                \"password\",\n                                \"leakedFrom\",\n                            ],\n                            \"default\": \"leakedDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                        \"start\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Filter data added to the system after start time (UTC timestamp)\",\n                        },\n                        \"end\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Filter data added to the system before end time (UTC timestamp)\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_ransomware\",\n                description=\"Search ransomware monitoring data using torurl: or domain: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'torurl:site.onion' to search ransomware sites or 'domain:victim.com' to search victim websites. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"victim\", \"attackGroup\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"get_node_details\",\n                description=\"Get detailed information about a specific node\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"node_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Node ID to get details for\",\n                        },\n                        \"pid\": {\n                            \"type\": \"string\",\n                            \"description\": \"Parent node ID (optional)\",\n                        },\n                        \"data_from\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Import data source list (default: False)\",\n                            \"default\": False,\n                        },\n                        \"include_url\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Import included URL list (default: False)\",\n                            \"default\": False,\n                        },\n                        \"include_contents\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Include HTML source contents for torurl, i2purl, url (default: True)\",\n                            \"default\": True,\n                        },\n                    },\n                    \"required\": [\"service\", \"node_id\"],\n                },\n            ),\n            Tool(\n                name=\"get_targets\",\n                description=\"Get available search targets for a service and indicator\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type\",\n                        },\n                    },\n                    \"required\": [\"service\", \"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_data\",\n                description=\"Export search results in specified format\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"service\", \"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_compromised_dataset\",\n                description=\"Search compromised data set information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_compromised_dataset\",\n                description=\"Export compromised data set as CSV/JSON\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"get_compromised_dataset_node\",\n                description=\"Get detailed compromised data set node information (Cyber Security Edition required)\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"node_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Node ID to get details for\",\n                        }\n                    },\n                    \"required\": [\"node_id\"],\n                },\n            ),\n            Tool(\n                name=\"search_combo_binder\",\n                description=\"Search leaked ID/Password combo information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_combo_binder\",\n                description=\"Export combo binder data as CSV/JSON\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_ulp_binder\",\n                description=\"Search URL-Login-Password combination information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_ulp_binder\",\n                description=\"Export ULP binder data as CSV/JSON\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_government_monitoring\",\n                description=\"Search government sector threat monitoring data using url: or id: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'url:hackersite.com' to search threat event URLs or 'id:hacker123' to search actor IDs. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"title\", \"author\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_leaked_monitoring\",\n                description=\"Search enterprise sector threat monitoring data using url: or id: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'url:hackersite.com' to search threat event URLs or 'id:hacker123' to search actor IDs. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"title\", \"author\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"download_file\",\n                description=\"Download file by hash from dt or tt service\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt or tt)\",\n                            \"enum\": [\"dt\", \"tt\"],\n                        },\n                        \"file_hash\": {\n                            \"type\": \"string\",\n                            \"description\": \"File hash to download\",\n                        },\n                    },\n                    \"required\": [\"service\", \"file_hash\"],\n                },\n            ),\n            Tool(\n                name=\"search_pagination\",\n                description=\"Pagination search using search ID for dt or tt service\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt or tt)\",\n                            \"enum\": [\"dt\", \"tt\"],\n                        },\n                        \"search_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search ID from previous search\",\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"service\", \"search_id\"],\n                },\n            ),\n            Tool(\n                name=\"get_user_quotas\",\n                description=\"Get API usage quotas by service\",\n                inputSchema={\"type\": \"object\", \"properties\": {}, \"required\": []},\n            ),\n        ]\n    except Exception as e:\n        print(f\"Error in handle_list_tools: {e}\", file=sys.stderr)\n        import traceback\n\n        traceback.print_exc(file=sys.stderr)\n        return []\n\n\n@server.call_tool()\nasync def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:\n    \"\"\"Handle tool calls.\"\"\"\n    global client\n\n    if client is None:\n        return [\n            TextContent(\n                type=\"text\",\n                text=\"Error: StealthMole client not initialized. Please check your API credentials.\",\n            )\n        ]\n\n    try:\n        if name == \"search_darkweb\":\n            result = await client.search_darkweb(\n                indicator=arguments[\"indicator\"],\n                text=arguments[\"text\"],\n                target=arguments.get(\"target\", \"all\"),\n                limit=arguments.get(\"limit\", 50),\n                orderType=arguments.get(\"orderType\", \"createDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_telegram\":\n            result = await client.search_telegram(\n                indicator=arguments[\"indicator\"],\n                text=arguments[\"text\"],\n                target=arguments.get(\"target\", \"all\"),\n                limit=arguments.get(\"limit\", 50),\n                orderType=arguments.get(\"orderType\", \"createDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_credentials\":\n            result = await client.search_credentials(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"leakedDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n                start=arguments.get(\"start\"),\n                end=arguments.get(\"end\"),\n            )\n        elif name == \"search_ransomware\":\n            result = await client.search_ransomware(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"get_node_details\":\n            result = await client.get_node_details(\n                service=arguments[\"service\"],\n                node_id=arguments[\"node_id\"],\n                pid=arguments.get(\"pid\"),\n                data_from=arguments.get(\"data_from\", False),\n                include_url=arguments.get(\"include_url\", False),\n                include_contents=arguments.get(\"include_contents\", True),\n            )\n        elif name == \"get_targets\":\n            result = await client.get_targets(\n                service=arguments[\"service\"], indicator=arguments[\"indicator\"]\n            )\n        elif name == \"export_data\":\n            result = await client.export_data(\n                service=arguments[\"service\"],\n                indicator=arguments[\"indicator\"],\n                format=arguments.get(\"format\", \"json\"),\n            )\n        elif name == \"search_compromised_dataset\":\n            result = await client.search_compromised_dataset(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"export_compromised_dataset\":\n            result = await client.export_compromised_dataset(\n                indicator=arguments[\"indicator\"], format=arguments.get(\"format\", \"json\")\n            )\n        elif name == \"get_compromised_dataset_node\":\n            result = await client.get_compromised_dataset_node(\n                node_id=arguments[\"node_id\"]\n            )\n        elif name == \"search_combo_binder\":\n            result = await client.search_combo_binder(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"export_combo_binder\":\n            result = await client.export_combo_binder(\n                indicator=arguments[\"indicator\"], format=arguments.get(\"format\", \"json\")\n            )\n        elif name == \"search_ulp_binder\":\n            result = await client.search_ulp_binder(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"export_ulp_binder\":\n            result = await client.export_ulp_binder(\n                indicator=arguments[\"indicator\"], format=arguments.get(\"format\", \"json\")\n            )\n        elif name == \"search_government_monitoring\":\n            result = await client.search_government_monitoring(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_leaked_monitoring\":\n            result = await client.search_leaked_monitoring(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"download_file\":\n            file_content = await client.download_file(\n                service=arguments[\"service\"], file_hash=arguments[\"file_hash\"]\n            )\n            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"Downloaded file {arguments['file_hash']} from {arguments['service']} service. File size: {len(file_content)} bytes\",\n                )\n            ]\n        elif name == \"search_pagination\":\n            result = await client.search_pagination(\n                service=arguments[\"service\"],\n                search_id=arguments[\"search_id\"],\n                cursor=arguments.get(\"cursor\", 0),\n                limit=arguments.get(\"limit\", 50),\n            )\n        elif name == \"get_user_quotas\":\n            result = await client.get_user_quotas()\n        else:\n            return [TextContent(type=\"text\", text=f\"Unknown tool: {name}\")]\n\n        return [TextContent(type=\"text\", text=f\"StealthMole API Results:\\n\\n{result}\")]\n\n    except asyncio.TimeoutError:\n        return [\n            TextContent(\n                type=\"text\",\n                text=\"Request timed out. The API request took too long to complete.\",\n            )\n        ]\n    except Exception as e:\n        error_msg = str(e)\n        if \"timeout\" in error_msg.lower():\n            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"Timeout error: {error_msg}. Try reducing the result limit or check your network connection.\",\n                )\n            ]\n        return [\n            TextContent(type=\"text\", text=f\"Error calling StealthMole API: {error_msg}\")\n        ]\n\n\nasync def run_server():\n    \"\"\"Run the MCP server.\"\"\"\n    global client\n\n    try:\n        print(\"Starting StealthMole MCP server...\", file=sys.stderr)\n\n        # Initialize StealthMole client\n        access_key = os.getenv(\"STEALTHMOLE_ACCESS_KEY\")\n        secret_key = os.getenv(\"STEALTHMOLE_SECRET_KEY\")\n\n        print(f\"Access key: {'SET' if access_key else 'NOT SET'}\", file=sys.stderr)\n        print(f\"Secret key: {'SET' if secret_key else 'NOT SET'}\", file=sys.stderr)\n\n        if not access_key or not secret_key:\n            print(\n                \"Warning: STEALTHMOLE_ACCESS_KEY and STEALTHMOLE_SECRET_KEY environment variables not set\",\n                file=sys.stderr,\n            )\n            print(\"MCP server will start but tools will not function\", file=sys.stderr)\n        else:\n            try:\n                config = StealthMoleConfig(access_key=access_key, secret_key=secret_key)\n                print(\"StealthMole config created\", file=sys.stderr)\n                client = StealthMoleClient(config)\n                print(\"StealthMole client initialized\", file=sys.stderr)\n\n                # API 연결 테스트 (타임아웃 없이 간단히)\n                try:\n                    quotas = await client.get_user_quotas()\n                    print(\n                        f\"✓ API connection successful. Available quotas: {quotas}\",\n                        file=sys.stderr,\n                    )\n                except Exception as api_error:\n                    print(f\"Warning: API test failed: {api_error}\", file=sys.stderr)\n                    print(\"Continuing with server startup...\", file=sys.stderr)\n\n            except Exception as e:\n                print(\n                    f\"Warning: Error creating StealthMole client: {e}\", file=sys.stderr\n                )\n                print(\n                    \"MCP server will start but tools may not function properly\",\n                    file=sys.stderr,\n                )\n                import traceback\n\n                traceback.print_exc(file=sys.stderr)\n\n        print(\"Creating stdio server...\", file=sys.stderr)\n        async with stdio_server() as (read_stream, write_stream):\n            print(\"Starting MCP server...\", file=sys.stderr)\n            try:\n                await server.run(\n                    read_stream,\n                    write_stream,\n                    InitializationOptions(\n                        server_name=\"stealthmole-mcp\",\n                        server_version=\"0.1.0\",\n                        capabilities=server.get_capabilities(\n                            notification_options=NotificationOptions(),\n                            experimental_capabilities={},\n                        ),\n                    ),\n                )\n                print(\"MCP server completed normally\", file=sys.stderr)\n            except Exception as e:\n                print(f\"Error in MCP server.run: {e}\", file=sys.stderr)\n                import traceback\n\n                traceback.print_exc(file=sys.stderr)\n                raise\n    except Exception as e:\n        print(f\"Error in run_server: {e}\", file=sys.stderr)\n        import traceback\n\n        traceback.print_exc(file=sys.stderr)\n\n\ndef main():\n    \"\"\"Main entry point for the MCP server.\"\"\"\n    asyncio.run(run_server())\n\n\nif __name__ == \"__main__\":\n    main()\n","structuredPatch":[{"oldStart":9,"oldLines":7,"newStart":9,"newLines":7,"lines":[" from mcp.server import NotificationOptions, Server"," from mcp.server.models import InitializationOptions"," from mcp.server.stdio import stdio_server","-from mcp.types import Resource, TextContent, Tool","+from mcp.types import Prompt, PromptArgument, PromptMessage, Resource, TextContent, Tool"," from pydantic import AnyUrl"," "," from src.tools import *"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"04b964fb-f1cd-4712-833d-18fa5356810a","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"e1862b0a-edaf-4305-96cf-2297be889bda","version":"1.0.51","message":{"id":"msg_01Gd1psyfJF383g1xLceNjbS","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_018WeMxmb69Jn3ZbzEjikvh3","name":"Edit","input":{"file_path":"/Users/realsun/data/git/mole-mcp-server/src/server.py","old_string":"@server.read_resource()\nasync def handle_read_resource(uri: AnyUrl) -> str:\n    \"\"\"Read a specific resource.\"\"\"\n    raise ValueError(f\"Unknown resource: {uri}\")","new_string":"@server.read_resource()\nasync def handle_read_resource(uri: AnyUrl) -> str:\n    \"\"\"Read a specific resource.\"\"\"\n    raise ValueError(f\"Unknown resource: {uri}\")\n\n\n@server.list_prompts()\nasync def handle_list_prompts() -> list[Prompt]:\n    \"\"\"List available prompts.\"\"\"\n    return [\n        Prompt(\n            name=\"security_analysis\",\n            description=\"Analyze security threats using StealthMole data\",\n            arguments=[\n                PromptArgument(\n                    name=\"target\",\n                    description=\"Target to analyze (domain, IP, email, etc.)\",\n                    required=True,\n                ),\n                PromptArgument(\n                    name=\"analysis_type\",\n                    description=\"Type of analysis (threat_intelligence, credential_exposure, ransomware_monitoring)\",\n                    required=False,\n                ),\n            ],\n        ),\n        Prompt(\n            name=\"threat_investigation\",\n            description=\"Comprehensive threat investigation workflow\",\n            arguments=[\n                PromptArgument(\n                    name=\"indicator\",\n                    description=\"Threat indicator to investigate\",\n                    required=True,\n                ),\n                PromptArgument(\n                    name=\"scope\",\n                    description=\"Investigation scope (basic, comprehensive, deep)\",\n                    required=False,\n                ),\n            ],\n        ),\n    ]\n\n\n@server.get_prompt()\nasync def handle_get_prompt(name: str, arguments: dict[str, str]) -> list[PromptMessage]:\n    \"\"\"Generate prompt content based on the request.\"\"\"\n    if name == \"security_analysis\":\n        target = arguments.get(\"target\", \"\")\n        analysis_type = arguments.get(\"analysis_type\", \"comprehensive\")\n        \n        content = f\"\"\"# Security Analysis for {target}\n\n## Analysis Objective\nPerform a {analysis_type} security analysis of the target: {target}\n\n## Recommended Investigation Steps\n\n1. **Dark Web Intelligence**\n   - Search for mentions of {target} in dark web sources\n   - Look for potential threats, discussions, or planned attacks\n\n2. **Credential Exposure Check**\n   - Search for leaked credentials associated with {target}\n   - Identify potential account compromises\n\n3. **Ransomware Monitoring**\n   - Check if {target} appears in ransomware victim lists\n   - Monitor for ransomware group discussions\n\n4. **Compromised Data Analysis**\n   - Search for {target} in compromised datasets\n   - Identify data breach exposures\n\n## Analysis Commands\nUse the following StealthMole tools to gather intelligence:\n\n```\nsearch_darkweb(indicator=\"domain\", text=\"{target}\")\nsearch_credentials(indicator=\"domain:{target}\")\nsearch_ransomware(indicator=\"domain:{target}\")\nsearch_compromised_dataset(indicator=\"{target}\")\n```\n\n## Report Structure\nPlease structure your findings as:\n1. Executive Summary\n2. Threat Intelligence Findings\n3. Credential Exposure Assessment\n4. Data Breach Impact\n5. Recommendations\n\"\"\"\n        \n        return [\n            PromptMessage(\n                role=\"user\",\n                content=TextContent(type=\"text\", text=content),\n            )\n        ]\n    \n    elif name == \"threat_investigation\":\n        indicator = arguments.get(\"indicator\", \"\")\n        scope = arguments.get(\"scope\", \"comprehensive\")\n        \n        content = f\"\"\"# Threat Investigation: {indicator}\n\n## Investigation Scope: {scope.upper()}\n\n### Target Information\n- **Indicator**: {indicator}\n- **Investigation Date**: {{current_date}}\n- **Scope Level**: {scope}\n\n### Investigation Methodology\n\n#### Phase 1: Initial Intelligence Gathering\n- Search dark web sources for threat intelligence\n- Check Telegram channels for discussions\n- Review government and enterprise monitoring feeds\n\n#### Phase 2: Exposure Assessment\n- Credential compromise analysis\n- Data breach involvement\n- Ransomware victim verification\n\n#### Phase 3: Advanced Analysis\n- Node detail examination\n- File downloads (if applicable)\n- Cross-reference with known threat actors\n\n### Recommended Tool Sequence\n\n1. **Multi-source Search**\n```\nsearch_darkweb(indicator=\"keyword\", text=\"{indicator}\")\nsearch_telegram(indicator=\"keyword\", text=\"{indicator}\")\nsearch_government_monitoring(indicator=\"id:{indicator}\")\nsearch_leaked_monitoring(indicator=\"id:{indicator}\")\n```\n\n2. **Credential and Data Analysis**\n```\nsearch_credentials(indicator=\"{indicator}\")\nsearch_compromised_dataset(indicator=\"{indicator}\")\nsearch_ransomware(indicator=\"{indicator}\")\n```\n\n3. **Detailed Investigation** (if nodes found)\n```\nget_node_details(service=\"dt\", node_id=\"<found_node_id>\")\nget_targets(service=\"dt\", indicator=\"keyword\")\n```\n\n### Output Requirements\n- Comprehensive threat profile\n- Risk assessment\n- Actionable recommendations\n- Technical indicators for monitoring\n\"\"\"\n        \n        return [\n            PromptMessage(\n                role=\"user\",\n                content=TextContent(type=\"text\", text=content),\n            )\n        ]\n    \n    else:\n        raise ValueError(f\"Unknown prompt: {name}\")"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":341,"cache_read_input_tokens":26564,"output_tokens":25,"service_tier":"standard"}},"requestId":"req_011CR8AhHsjs2abH5znRmovr","type":"assistant","uuid":"030b489d-0414-4c7c-bb41-c0bc0bbac3d3","timestamp":"2025-07-15T04:24:38.220Z"}
{"parentUuid":"030b489d-0414-4c7c-bb41-c0bc0bbac3d3","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"e1862b0a-edaf-4305-96cf-2297be889bda","version":"1.0.51","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018WeMxmb69Jn3ZbzEjikvh3","type":"tool_result","content":"The file /Users/realsun/data/git/mole-mcp-server/src/server.py has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n    32→    \"\"\"List available resources.\"\"\"\n    33→    return []\n    34→\n    35→\n    36→@server.read_resource()\n    37→async def handle_read_resource(uri: AnyUrl) -> str:\n    38→    \"\"\"Read a specific resource.\"\"\"\n    39→    raise ValueError(f\"Unknown resource: {uri}\")\n    40→\n    41→\n    42→@server.list_prompts()\n    43→async def handle_list_prompts() -> list[Prompt]:\n    44→    \"\"\"List available prompts.\"\"\"\n    45→    return [\n    46→        Prompt(\n    47→            name=\"security_analysis\",\n    48→            description=\"Analyze security threats using StealthMole data\",\n    49→            arguments=[\n    50→                PromptArgument(\n    51→                    name=\"target\",\n    52→                    description=\"Target to analyze (domain, IP, email, etc.)\",\n    53→                    required=True,\n    54→                ),\n    55→                PromptArgument(\n    56→                    name=\"analysis_type\",\n    57→                    description=\"Type of analysis (threat_intelligence, credential_exposure, ransomware_monitoring)\",\n    58→                    required=False,\n    59→                ),\n    60→            ],\n    61→        ),\n    62→        Prompt(\n    63→            name=\"threat_investigation\",\n    64→            description=\"Comprehensive threat investigation workflow\",\n    65→            arguments=[\n    66→                PromptArgument(\n    67→                    name=\"indicator\",\n    68→                    description=\"Threat indicator to investigate\",\n    69→                    required=True,\n    70→                ),\n    71→                PromptArgument(\n    72→                    name=\"scope\",\n    73→                    description=\"Investigation scope (basic, comprehensive, deep)\",\n    74→                    required=False,\n    75→                ),\n    76→            ],\n    77→        ),\n    78→    ]\n    79→\n    80→\n    81→@server.get_prompt()\n    82→async def handle_get_prompt(name: str, arguments: dict[str, str]) -> list[PromptMessage]:\n    83→    \"\"\"Generate prompt content based on the request.\"\"\"\n    84→    if name == \"security_analysis\":\n    85→        target = arguments.get(\"target\", \"\")\n    86→        analysis_type = arguments.get(\"analysis_type\", \"comprehensive\")\n    87→        \n    88→        content = f\"\"\"# Security Analysis for {target}\n    89→\n    90→## Analysis Objective\n    91→Perform a {analysis_type} security analysis of the target: {target}\n    92→\n    93→## Recommended Investigation Steps\n    94→\n    95→1. **Dark Web Intelligence**\n    96→   - Search for mentions of {target} in dark web sources\n    97→   - Look for potential threats, discussions, or planned attacks\n    98→\n    99→2. **Credential Exposure Check**\n   100→   - Search for leaked credentials associated with {target}\n   101→   - Identify potential account compromises\n   102→\n   103→3. **Ransomware Monitoring**\n   104→   - Check if {target} appears in ransomware victim lists\n   105→   - Monitor for ransomware group discussions\n   106→\n   107→4. **Compromised Data Analysis**\n   108→   - Search for {target} in compromised datasets\n   109→   - Identify data breach exposures\n   110→\n   111→## Analysis Commands\n   112→Use the following StealthMole tools to gather intelligence:\n   113→\n   114→```\n   115→search_darkweb(indicator=\"domain\", text=\"{target}\")\n   116→search_credentials(indicator=\"domain:{target}\")\n   117→search_ransomware(indicator=\"domain:{target}\")\n   118→search_compromised_dataset(indicator=\"{target}\")\n   119→```\n   120→\n   121→## Report Structure\n   122→Please structure your findings as:\n   123→1. Executive Summary\n   124→2. Threat Intelligence Findings\n   125→3. Credential Exposure Assessment\n   126→4. Data Breach Impact\n   127→5. Recommendations\n   128→\"\"\"\n   129→        \n   130→        return [\n   131→            PromptMessage(\n   132→                role=\"user\",\n   133→                content=TextContent(type=\"text\", text=content),\n   134→            )\n   135→        ]\n   136→    \n   137→    elif name == \"threat_investigation\":\n   138→        indicator = arguments.get(\"indicator\", \"\")\n   139→        scope = arguments.get(\"scope\", \"comprehensive\")\n   140→        \n   141→        content = f\"\"\"# Threat Investigation: {indicator}\n   142→\n   143→## Investigation Scope: {scope.upper()}\n   144→\n   145→### Target Information\n   146→- **Indicator**: {indicator}\n   147→- **Investigation Date**: {{current_date}}\n   148→- **Scope Level**: {scope}\n   149→\n   150→### Investigation Methodology\n   151→\n   152→#### Phase 1: Initial Intelligence Gathering\n   153→- Search dark web sources for threat intelligence\n   154→- Check Telegram channels for discussions\n   155→- Review government and enterprise monitoring feeds\n   156→\n   157→#### Phase 2: Exposure Assessment\n   158→- Credential compromise analysis\n   159→- Data breach involvement\n   160→- Ransomware victim verification\n   161→\n   162→#### Phase 3: Advanced Analysis\n   163→- Node detail examination\n   164→- File downloads (if applicable)\n   165→- Cross-reference with known threat actors\n   166→\n   167→### Recommended Tool Sequence\n   168→\n   169→1. **Multi-source Search**\n   170→```\n   171→search_darkweb(indicator=\"keyword\", text=\"{indicator}\")\n   172→search_telegram(indicator=\"keyword\", text=\"{indicator}\")\n   173→search_government_monitoring(indicator=\"id:{indicator}\")\n   174→search_leaked_monitoring(indicator=\"id:{indicator}\")\n   175→```\n   176→\n   177→2. **Credential and Data Analysis**\n   178→```\n   179→search_credentials(indicator=\"{indicator}\")\n   180→search_compromised_dataset(indicator=\"{indicator}\")\n   181→search_ransomware(indicator=\"{indicator}\")\n   182→```\n   183→\n   184→3. **Detailed Investigation** (if nodes found)\n   185→```\n   186→get_node_details(service=\"dt\", node_id=\"<found_node_id>\")\n   187→get_targets(service=\"dt\", indicator=\"keyword\")\n   188→```\n   189→\n   190→### Output Requirements\n   191→- Comprehensive threat profile\n   192→- Risk assessment\n   193→- Actionable recommendations\n   194→- Technical indicators for monitoring\n   195→\"\"\"\n   196→        \n   197→        return [\n   198→            PromptMessage(\n   199→                role=\"user\",\n   200→                content=TextContent(type=\"text\", text=content),\n   201→            )\n   202→        ]\n   203→    \n   204→    else:\n   205→        raise ValueError(f\"Unknown prompt: {name}\")\n   206→\n   207→\n   208→@server.list_tools()\n   209→async def handle_list_tools() -> list[Tool]:"}]},"uuid":"629231b8-082a-4d00-948c-66f87185ae0e","timestamp":"2025-07-15T04:24:40.906Z","toolUseResult":{"filePath":"/Users/realsun/data/git/mole-mcp-server/src/server.py","oldString":"@server.read_resource()\nasync def handle_read_resource(uri: AnyUrl) -> str:\n    \"\"\"Read a specific resource.\"\"\"\n    raise ValueError(f\"Unknown resource: {uri}\")","newString":"@server.read_resource()\nasync def handle_read_resource(uri: AnyUrl) -> str:\n    \"\"\"Read a specific resource.\"\"\"\n    raise ValueError(f\"Unknown resource: {uri}\")\n\n\n@server.list_prompts()\nasync def handle_list_prompts() -> list[Prompt]:\n    \"\"\"List available prompts.\"\"\"\n    return [\n        Prompt(\n            name=\"security_analysis\",\n            description=\"Analyze security threats using StealthMole data\",\n            arguments=[\n                PromptArgument(\n                    name=\"target\",\n                    description=\"Target to analyze (domain, IP, email, etc.)\",\n                    required=True,\n                ),\n                PromptArgument(\n                    name=\"analysis_type\",\n                    description=\"Type of analysis (threat_intelligence, credential_exposure, ransomware_monitoring)\",\n                    required=False,\n                ),\n            ],\n        ),\n        Prompt(\n            name=\"threat_investigation\",\n            description=\"Comprehensive threat investigation workflow\",\n            arguments=[\n                PromptArgument(\n                    name=\"indicator\",\n                    description=\"Threat indicator to investigate\",\n                    required=True,\n                ),\n                PromptArgument(\n                    name=\"scope\",\n                    description=\"Investigation scope (basic, comprehensive, deep)\",\n                    required=False,\n                ),\n            ],\n        ),\n    ]\n\n\n@server.get_prompt()\nasync def handle_get_prompt(name: str, arguments: dict[str, str]) -> list[PromptMessage]:\n    \"\"\"Generate prompt content based on the request.\"\"\"\n    if name == \"security_analysis\":\n        target = arguments.get(\"target\", \"\")\n        analysis_type = arguments.get(\"analysis_type\", \"comprehensive\")\n        \n        content = f\"\"\"# Security Analysis for {target}\n\n## Analysis Objective\nPerform a {analysis_type} security analysis of the target: {target}\n\n## Recommended Investigation Steps\n\n1. **Dark Web Intelligence**\n   - Search for mentions of {target} in dark web sources\n   - Look for potential threats, discussions, or planned attacks\n\n2. **Credential Exposure Check**\n   - Search for leaked credentials associated with {target}\n   - Identify potential account compromises\n\n3. **Ransomware Monitoring**\n   - Check if {target} appears in ransomware victim lists\n   - Monitor for ransomware group discussions\n\n4. **Compromised Data Analysis**\n   - Search for {target} in compromised datasets\n   - Identify data breach exposures\n\n## Analysis Commands\nUse the following StealthMole tools to gather intelligence:\n\n```\nsearch_darkweb(indicator=\"domain\", text=\"{target}\")\nsearch_credentials(indicator=\"domain:{target}\")\nsearch_ransomware(indicator=\"domain:{target}\")\nsearch_compromised_dataset(indicator=\"{target}\")\n```\n\n## Report Structure\nPlease structure your findings as:\n1. Executive Summary\n2. Threat Intelligence Findings\n3. Credential Exposure Assessment\n4. Data Breach Impact\n5. Recommendations\n\"\"\"\n        \n        return [\n            PromptMessage(\n                role=\"user\",\n                content=TextContent(type=\"text\", text=content),\n            )\n        ]\n    \n    elif name == \"threat_investigation\":\n        indicator = arguments.get(\"indicator\", \"\")\n        scope = arguments.get(\"scope\", \"comprehensive\")\n        \n        content = f\"\"\"# Threat Investigation: {indicator}\n\n## Investigation Scope: {scope.upper()}\n\n### Target Information\n- **Indicator**: {indicator}\n- **Investigation Date**: {{current_date}}\n- **Scope Level**: {scope}\n\n### Investigation Methodology\n\n#### Phase 1: Initial Intelligence Gathering\n- Search dark web sources for threat intelligence\n- Check Telegram channels for discussions\n- Review government and enterprise monitoring feeds\n\n#### Phase 2: Exposure Assessment\n- Credential compromise analysis\n- Data breach involvement\n- Ransomware victim verification\n\n#### Phase 3: Advanced Analysis\n- Node detail examination\n- File downloads (if applicable)\n- Cross-reference with known threat actors\n\n### Recommended Tool Sequence\n\n1. **Multi-source Search**\n```\nsearch_darkweb(indicator=\"keyword\", text=\"{indicator}\")\nsearch_telegram(indicator=\"keyword\", text=\"{indicator}\")\nsearch_government_monitoring(indicator=\"id:{indicator}\")\nsearch_leaked_monitoring(indicator=\"id:{indicator}\")\n```\n\n2. **Credential and Data Analysis**\n```\nsearch_credentials(indicator=\"{indicator}\")\nsearch_compromised_dataset(indicator=\"{indicator}\")\nsearch_ransomware(indicator=\"{indicator}\")\n```\n\n3. **Detailed Investigation** (if nodes found)\n```\nget_node_details(service=\"dt\", node_id=\"<found_node_id>\")\nget_targets(service=\"dt\", indicator=\"keyword\")\n```\n\n### Output Requirements\n- Comprehensive threat profile\n- Risk assessment\n- Actionable recommendations\n- Technical indicators for monitoring\n\"\"\"\n        \n        return [\n            PromptMessage(\n                role=\"user\",\n                content=TextContent(type=\"text\", text=content),\n            )\n        ]\n    \n    else:\n        raise ValueError(f\"Unknown prompt: {name}\")","originalFile":"\"\"\"StealthMole MCP Server implementation.\"\"\"\n\nimport asyncio\nimport os\nimport sys\nfrom typing import Any, Optional, Sequence\n\nfrom dotenv import load_dotenv\nfrom mcp.server import NotificationOptions, Server\nfrom mcp.server.models import InitializationOptions\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import Prompt, PromptArgument, PromptMessage, Resource, TextContent, Tool\nfrom pydantic import AnyUrl\n\nfrom src.tools import *\nfrom src.utils.client import StealthMoleClient\nfrom src.utils.config import StealthMoleConfig\n\nload_dotenv()\n\n# Global client instance\nclient: Optional[StealthMoleClient] = None\n\nserver: Server = Server(\n    \"stealthmole-mcp\",\n    \"0.2.0\",\n)\n\n\n@server.list_resources()\nasync def handle_list_resources() -> list[Resource]:\n    \"\"\"List available resources.\"\"\"\n    return []\n\n\n@server.read_resource()\nasync def handle_read_resource(uri: AnyUrl) -> str:\n    \"\"\"Read a specific resource.\"\"\"\n    raise ValueError(f\"Unknown resource: {uri}\")\n\n\n@server.list_tools()\nasync def handle_list_tools() -> list[Tool]:\n    \"\"\"List available StealthMole tools.\"\"\"\n    try:\n        print(\"Returning StealthMole tools list\", file=sys.stderr)\n        return [\n            Tool(\n                name=\"search_darkweb\",\n                description=\"Search dark web content for indicators like domains, IPs, emails, etc.\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type to search for\",\n                            \"enum\": [\n                                \"adsense\",\n                                \"analyticsid\",\n                                \"band\",\n                                \"bitcoin\",\n                                \"blueprint\",\n                                \"creditcard\",\n                                \"cve\",\n                                \"discord\",\n                                \"document\",\n                                \"domain\",\n                                \"email\",\n                                \"ethereum\",\n                                \"exefile\",\n                                \"facebook\",\n                                \"filehosting\",\n                                \"googledrive\",\n                                \"gps\",\n                                \"hash\",\n                                \"hashstring\",\n                                \"i2p\",\n                                \"i2purl\",\n                                \"id\",\n                                \"image\",\n                                \"instagram\",\n                                \"ioc\",\n                                \"ip\",\n                                \"kakaotalk\",\n                                \"keyword\",\n                                \"kssn\",\n                                \"leakedaudio\",\n                                \"leakedemailfile\",\n                                \"leakedvideo\",\n                                \"line\",\n                                \"linkedin\",\n                                \"malware\",\n                                \"monero\",\n                                \"otherfile\",\n                                \"pastebin\",\n                                \"pgp\",\n                                \"serverstatus\",\n                                \"session\",\n                                \"shorten\",\n                                \"sshkey\",\n                                \"sslkey\",\n                                \"tel\",\n                                \"telegram\",\n                                \"tor\",\n                                \"torurl\",\n                                \"twitter\",\n                                \"url\",\n                            ],\n                        },\n                        \"text\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search keyword or data to find. Supports AND, OR, NOT operators (max 3 OR, 5 total operators)\",\n                        },\n                        \"target\": {\n                            \"type\": \"string\",\n                            \"description\": \"Target type to search (default: 'all'). Use comma-separated values for multiple targets\",\n                            \"default\": \"all\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Ordering type\",\n                            \"enum\": [\"createDate\", \"value\"],\n                            \"default\": \"createDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\", \"text\"],\n                },\n            ),\n            Tool(\n                name=\"search_telegram\",\n                description=\"Search Telegram content for indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type to search for\",\n                            \"enum\": [\n                                \"band\",\n                                \"bitcoin\",\n                                \"creditcard\",\n                                \"cve\",\n                                \"discord\",\n                                \"document\",\n                                \"domain\",\n                                \"email\",\n                                \"ethereum\",\n                                \"exefile\",\n                                \"facebook\",\n                                \"filehosting\",\n                                \"googledrive\",\n                                \"gps\",\n                                \"hash\",\n                                \"hashstring\",\n                                \"i2p\",\n                                \"i2purl\",\n                                \"id\",\n                                \"image\",\n                                \"instagram\",\n                                \"ip\",\n                                \"kakaotalk\",\n                                \"keyword\",\n                                \"kssn\",\n                                \"line\",\n                                \"monero\",\n                                \"otherfile\",\n                                \"pastebin\",\n                                \"pgp\",\n                                \"tel\",\n                                \"session\",\n                                \"shorten\",\n                                \"telegram\",\n                                \"telegram.channel\",\n                                \"telegram.message\",\n                                \"telegram.user\",\n                                \"tor\",\n                                \"torurl\",\n                                \"tox\",\n                                \"twitter\",\n                                \"url\",\n                            ],\n                        },\n                        \"text\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search keyword or data to find. Supports AND, OR, NOT operators (max 3 OR, 5 total operators)\",\n                        },\n                        \"target\": {\n                            \"type\": \"string\",\n                            \"description\": \"Target type to search (default: 'all'). Use comma-separated values for multiple targets\",\n                            \"default\": \"all\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Ordering type\",\n                            \"enum\": [\"createDate\", \"value\"],\n                            \"default\": \"createDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\", \"text\"],\n                },\n            ),\n            Tool(\n                name=\"search_credentials\",\n                description=\"Search for leaked credentials using keywords or specific indicators (domain:, email:, id:, password:, after:, before:)\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - can use indicators like 'domain:example.com', 'email:user@domain.com', 'id:username', 'password:pass123', 'after:2023-01', 'before:2024-01' or plain keywords\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\n                                \"leakedDate\",\n                                \"domain\",\n                                \"email\",\n                                \"password\",\n                                \"leakedFrom\",\n                            ],\n                            \"default\": \"leakedDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                        \"start\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Filter data added to the system after start time (UTC timestamp)\",\n                        },\n                        \"end\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Filter data added to the system before end time (UTC timestamp)\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_ransomware\",\n                description=\"Search ransomware monitoring data using torurl: or domain: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'torurl:site.onion' to search ransomware sites or 'domain:victim.com' to search victim websites. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"victim\", \"attackGroup\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"get_node_details\",\n                description=\"Get detailed information about a specific node\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"node_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Node ID to get details for\",\n                        },\n                        \"pid\": {\n                            \"type\": \"string\",\n                            \"description\": \"Parent node ID (optional)\",\n                        },\n                        \"data_from\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Import data source list (default: False)\",\n                            \"default\": False,\n                        },\n                        \"include_url\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Import included URL list (default: False)\",\n                            \"default\": False,\n                        },\n                        \"include_contents\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Include HTML source contents for torurl, i2purl, url (default: True)\",\n                            \"default\": True,\n                        },\n                    },\n                    \"required\": [\"service\", \"node_id\"],\n                },\n            ),\n            Tool(\n                name=\"get_targets\",\n                description=\"Get available search targets for a service and indicator\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type\",\n                        },\n                    },\n                    \"required\": [\"service\", \"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_data\",\n                description=\"Export search results in specified format\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"service\", \"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_compromised_dataset\",\n                description=\"Search compromised data set information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_compromised_dataset\",\n                description=\"Export compromised data set as CSV/JSON\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"get_compromised_dataset_node\",\n                description=\"Get detailed compromised data set node information (Cyber Security Edition required)\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"node_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Node ID to get details for\",\n                        }\n                    },\n                    \"required\": [\"node_id\"],\n                },\n            ),\n            Tool(\n                name=\"search_combo_binder\",\n                description=\"Search leaked ID/Password combo information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_combo_binder\",\n                description=\"Export combo binder data as CSV/JSON\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_ulp_binder\",\n                description=\"Search URL-Login-Password combination information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_ulp_binder\",\n                description=\"Export ULP binder data as CSV/JSON\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_government_monitoring\",\n                description=\"Search government sector threat monitoring data using url: or id: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'url:hackersite.com' to search threat event URLs or 'id:hacker123' to search actor IDs. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"title\", \"author\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_leaked_monitoring\",\n                description=\"Search enterprise sector threat monitoring data using url: or id: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'url:hackersite.com' to search threat event URLs or 'id:hacker123' to search actor IDs. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"title\", \"author\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"download_file\",\n                description=\"Download file by hash from dt or tt service\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt or tt)\",\n                            \"enum\": [\"dt\", \"tt\"],\n                        },\n                        \"file_hash\": {\n                            \"type\": \"string\",\n                            \"description\": \"File hash to download\",\n                        },\n                    },\n                    \"required\": [\"service\", \"file_hash\"],\n                },\n            ),\n            Tool(\n                name=\"search_pagination\",\n                description=\"Pagination search using search ID for dt or tt service\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt or tt)\",\n                            \"enum\": [\"dt\", \"tt\"],\n                        },\n                        \"search_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search ID from previous search\",\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"service\", \"search_id\"],\n                },\n            ),\n            Tool(\n                name=\"get_user_quotas\",\n                description=\"Get API usage quotas by service\",\n                inputSchema={\"type\": \"object\", \"properties\": {}, \"required\": []},\n            ),\n        ]\n    except Exception as e:\n        print(f\"Error in handle_list_tools: {e}\", file=sys.stderr)\n        import traceback\n\n        traceback.print_exc(file=sys.stderr)\n        return []\n\n\n@server.call_tool()\nasync def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:\n    \"\"\"Handle tool calls.\"\"\"\n    global client\n\n    if client is None:\n        return [\n            TextContent(\n                type=\"text\",\n                text=\"Error: StealthMole client not initialized. Please check your API credentials.\",\n            )\n        ]\n\n    try:\n        if name == \"search_darkweb\":\n            result = await client.search_darkweb(\n                indicator=arguments[\"indicator\"],\n                text=arguments[\"text\"],\n                target=arguments.get(\"target\", \"all\"),\n                limit=arguments.get(\"limit\", 50),\n                orderType=arguments.get(\"orderType\", \"createDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_telegram\":\n            result = await client.search_telegram(\n                indicator=arguments[\"indicator\"],\n                text=arguments[\"text\"],\n                target=arguments.get(\"target\", \"all\"),\n                limit=arguments.get(\"limit\", 50),\n                orderType=arguments.get(\"orderType\", \"createDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_credentials\":\n            result = await client.search_credentials(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"leakedDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n                start=arguments.get(\"start\"),\n                end=arguments.get(\"end\"),\n            )\n        elif name == \"search_ransomware\":\n            result = await client.search_ransomware(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"get_node_details\":\n            result = await client.get_node_details(\n                service=arguments[\"service\"],\n                node_id=arguments[\"node_id\"],\n                pid=arguments.get(\"pid\"),\n                data_from=arguments.get(\"data_from\", False),\n                include_url=arguments.get(\"include_url\", False),\n                include_contents=arguments.get(\"include_contents\", True),\n            )\n        elif name == \"get_targets\":\n            result = await client.get_targets(\n                service=arguments[\"service\"], indicator=arguments[\"indicator\"]\n            )\n        elif name == \"export_data\":\n            result = await client.export_data(\n                service=arguments[\"service\"],\n                indicator=arguments[\"indicator\"],\n                format=arguments.get(\"format\", \"json\"),\n            )\n        elif name == \"search_compromised_dataset\":\n            result = await client.search_compromised_dataset(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"export_compromised_dataset\":\n            result = await client.export_compromised_dataset(\n                indicator=arguments[\"indicator\"], format=arguments.get(\"format\", \"json\")\n            )\n        elif name == \"get_compromised_dataset_node\":\n            result = await client.get_compromised_dataset_node(\n                node_id=arguments[\"node_id\"]\n            )\n        elif name == \"search_combo_binder\":\n            result = await client.search_combo_binder(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"export_combo_binder\":\n            result = await client.export_combo_binder(\n                indicator=arguments[\"indicator\"], format=arguments.get(\"format\", \"json\")\n            )\n        elif name == \"search_ulp_binder\":\n            result = await client.search_ulp_binder(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"export_ulp_binder\":\n            result = await client.export_ulp_binder(\n                indicator=arguments[\"indicator\"], format=arguments.get(\"format\", \"json\")\n            )\n        elif name == \"search_government_monitoring\":\n            result = await client.search_government_monitoring(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_leaked_monitoring\":\n            result = await client.search_leaked_monitoring(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"download_file\":\n            file_content = await client.download_file(\n                service=arguments[\"service\"], file_hash=arguments[\"file_hash\"]\n            )\n            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"Downloaded file {arguments['file_hash']} from {arguments['service']} service. File size: {len(file_content)} bytes\",\n                )\n            ]\n        elif name == \"search_pagination\":\n            result = await client.search_pagination(\n                service=arguments[\"service\"],\n                search_id=arguments[\"search_id\"],\n                cursor=arguments.get(\"cursor\", 0),\n                limit=arguments.get(\"limit\", 50),\n            )\n        elif name == \"get_user_quotas\":\n            result = await client.get_user_quotas()\n        else:\n            return [TextContent(type=\"text\", text=f\"Unknown tool: {name}\")]\n\n        return [TextContent(type=\"text\", text=f\"StealthMole API Results:\\n\\n{result}\")]\n\n    except asyncio.TimeoutError:\n        return [\n            TextContent(\n                type=\"text\",\n                text=\"Request timed out. The API request took too long to complete.\",\n            )\n        ]\n    except Exception as e:\n        error_msg = str(e)\n        if \"timeout\" in error_msg.lower():\n            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"Timeout error: {error_msg}. Try reducing the result limit or check your network connection.\",\n                )\n            ]\n        return [\n            TextContent(type=\"text\", text=f\"Error calling StealthMole API: {error_msg}\")\n        ]\n\n\nasync def run_server():\n    \"\"\"Run the MCP server.\"\"\"\n    global client\n\n    try:\n        print(\"Starting StealthMole MCP server...\", file=sys.stderr)\n\n        # Initialize StealthMole client\n        access_key = os.getenv(\"STEALTHMOLE_ACCESS_KEY\")\n        secret_key = os.getenv(\"STEALTHMOLE_SECRET_KEY\")\n\n        print(f\"Access key: {'SET' if access_key else 'NOT SET'}\", file=sys.stderr)\n        print(f\"Secret key: {'SET' if secret_key else 'NOT SET'}\", file=sys.stderr)\n\n        if not access_key or not secret_key:\n            print(\n                \"Warning: STEALTHMOLE_ACCESS_KEY and STEALTHMOLE_SECRET_KEY environment variables not set\",\n                file=sys.stderr,\n            )\n            print(\"MCP server will start but tools will not function\", file=sys.stderr)\n        else:\n            try:\n                config = StealthMoleConfig(access_key=access_key, secret_key=secret_key)\n                print(\"StealthMole config created\", file=sys.stderr)\n                client = StealthMoleClient(config)\n                print(\"StealthMole client initialized\", file=sys.stderr)\n\n                # API 연결 테스트 (타임아웃 없이 간단히)\n                try:\n                    quotas = await client.get_user_quotas()\n                    print(\n                        f\"✓ API connection successful. Available quotas: {quotas}\",\n                        file=sys.stderr,\n                    )\n                except Exception as api_error:\n                    print(f\"Warning: API test failed: {api_error}\", file=sys.stderr)\n                    print(\"Continuing with server startup...\", file=sys.stderr)\n\n            except Exception as e:\n                print(\n                    f\"Warning: Error creating StealthMole client: {e}\", file=sys.stderr\n                )\n                print(\n                    \"MCP server will start but tools may not function properly\",\n                    file=sys.stderr,\n                )\n                import traceback\n\n                traceback.print_exc(file=sys.stderr)\n\n        print(\"Creating stdio server...\", file=sys.stderr)\n        async with stdio_server() as (read_stream, write_stream):\n            print(\"Starting MCP server...\", file=sys.stderr)\n            try:\n                await server.run(\n                    read_stream,\n                    write_stream,\n                    InitializationOptions(\n                        server_name=\"stealthmole-mcp\",\n                        server_version=\"0.1.0\",\n                        capabilities=server.get_capabilities(\n                            notification_options=NotificationOptions(),\n                            experimental_capabilities={},\n                        ),\n                    ),\n                )\n                print(\"MCP server completed normally\", file=sys.stderr)\n            except Exception as e:\n                print(f\"Error in MCP server.run: {e}\", file=sys.stderr)\n                import traceback\n\n                traceback.print_exc(file=sys.stderr)\n                raise\n    except Exception as e:\n        print(f\"Error in run_server: {e}\", file=sys.stderr)\n        import traceback\n\n        traceback.print_exc(file=sys.stderr)\n\n\ndef main():\n    \"\"\"Main entry point for the MCP server.\"\"\"\n    asyncio.run(run_server())\n\n\nif __name__ == \"__main__\":\n    main()\n","structuredPatch":[{"oldStart":39,"oldLines":6,"newStart":39,"newLines":172,"lines":["     raise ValueError(f\"Unknown resource: {uri}\")"," "," ","+@server.list_prompts()","+async def handle_list_prompts() -> list[Prompt]:","+    \"\"\"List available prompts.\"\"\"","+    return [","+        Prompt(","+            name=\"security_analysis\",","+            description=\"Analyze security threats using StealthMole data\",","+            arguments=[","+                PromptArgument(","+                    name=\"target\",","+                    description=\"Target to analyze (domain, IP, email, etc.)\",","+                    required=True,","+                ),","+                PromptArgument(","+                    name=\"analysis_type\",","+                    description=\"Type of analysis (threat_intelligence, credential_exposure, ransomware_monitoring)\",","+                    required=False,","+                ),","+            ],","+        ),","+        Prompt(","+            name=\"threat_investigation\",","+            description=\"Comprehensive threat investigation workflow\",","+            arguments=[","+                PromptArgument(","+                    name=\"indicator\",","+                    description=\"Threat indicator to investigate\",","+                    required=True,","+                ),","+                PromptArgument(","+                    name=\"scope\",","+                    description=\"Investigation scope (basic, comprehensive, deep)\",","+                    required=False,","+                ),","+            ],","+        ),","+    ]","+","+","+@server.get_prompt()","+async def handle_get_prompt(name: str, arguments: dict[str, str]) -> list[PromptMessage]:","+    \"\"\"Generate prompt content based on the request.\"\"\"","+    if name == \"security_analysis\":","+        target = arguments.get(\"target\", \"\")","+        analysis_type = arguments.get(\"analysis_type\", \"comprehensive\")","+        ","+        content = f\"\"\"# Security Analysis for {target}","+","+## Analysis Objective","+Perform a {analysis_type} security analysis of the target: {target}","+","+## Recommended Investigation Steps","+","+1. **Dark Web Intelligence**","+   - Search for mentions of {target} in dark web sources","+   - Look for potential threats, discussions, or planned attacks","+","+2. **Credential Exposure Check**","+   - Search for leaked credentials associated with {target}","+   - Identify potential account compromises","+","+3. **Ransomware Monitoring**","+   - Check if {target} appears in ransomware victim lists","+   - Monitor for ransomware group discussions","+","+4. **Compromised Data Analysis**","+   - Search for {target} in compromised datasets","+   - Identify data breach exposures","+","+## Analysis Commands","+Use the following StealthMole tools to gather intelligence:","+","+```","+search_darkweb(indicator=\"domain\", text=\"{target}\")","+search_credentials(indicator=\"domain:{target}\")","+search_ransomware(indicator=\"domain:{target}\")","+search_compromised_dataset(indicator=\"{target}\")","+```","+","+## Report Structure","+Please structure your findings as:","+1. Executive Summary","+2. Threat Intelligence Findings","+3. Credential Exposure Assessment","+4. Data Breach Impact","+5. Recommendations","+\"\"\"","+        ","+        return [","+            PromptMessage(","+                role=\"user\",","+                content=TextContent(type=\"text\", text=content),","+            )","+        ]","+    ","+    elif name == \"threat_investigation\":","+        indicator = arguments.get(\"indicator\", \"\")","+        scope = arguments.get(\"scope\", \"comprehensive\")","+        ","+        content = f\"\"\"# Threat Investigation: {indicator}","+","+## Investigation Scope: {scope.upper()}","+","+### Target Information","+- **Indicator**: {indicator}","+- **Investigation Date**: {{current_date}}","+- **Scope Level**: {scope}","+","+### Investigation Methodology","+","+#### Phase 1: Initial Intelligence Gathering","+- Search dark web sources for threat intelligence","+- Check Telegram channels for discussions","+- Review government and enterprise monitoring feeds","+","+#### Phase 2: Exposure Assessment","+- Credential compromise analysis","+- Data breach involvement","+- Ransomware victim verification","+","+#### Phase 3: Advanced Analysis","+- Node detail examination","+- File downloads (if applicable)","+- Cross-reference with known threat actors","+","+### Recommended Tool Sequence","+","+1. **Multi-source Search**","+```","+search_darkweb(indicator=\"keyword\", text=\"{indicator}\")","+search_telegram(indicator=\"keyword\", text=\"{indicator}\")","+search_government_monitoring(indicator=\"id:{indicator}\")","+search_leaked_monitoring(indicator=\"id:{indicator}\")","+```","+","+2. **Credential and Data Analysis**","+```","+search_credentials(indicator=\"{indicator}\")","+search_compromised_dataset(indicator=\"{indicator}\")","+search_ransomware(indicator=\"{indicator}\")","+```","+","+3. **Detailed Investigation** (if nodes found)","+```","+get_node_details(service=\"dt\", node_id=\"<found_node_id>\")","+get_targets(service=\"dt\", indicator=\"keyword\")","+```","+","+### Output Requirements","+- Comprehensive threat profile","+- Risk assessment","+- Actionable recommendations","+- Technical indicators for monitoring","+\"\"\"","+        ","+        return [","+            PromptMessage(","+                role=\"user\",","+                content=TextContent(type=\"text\", text=content),","+            )","+        ]","+    ","+    else:","+        raise ValueError(f\"Unknown prompt: {name}\")","+","+"," @server.list_tools()"," async def handle_list_tools() -> list[Tool]:","     \"\"\"List available StealthMole tools.\"\"\""]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"629231b8-082a-4d00-948c-66f87185ae0e","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"e1862b0a-edaf-4305-96cf-2297be889bda","version":"1.0.51","message":{"id":"msg_01QV3ZwMUZyy1x7m5cSiv4KL","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01HeEurNqcQFZ3NFLLeFJVuY","name":"TodoWrite","input":{"todos":[{"id":"1","content":"MCP 서버에 기본 프롬프트 기능 추가","status":"completed","priority":"high"},{"id":"2","content":"프롬프트 핸들러 구현","status":"completed","priority":"medium"},{"id":"3","content":"서버 설정에 기본 프롬프트 추가","status":"completed","priority":"medium"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":3235,"cache_read_input_tokens":26905,"output_tokens":23,"service_tier":"standard"}},"requestId":"req_011CR8AjAZ1WPm2mSgYQgV6k","type":"assistant","uuid":"c7b1e0f0-097c-432e-a656-b8f5e71280a5","timestamp":"2025-07-15T04:24:48.687Z"}
{"parentUuid":"c7b1e0f0-097c-432e-a656-b8f5e71280a5","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"e1862b0a-edaf-4305-96cf-2297be889bda","version":"1.0.51","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HeEurNqcQFZ3NFLLeFJVuY","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"dca4ae7c-6997-491a-922a-940b647b8a5b","timestamp":"2025-07-15T04:24:48.732Z","toolUseResult":{"oldTodos":[{"content":"MCP 서버에 기본 프롬프트 기능 추가","status":"in_progress","priority":"high","id":"1"},{"content":"프롬프트 핸들러 구현","status":"pending","priority":"medium","id":"2"},{"content":"서버 설정에 기본 프롬프트 추가","status":"pending","priority":"medium","id":"3"}],"newTodos":[{"content":"MCP 서버에 기본 프롬프트 기능 추가","status":"completed","priority":"high","id":"1"},{"content":"프롬프트 핸들러 구현","status":"completed","priority":"medium","id":"2"},{"content":"서버 설정에 기본 프롬프트 추가","status":"completed","priority":"medium","id":"3"}]}}
{"parentUuid":"dca4ae7c-6997-491a-922a-940b647b8a5b","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"e1862b0a-edaf-4305-96cf-2297be889bda","version":"1.0.51","message":{"id":"msg_01EvrMekkEQZ1KKLEcCyTWhS","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"네, 서버에 default prompt를 설정했습니다. 두 가지 기본 프롬프트를 추가했습니다:\n\n1. **security_analysis** - 보안 위협 분석용 프롬프트\n2. **threat_investigation** - 종합적인 위협 조사 워크플로우\n\n이제 MCP 클라이언트에서 다음과 같이 사용할 수 있습니다:\n\n- `security_analysis` 프롬프트: 특정 타겟(도메인, IP, 이메일 등)에 대한 보안 분석 가이드\n- `threat_investigation` 프롬프트: 위협 지표에 대한 포괄적인 조사 방법론\n\n클라이언트에서는 프롬프트 목록을 조회하고 필요한 인자(target, analysis_type, indicator, scope 등)를 제공하여 맞춤형 분석 가이드를 받을 수 있습니다."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":478,"cache_read_input_tokens":30140,"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CR8Ajj3ckzc8AZG7fsmyi","type":"assistant","uuid":"e8223120-3f0c-4b9d-9267-672405a3001e","timestamp":"2025-07-15T04:24:56.071Z"}
{"parentUuid":"e8223120-3f0c-4b9d-9267-672405a3001e","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"e1862b0a-edaf-4305-96cf-2297be889bda","version":"1.0.51","type":"user","message":{"role":"user","content":"내가 하고싶은건 서버 초기화할때 프롬프트를 적용하고싶어\n\"\"\"If you don't mention a specific indicator, Neo will default to searching by keyword.\nIf a different indicator is requested, but not explicitly in the form indicator:query, it will say “also search keyword for more information” and proceed. \nAlways set limit to the maximum value.\nWe also ask the user if they want to browse the next page:\"\"\""},"uuid":"b9004d24-f221-49e9-a4bb-b0608d4ac93f","timestamp":"2025-07-15T04:36:26.600Z"}
{"parentUuid":"b9004d24-f221-49e9-a4bb-b0608d4ac93f","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"e1862b0a-edaf-4305-96cf-2297be889bda","version":"1.0.51","message":{"id":"msg_01XzN5d4VHEhHUtADEV2Ld9Y","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"아, 서버 초기화 시 기본 시스템 프롬프트를 설정하고 싶으시는군요. MCP 서버 자체에 기본 동작 방식을 정의하는 프롬프트를 추가하겠습니다."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":31023,"cache_read_input_tokens":0,"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CR8BdAqKza3o6e5P84Y9c","type":"assistant","uuid":"886e254a-6fd8-421c-b411-95296a44e75c","timestamp":"2025-07-15T04:36:30.864Z"}
{"parentUuid":"886e254a-6fd8-421c-b411-95296a44e75c","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"e1862b0a-edaf-4305-96cf-2297be889bda","version":"1.0.51","message":{"id":"msg_01XzN5d4VHEhHUtADEV2Ld9Y","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01XT1CHR3vo5CQTsnjae8HQ1","name":"TodoWrite","input":{"todos":[{"id":"1","content":"서버 초기화 시 기본 시스템 프롬프트 설정","status":"in_progress","priority":"high"},{"id":"2","content":"도구 호출 시 기본 동작 규칙 적용","status":"pending","priority":"medium"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":31023,"cache_read_input_tokens":0,"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CR8BdAqKza3o6e5P84Y9c","type":"assistant","uuid":"dd5a8726-c777-446e-8bf3-84d7fe28c40e","timestamp":"2025-07-15T04:36:32.226Z"}
{"parentUuid":"dd5a8726-c777-446e-8bf3-84d7fe28c40e","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"e1862b0a-edaf-4305-96cf-2297be889bda","version":"1.0.51","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XT1CHR3vo5CQTsnjae8HQ1","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"f8f5293b-1d34-4f70-a813-60a7e3975feb","timestamp":"2025-07-15T04:36:32.367Z","toolUseResult":{"oldTodos":[{"content":"MCP 서버에 기본 프롬프트 기능 추가","status":"completed","priority":"high","id":"1"},{"content":"프롬프트 핸들러 구현","status":"completed","priority":"medium","id":"2"},{"content":"서버 설정에 기본 프롬프트 추가","status":"completed","priority":"medium","id":"3"}],"newTodos":[{"content":"서버 초기화 시 기본 시스템 프롬프트 설정","status":"in_progress","priority":"high","id":"1"},{"content":"도구 호출 시 기본 동작 규칙 적용","status":"pending","priority":"medium","id":"2"}]}}
{"parentUuid":"f8f5293b-1d34-4f70-a813-60a7e3975feb","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"e1862b0a-edaf-4305-96cf-2297be889bda","version":"1.0.51","message":{"id":"msg_01SSTyvHVDwNozjoe8YrEjSn","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_014xNUdsmsSxGzmBDpGCUL72","name":"Edit","input":{"file_path":"/Users/realsun/data/git/mole-mcp-server/src/server.py","old_string":"# Global client instance\nclient: Optional[StealthMoleClient] = None","new_string":"# Global client instance\nclient: Optional[StealthMoleClient] = None\n\n# Default system prompt for Neo behavior\nDEFAULT_SYSTEM_PROMPT = \"\"\"If you don't mention a specific indicator, Neo will default to searching by keyword.\nIf a different indicator is requested, but not explicitly in the form indicator:query, it will say \"also search keyword for more information\" and proceed. \nAlways set limit to the maximum value.\nWe also ask the user if they want to browse the next page:\"\"\""}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":491,"cache_read_input_tokens":31023,"output_tokens":22,"service_tier":"standard"}},"requestId":"req_011CR8BdbNx3Xm2VPAff3cos","type":"assistant","uuid":"f05f1e27-39db-4c49-923b-47257d55b2b3","timestamp":"2025-07-15T04:36:38.222Z"}
{"parentUuid":"f05f1e27-39db-4c49-923b-47257d55b2b3","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"e1862b0a-edaf-4305-96cf-2297be889bda","version":"1.0.51","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014xNUdsmsSxGzmBDpGCUL72","type":"tool_result","content":"The file /Users/realsun/data/git/mole-mcp-server/src/server.py has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n    17→from src.utils.config import StealthMoleConfig\n    18→\n    19→load_dotenv()\n    20→\n    21→# Global client instance\n    22→client: Optional[StealthMoleClient] = None\n    23→\n    24→# Default system prompt for Neo behavior\n    25→DEFAULT_SYSTEM_PROMPT = \"\"\"If you don't mention a specific indicator, Neo will default to searching by keyword.\n    26→If a different indicator is requested, but not explicitly in the form indicator:query, it will say \"also search keyword for more information\" and proceed. \n    27→Always set limit to the maximum value.\n    28→We also ask the user if they want to browse the next page:\"\"\"\n    29→\n    30→server: Server = Server(\n    31→    \"stealthmole-mcp\",\n    32→    \"0.2.0\","}]},"uuid":"40d92f8f-f8f8-4474-9c0e-90f633bdb776","timestamp":"2025-07-15T04:40:31.340Z","toolUseResult":{"filePath":"/Users/realsun/data/git/mole-mcp-server/src/server.py","oldString":"# Global client instance\nclient: Optional[StealthMoleClient] = None","newString":"# Global client instance\nclient: Optional[StealthMoleClient] = None\n\n# Default system prompt for Neo behavior\nDEFAULT_SYSTEM_PROMPT = \"\"\"If you don't mention a specific indicator, Neo will default to searching by keyword.\nIf a different indicator is requested, but not explicitly in the form indicator:query, it will say \"also search keyword for more information\" and proceed. \nAlways set limit to the maximum value.\nWe also ask the user if they want to browse the next page:\"\"\"","originalFile":"\"\"\"StealthMole MCP Server implementation.\"\"\"\n\nimport asyncio\nimport os\nimport sys\nfrom typing import Any, Optional, Sequence\n\nfrom dotenv import load_dotenv\nfrom mcp.server import NotificationOptions, Server\nfrom mcp.server.models import InitializationOptions\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import Prompt, PromptArgument, PromptMessage, Resource, TextContent, Tool\nfrom pydantic import AnyUrl\n\nfrom src.tools import *\nfrom src.utils.client import StealthMoleClient\nfrom src.utils.config import StealthMoleConfig\n\nload_dotenv()\n\n# Global client instance\nclient: Optional[StealthMoleClient] = None\n\nserver: Server = Server(\n    \"stealthmole-mcp\",\n    \"0.2.0\",\n)\n\n\n@server.list_resources()\nasync def handle_list_resources() -> list[Resource]:\n    \"\"\"List available resources.\"\"\"\n    return []\n\n\n@server.read_resource()\nasync def handle_read_resource(uri: AnyUrl) -> str:\n    \"\"\"Read a specific resource.\"\"\"\n    raise ValueError(f\"Unknown resource: {uri}\")\n\n\n@server.list_prompts()\nasync def handle_list_prompts() -> list[Prompt]:\n    \"\"\"List available prompts.\"\"\"\n    return [\n        Prompt(\n            name=\"security_analysis\",\n            description=\"Analyze security threats using StealthMole data\",\n            arguments=[\n                PromptArgument(\n                    name=\"target\",\n                    description=\"Target to analyze (domain, IP, email, etc.)\",\n                    required=True,\n                ),\n                PromptArgument(\n                    name=\"analysis_type\",\n                    description=\"Type of analysis (threat_intelligence, credential_exposure, ransomware_monitoring)\",\n                    required=False,\n                ),\n            ],\n        ),\n        Prompt(\n            name=\"threat_investigation\",\n            description=\"Comprehensive threat investigation workflow\",\n            arguments=[\n                PromptArgument(\n                    name=\"indicator\",\n                    description=\"Threat indicator to investigate\",\n                    required=True,\n                ),\n                PromptArgument(\n                    name=\"scope\",\n                    description=\"Investigation scope (basic, comprehensive, deep)\",\n                    required=False,\n                ),\n            ],\n        ),\n    ]\n\n\n@server.get_prompt()\nasync def handle_get_prompt(name: str, arguments: dict[str, str]) -> list[PromptMessage]:\n    \"\"\"Generate prompt content based on the request.\"\"\"\n    if name == \"security_analysis\":\n        target = arguments.get(\"target\", \"\")\n        analysis_type = arguments.get(\"analysis_type\", \"comprehensive\")\n        \n        content = f\"\"\"# Security Analysis for {target}\n\n## Analysis Objective\nPerform a {analysis_type} security analysis of the target: {target}\n\n## Recommended Investigation Steps\n\n1. **Dark Web Intelligence**\n   - Search for mentions of {target} in dark web sources\n   - Look for potential threats, discussions, or planned attacks\n\n2. **Credential Exposure Check**\n   - Search for leaked credentials associated with {target}\n   - Identify potential account compromises\n\n3. **Ransomware Monitoring**\n   - Check if {target} appears in ransomware victim lists\n   - Monitor for ransomware group discussions\n\n4. **Compromised Data Analysis**\n   - Search for {target} in compromised datasets\n   - Identify data breach exposures\n\n## Analysis Commands\nUse the following StealthMole tools to gather intelligence:\n\n```\nsearch_darkweb(indicator=\"domain\", text=\"{target}\")\nsearch_credentials(indicator=\"domain:{target}\")\nsearch_ransomware(indicator=\"domain:{target}\")\nsearch_compromised_dataset(indicator=\"{target}\")\n```\n\n## Report Structure\nPlease structure your findings as:\n1. Executive Summary\n2. Threat Intelligence Findings\n3. Credential Exposure Assessment\n4. Data Breach Impact\n5. Recommendations\n\"\"\"\n        \n        return [\n            PromptMessage(\n                role=\"user\",\n                content=TextContent(type=\"text\", text=content),\n            )\n        ]\n    \n    elif name == \"threat_investigation\":\n        indicator = arguments.get(\"indicator\", \"\")\n        scope = arguments.get(\"scope\", \"comprehensive\")\n        \n        content = f\"\"\"# Threat Investigation: {indicator}\n\n## Investigation Scope: {scope.upper()}\n\n### Target Information\n- **Indicator**: {indicator}\n- **Investigation Date**: {{current_date}}\n- **Scope Level**: {scope}\n\n### Investigation Methodology\n\n#### Phase 1: Initial Intelligence Gathering\n- Search dark web sources for threat intelligence\n- Check Telegram channels for discussions\n- Review government and enterprise monitoring feeds\n\n#### Phase 2: Exposure Assessment\n- Credential compromise analysis\n- Data breach involvement\n- Ransomware victim verification\n\n#### Phase 3: Advanced Analysis\n- Node detail examination\n- File downloads (if applicable)\n- Cross-reference with known threat actors\n\n### Recommended Tool Sequence\n\n1. **Multi-source Search**\n```\nsearch_darkweb(indicator=\"keyword\", text=\"{indicator}\")\nsearch_telegram(indicator=\"keyword\", text=\"{indicator}\")\nsearch_government_monitoring(indicator=\"id:{indicator}\")\nsearch_leaked_monitoring(indicator=\"id:{indicator}\")\n```\n\n2. **Credential and Data Analysis**\n```\nsearch_credentials(indicator=\"{indicator}\")\nsearch_compromised_dataset(indicator=\"{indicator}\")\nsearch_ransomware(indicator=\"{indicator}\")\n```\n\n3. **Detailed Investigation** (if nodes found)\n```\nget_node_details(service=\"dt\", node_id=\"<found_node_id>\")\nget_targets(service=\"dt\", indicator=\"keyword\")\n```\n\n### Output Requirements\n- Comprehensive threat profile\n- Risk assessment\n- Actionable recommendations\n- Technical indicators for monitoring\n\"\"\"\n        \n        return [\n            PromptMessage(\n                role=\"user\",\n                content=TextContent(type=\"text\", text=content),\n            )\n        ]\n    \n    else:\n        raise ValueError(f\"Unknown prompt: {name}\")\n\n\n@server.list_tools()\nasync def handle_list_tools() -> list[Tool]:\n    \"\"\"List available StealthMole tools.\"\"\"\n    try:\n        print(\"Returning StealthMole tools list\", file=sys.stderr)\n        return [\n            Tool(\n                name=\"search_darkweb\",\n                description=\"Search dark web content for indicators like domains, IPs, emails, etc.\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type to search for\",\n                            \"enum\": [\n                                \"adsense\",\n                                \"analyticsid\",\n                                \"band\",\n                                \"bitcoin\",\n                                \"blueprint\",\n                                \"creditcard\",\n                                \"cve\",\n                                \"discord\",\n                                \"document\",\n                                \"domain\",\n                                \"email\",\n                                \"ethereum\",\n                                \"exefile\",\n                                \"facebook\",\n                                \"filehosting\",\n                                \"googledrive\",\n                                \"gps\",\n                                \"hash\",\n                                \"hashstring\",\n                                \"i2p\",\n                                \"i2purl\",\n                                \"id\",\n                                \"image\",\n                                \"instagram\",\n                                \"ioc\",\n                                \"ip\",\n                                \"kakaotalk\",\n                                \"keyword\",\n                                \"kssn\",\n                                \"leakedaudio\",\n                                \"leakedemailfile\",\n                                \"leakedvideo\",\n                                \"line\",\n                                \"linkedin\",\n                                \"malware\",\n                                \"monero\",\n                                \"otherfile\",\n                                \"pastebin\",\n                                \"pgp\",\n                                \"serverstatus\",\n                                \"session\",\n                                \"shorten\",\n                                \"sshkey\",\n                                \"sslkey\",\n                                \"tel\",\n                                \"telegram\",\n                                \"tor\",\n                                \"torurl\",\n                                \"twitter\",\n                                \"url\",\n                            ],\n                        },\n                        \"text\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search keyword or data to find. Supports AND, OR, NOT operators (max 3 OR, 5 total operators)\",\n                        },\n                        \"target\": {\n                            \"type\": \"string\",\n                            \"description\": \"Target type to search (default: 'all'). Use comma-separated values for multiple targets\",\n                            \"default\": \"all\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Ordering type\",\n                            \"enum\": [\"createDate\", \"value\"],\n                            \"default\": \"createDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\", \"text\"],\n                },\n            ),\n            Tool(\n                name=\"search_telegram\",\n                description=\"Search Telegram content for indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type to search for\",\n                            \"enum\": [\n                                \"band\",\n                                \"bitcoin\",\n                                \"creditcard\",\n                                \"cve\",\n                                \"discord\",\n                                \"document\",\n                                \"domain\",\n                                \"email\",\n                                \"ethereum\",\n                                \"exefile\",\n                                \"facebook\",\n                                \"filehosting\",\n                                \"googledrive\",\n                                \"gps\",\n                                \"hash\",\n                                \"hashstring\",\n                                \"i2p\",\n                                \"i2purl\",\n                                \"id\",\n                                \"image\",\n                                \"instagram\",\n                                \"ip\",\n                                \"kakaotalk\",\n                                \"keyword\",\n                                \"kssn\",\n                                \"line\",\n                                \"monero\",\n                                \"otherfile\",\n                                \"pastebin\",\n                                \"pgp\",\n                                \"tel\",\n                                \"session\",\n                                \"shorten\",\n                                \"telegram\",\n                                \"telegram.channel\",\n                                \"telegram.message\",\n                                \"telegram.user\",\n                                \"tor\",\n                                \"torurl\",\n                                \"tox\",\n                                \"twitter\",\n                                \"url\",\n                            ],\n                        },\n                        \"text\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search keyword or data to find. Supports AND, OR, NOT operators (max 3 OR, 5 total operators)\",\n                        },\n                        \"target\": {\n                            \"type\": \"string\",\n                            \"description\": \"Target type to search (default: 'all'). Use comma-separated values for multiple targets\",\n                            \"default\": \"all\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Ordering type\",\n                            \"enum\": [\"createDate\", \"value\"],\n                            \"default\": \"createDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\", \"text\"],\n                },\n            ),\n            Tool(\n                name=\"search_credentials\",\n                description=\"Search for leaked credentials using keywords or specific indicators (domain:, email:, id:, password:, after:, before:)\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - can use indicators like 'domain:example.com', 'email:user@domain.com', 'id:username', 'password:pass123', 'after:2023-01', 'before:2024-01' or plain keywords\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\n                                \"leakedDate\",\n                                \"domain\",\n                                \"email\",\n                                \"password\",\n                                \"leakedFrom\",\n                            ],\n                            \"default\": \"leakedDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                        \"start\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Filter data added to the system after start time (UTC timestamp)\",\n                        },\n                        \"end\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Filter data added to the system before end time (UTC timestamp)\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_ransomware\",\n                description=\"Search ransomware monitoring data using torurl: or domain: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'torurl:site.onion' to search ransomware sites or 'domain:victim.com' to search victim websites. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"victim\", \"attackGroup\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"get_node_details\",\n                description=\"Get detailed information about a specific node\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"node_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Node ID to get details for\",\n                        },\n                        \"pid\": {\n                            \"type\": \"string\",\n                            \"description\": \"Parent node ID (optional)\",\n                        },\n                        \"data_from\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Import data source list (default: False)\",\n                            \"default\": False,\n                        },\n                        \"include_url\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Import included URL list (default: False)\",\n                            \"default\": False,\n                        },\n                        \"include_contents\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Include HTML source contents for torurl, i2purl, url (default: True)\",\n                            \"default\": True,\n                        },\n                    },\n                    \"required\": [\"service\", \"node_id\"],\n                },\n            ),\n            Tool(\n                name=\"get_targets\",\n                description=\"Get available search targets for a service and indicator\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type\",\n                        },\n                    },\n                    \"required\": [\"service\", \"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_data\",\n                description=\"Export search results in specified format\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"service\", \"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_compromised_dataset\",\n                description=\"Search compromised data set information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_compromised_dataset\",\n                description=\"Export compromised data set as CSV/JSON\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"get_compromised_dataset_node\",\n                description=\"Get detailed compromised data set node information (Cyber Security Edition required)\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"node_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Node ID to get details for\",\n                        }\n                    },\n                    \"required\": [\"node_id\"],\n                },\n            ),\n            Tool(\n                name=\"search_combo_binder\",\n                description=\"Search leaked ID/Password combo information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_combo_binder\",\n                description=\"Export combo binder data as CSV/JSON\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_ulp_binder\",\n                description=\"Search URL-Login-Password combination information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_ulp_binder\",\n                description=\"Export ULP binder data as CSV/JSON\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_government_monitoring\",\n                description=\"Search government sector threat monitoring data using url: or id: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'url:hackersite.com' to search threat event URLs or 'id:hacker123' to search actor IDs. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"title\", \"author\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_leaked_monitoring\",\n                description=\"Search enterprise sector threat monitoring data using url: or id: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'url:hackersite.com' to search threat event URLs or 'id:hacker123' to search actor IDs. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"title\", \"author\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"download_file\",\n                description=\"Download file by hash from dt or tt service\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt or tt)\",\n                            \"enum\": [\"dt\", \"tt\"],\n                        },\n                        \"file_hash\": {\n                            \"type\": \"string\",\n                            \"description\": \"File hash to download\",\n                        },\n                    },\n                    \"required\": [\"service\", \"file_hash\"],\n                },\n            ),\n            Tool(\n                name=\"search_pagination\",\n                description=\"Pagination search using search ID for dt or tt service\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt or tt)\",\n                            \"enum\": [\"dt\", \"tt\"],\n                        },\n                        \"search_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search ID from previous search\",\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"service\", \"search_id\"],\n                },\n            ),\n            Tool(\n                name=\"get_user_quotas\",\n                description=\"Get API usage quotas by service\",\n                inputSchema={\"type\": \"object\", \"properties\": {}, \"required\": []},\n            ),\n        ]\n    except Exception as e:\n        print(f\"Error in handle_list_tools: {e}\", file=sys.stderr)\n        import traceback\n\n        traceback.print_exc(file=sys.stderr)\n        return []\n\n\n@server.call_tool()\nasync def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:\n    \"\"\"Handle tool calls.\"\"\"\n    global client\n\n    if client is None:\n        return [\n            TextContent(\n                type=\"text\",\n                text=\"Error: StealthMole client not initialized. Please check your API credentials.\",\n            )\n        ]\n\n    try:\n        if name == \"search_darkweb\":\n            result = await client.search_darkweb(\n                indicator=arguments[\"indicator\"],\n                text=arguments[\"text\"],\n                target=arguments.get(\"target\", \"all\"),\n                limit=arguments.get(\"limit\", 50),\n                orderType=arguments.get(\"orderType\", \"createDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_telegram\":\n            result = await client.search_telegram(\n                indicator=arguments[\"indicator\"],\n                text=arguments[\"text\"],\n                target=arguments.get(\"target\", \"all\"),\n                limit=arguments.get(\"limit\", 50),\n                orderType=arguments.get(\"orderType\", \"createDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_credentials\":\n            result = await client.search_credentials(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"leakedDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n                start=arguments.get(\"start\"),\n                end=arguments.get(\"end\"),\n            )\n        elif name == \"search_ransomware\":\n            result = await client.search_ransomware(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"get_node_details\":\n            result = await client.get_node_details(\n                service=arguments[\"service\"],\n                node_id=arguments[\"node_id\"],\n                pid=arguments.get(\"pid\"),\n                data_from=arguments.get(\"data_from\", False),\n                include_url=arguments.get(\"include_url\", False),\n                include_contents=arguments.get(\"include_contents\", True),\n            )\n        elif name == \"get_targets\":\n            result = await client.get_targets(\n                service=arguments[\"service\"], indicator=arguments[\"indicator\"]\n            )\n        elif name == \"export_data\":\n            result = await client.export_data(\n                service=arguments[\"service\"],\n                indicator=arguments[\"indicator\"],\n                format=arguments.get(\"format\", \"json\"),\n            )\n        elif name == \"search_compromised_dataset\":\n            result = await client.search_compromised_dataset(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"export_compromised_dataset\":\n            result = await client.export_compromised_dataset(\n                indicator=arguments[\"indicator\"], format=arguments.get(\"format\", \"json\")\n            )\n        elif name == \"get_compromised_dataset_node\":\n            result = await client.get_compromised_dataset_node(\n                node_id=arguments[\"node_id\"]\n            )\n        elif name == \"search_combo_binder\":\n            result = await client.search_combo_binder(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"export_combo_binder\":\n            result = await client.export_combo_binder(\n                indicator=arguments[\"indicator\"], format=arguments.get(\"format\", \"json\")\n            )\n        elif name == \"search_ulp_binder\":\n            result = await client.search_ulp_binder(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"export_ulp_binder\":\n            result = await client.export_ulp_binder(\n                indicator=arguments[\"indicator\"], format=arguments.get(\"format\", \"json\")\n            )\n        elif name == \"search_government_monitoring\":\n            result = await client.search_government_monitoring(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_leaked_monitoring\":\n            result = await client.search_leaked_monitoring(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"download_file\":\n            file_content = await client.download_file(\n                service=arguments[\"service\"], file_hash=arguments[\"file_hash\"]\n            )\n            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"Downloaded file {arguments['file_hash']} from {arguments['service']} service. File size: {len(file_content)} bytes\",\n                )\n            ]\n        elif name == \"search_pagination\":\n            result = await client.search_pagination(\n                service=arguments[\"service\"],\n                search_id=arguments[\"search_id\"],\n                cursor=arguments.get(\"cursor\", 0),\n                limit=arguments.get(\"limit\", 50),\n            )\n        elif name == \"get_user_quotas\":\n            result = await client.get_user_quotas()\n        else:\n            return [TextContent(type=\"text\", text=f\"Unknown tool: {name}\")]\n\n        return [TextContent(type=\"text\", text=f\"StealthMole API Results:\\n\\n{result}\")]\n\n    except asyncio.TimeoutError:\n        return [\n            TextContent(\n                type=\"text\",\n                text=\"Request timed out. The API request took too long to complete.\",\n            )\n        ]\n    except Exception as e:\n        error_msg = str(e)\n        if \"timeout\" in error_msg.lower():\n            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"Timeout error: {error_msg}. Try reducing the result limit or check your network connection.\",\n                )\n            ]\n        return [\n            TextContent(type=\"text\", text=f\"Error calling StealthMole API: {error_msg}\")\n        ]\n\n\nasync def run_server():\n    \"\"\"Run the MCP server.\"\"\"\n    global client\n\n    try:\n        print(\"Starting StealthMole MCP server...\", file=sys.stderr)\n\n        # Initialize StealthMole client\n        access_key = os.getenv(\"STEALTHMOLE_ACCESS_KEY\")\n        secret_key = os.getenv(\"STEALTHMOLE_SECRET_KEY\")\n\n        print(f\"Access key: {'SET' if access_key else 'NOT SET'}\", file=sys.stderr)\n        print(f\"Secret key: {'SET' if secret_key else 'NOT SET'}\", file=sys.stderr)\n\n        if not access_key or not secret_key:\n            print(\n                \"Warning: STEALTHMOLE_ACCESS_KEY and STEALTHMOLE_SECRET_KEY environment variables not set\",\n                file=sys.stderr,\n            )\n            print(\"MCP server will start but tools will not function\", file=sys.stderr)\n        else:\n            try:\n                config = StealthMoleConfig(access_key=access_key, secret_key=secret_key)\n                print(\"StealthMole config created\", file=sys.stderr)\n                client = StealthMoleClient(config)\n                print(\"StealthMole client initialized\", file=sys.stderr)\n\n                # API 연결 테스트 (타임아웃 없이 간단히)\n                try:\n                    quotas = await client.get_user_quotas()\n                    print(\n                        f\"✓ API connection successful. Available quotas: {quotas}\",\n                        file=sys.stderr,\n                    )\n                except Exception as api_error:\n                    print(f\"Warning: API test failed: {api_error}\", file=sys.stderr)\n                    print(\"Continuing with server startup...\", file=sys.stderr)\n\n            except Exception as e:\n                print(\n                    f\"Warning: Error creating StealthMole client: {e}\", file=sys.stderr\n                )\n                print(\n                    \"MCP server will start but tools may not function properly\",\n                    file=sys.stderr,\n                )\n                import traceback\n\n                traceback.print_exc(file=sys.stderr)\n\n        print(\"Creating stdio server...\", file=sys.stderr)\n        async with stdio_server() as (read_stream, write_stream):\n            print(\"Starting MCP server...\", file=sys.stderr)\n            try:\n                await server.run(\n                    read_stream,\n                    write_stream,\n                    InitializationOptions(\n                        server_name=\"stealthmole-mcp\",\n                        server_version=\"0.1.0\",\n                        capabilities=server.get_capabilities(\n                            notification_options=NotificationOptions(),\n                            experimental_capabilities={},\n                        ),\n                    ),\n                )\n                print(\"MCP server completed normally\", file=sys.stderr)\n            except Exception as e:\n                print(f\"Error in MCP server.run: {e}\", file=sys.stderr)\n                import traceback\n\n                traceback.print_exc(file=sys.stderr)\n                raise\n    except Exception as e:\n        print(f\"Error in run_server: {e}\", file=sys.stderr)\n        import traceback\n\n        traceback.print_exc(file=sys.stderr)\n\n\ndef main():\n    \"\"\"Main entry point for the MCP server.\"\"\"\n    asyncio.run(run_server())\n\n\nif __name__ == \"__main__\":\n    main()\n","structuredPatch":[{"oldStart":21,"oldLines":6,"newStart":21,"newLines":12,"lines":[" # Global client instance"," client: Optional[StealthMoleClient] = None"," ","+# Default system prompt for Neo behavior","+DEFAULT_SYSTEM_PROMPT = \"\"\"If you don't mention a specific indicator, Neo will default to searching by keyword.","+If a different indicator is requested, but not explicitly in the form indicator:query, it will say \"also search keyword for more information\" and proceed. ","+Always set limit to the maximum value.","+We also ask the user if they want to browse the next page:\"\"\"","+"," server: Server = Server(","     \"stealthmole-mcp\",","     \"0.2.0\","]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"40d92f8f-f8f8-4474-9c0e-90f633bdb776","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"e1862b0a-edaf-4305-96cf-2297be889bda","version":"1.0.51","message":{"id":"msg_01DK8CqiNzfvEQwsMvcwLfSL","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01UUi3kuxrHTcpS26upV7LFh","name":"Edit","input":{"file_path":"/Users/realsun/data/git/mole-mcp-server/src/server.py","old_string":"@server.call_tool()\nasync def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:\n    \"\"\"Handle tool calls.\"\"\"\n    global client\n\n    if client is None:\n        return [\n            TextContent(\n                type=\"text\",\n                text=\"Error: StealthMole client not initialized. Please check your API credentials.\",\n            )\n        ]\n\n    try:","new_string":"def apply_default_behavior(name: str, arguments: dict[str, Any]) -> dict[str, Any]:\n    \"\"\"Apply default behavior rules to tool arguments.\"\"\"\n    # Always set limit to maximum value\n    if \"limit\" in arguments:\n        if name in [\"search_darkweb\", \"search_telegram\"]:\n            arguments[\"limit\"] = 100\n        elif name in [\"search_credentials\", \"search_ransomware\", \"search_compromised_dataset\", \n                      \"search_combo_binder\", \"search_ulp_binder\", \"search_government_monitoring\", \n                      \"search_leaked_monitoring\"]:\n            arguments[\"limit\"] = 50\n    \n    # Handle indicator defaults for search tools\n    if name in [\"search_darkweb\", \"search_telegram\"]:\n        if \"indicator\" not in arguments or not arguments[\"indicator\"]:\n            arguments[\"indicator\"] = \"keyword\"\n    \n    return arguments\n\n\n@server.call_tool()\nasync def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:\n    \"\"\"Handle tool calls with default behavior applied.\"\"\"\n    global client\n\n    if client is None:\n        return [\n            TextContent(\n                type=\"text\",\n                text=\"Error: StealthMole client not initialized. Please check your API credentials.\",\n            )\n        ]\n\n    # Apply default behavior rules\n    arguments = apply_default_behavior(name, arguments)\n    \n    # Add system prompt context to response\n    response_prefix = f\"[Neo System Behavior Active]\\n{DEFAULT_SYSTEM_PROMPT}\\n\\n\"\n\n    try:"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":509,"cache_read_input_tokens":31514,"output_tokens":25,"service_tier":"standard"}},"requestId":"req_011CR8BwD8EvMSdNCXJ1wPCV","type":"assistant","uuid":"2d074dcf-dd0a-4db2-9e16-69464a022f12","timestamp":"2025-07-15T04:40:42.194Z"}
{"parentUuid":"2d074dcf-dd0a-4db2-9e16-69464a022f12","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"e1862b0a-edaf-4305-96cf-2297be889bda","version":"1.0.51","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UUi3kuxrHTcpS26upV7LFh","type":"tool_result","content":"The file /Users/realsun/data/git/mole-mcp-server/src/server.py has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   847→        traceback.print_exc(file=sys.stderr)\n   848→        return []\n   849→\n   850→\n   851→def apply_default_behavior(name: str, arguments: dict[str, Any]) -> dict[str, Any]:\n   852→    \"\"\"Apply default behavior rules to tool arguments.\"\"\"\n   853→    # Always set limit to maximum value\n   854→    if \"limit\" in arguments:\n   855→        if name in [\"search_darkweb\", \"search_telegram\"]:\n   856→            arguments[\"limit\"] = 100\n   857→        elif name in [\"search_credentials\", \"search_ransomware\", \"search_compromised_dataset\", \n   858→                      \"search_combo_binder\", \"search_ulp_binder\", \"search_government_monitoring\", \n   859→                      \"search_leaked_monitoring\"]:\n   860→            arguments[\"limit\"] = 50\n   861→    \n   862→    # Handle indicator defaults for search tools\n   863→    if name in [\"search_darkweb\", \"search_telegram\"]:\n   864→        if \"indicator\" not in arguments or not arguments[\"indicator\"]:\n   865→            arguments[\"indicator\"] = \"keyword\"\n   866→    \n   867→    return arguments\n   868→\n   869→\n   870→@server.call_tool()\n   871→async def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:\n   872→    \"\"\"Handle tool calls with default behavior applied.\"\"\"\n   873→    global client\n   874→\n   875→    if client is None:\n   876→        return [\n   877→            TextContent(\n   878→                type=\"text\",\n   879→                text=\"Error: StealthMole client not initialized. Please check your API credentials.\",\n   880→            )\n   881→        ]\n   882→\n   883→    # Apply default behavior rules\n   884→    arguments = apply_default_behavior(name, arguments)\n   885→    \n   886→    # Add system prompt context to response\n   887→    response_prefix = f\"[Neo System Behavior Active]\\n{DEFAULT_SYSTEM_PROMPT}\\n\\n\"\n   888→\n   889→    try:\n   890→        if name == \"search_darkweb\":\n   891→            result = await client.search_darkweb(\n   892→                indicator=arguments[\"indicator\"],\n   893→                text=arguments[\"text\"],"}]},"uuid":"43c5c723-d55a-4a38-8a8a-93894a1d850b","timestamp":"2025-07-15T04:40:44.143Z","toolUseResult":{"filePath":"/Users/realsun/data/git/mole-mcp-server/src/server.py","oldString":"@server.call_tool()\nasync def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:\n    \"\"\"Handle tool calls.\"\"\"\n    global client\n\n    if client is None:\n        return [\n            TextContent(\n                type=\"text\",\n                text=\"Error: StealthMole client not initialized. Please check your API credentials.\",\n            )\n        ]\n\n    try:","newString":"def apply_default_behavior(name: str, arguments: dict[str, Any]) -> dict[str, Any]:\n    \"\"\"Apply default behavior rules to tool arguments.\"\"\"\n    # Always set limit to maximum value\n    if \"limit\" in arguments:\n        if name in [\"search_darkweb\", \"search_telegram\"]:\n            arguments[\"limit\"] = 100\n        elif name in [\"search_credentials\", \"search_ransomware\", \"search_compromised_dataset\", \n                      \"search_combo_binder\", \"search_ulp_binder\", \"search_government_monitoring\", \n                      \"search_leaked_monitoring\"]:\n            arguments[\"limit\"] = 50\n    \n    # Handle indicator defaults for search tools\n    if name in [\"search_darkweb\", \"search_telegram\"]:\n        if \"indicator\" not in arguments or not arguments[\"indicator\"]:\n            arguments[\"indicator\"] = \"keyword\"\n    \n    return arguments\n\n\n@server.call_tool()\nasync def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:\n    \"\"\"Handle tool calls with default behavior applied.\"\"\"\n    global client\n\n    if client is None:\n        return [\n            TextContent(\n                type=\"text\",\n                text=\"Error: StealthMole client not initialized. Please check your API credentials.\",\n            )\n        ]\n\n    # Apply default behavior rules\n    arguments = apply_default_behavior(name, arguments)\n    \n    # Add system prompt context to response\n    response_prefix = f\"[Neo System Behavior Active]\\n{DEFAULT_SYSTEM_PROMPT}\\n\\n\"\n\n    try:","originalFile":"\"\"\"StealthMole MCP Server implementation.\"\"\"\n\nimport asyncio\nimport os\nimport sys\nfrom typing import Any, Optional, Sequence\n\nfrom dotenv import load_dotenv\nfrom mcp.server import NotificationOptions, Server\nfrom mcp.server.models import InitializationOptions\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import Prompt, PromptArgument, PromptMessage, Resource, TextContent, Tool\nfrom pydantic import AnyUrl\n\nfrom src.tools import *\nfrom src.utils.client import StealthMoleClient\nfrom src.utils.config import StealthMoleConfig\n\nload_dotenv()\n\n# Global client instance\nclient: Optional[StealthMoleClient] = None\n\n# Default system prompt for Neo behavior\nDEFAULT_SYSTEM_PROMPT = \"\"\"If you don't mention a specific indicator, Neo will default to searching by keyword.\nIf a different indicator is requested, but not explicitly in the form indicator:query, it will say \"also search keyword for more information\" and proceed. \nAlways set limit to the maximum value.\nWe also ask the user if they want to browse the next page:\"\"\"\n\nserver: Server = Server(\n    \"stealthmole-mcp\",\n    \"0.2.0\",\n)\n\n\n@server.list_resources()\nasync def handle_list_resources() -> list[Resource]:\n    \"\"\"List available resources.\"\"\"\n    return []\n\n\n@server.read_resource()\nasync def handle_read_resource(uri: AnyUrl) -> str:\n    \"\"\"Read a specific resource.\"\"\"\n    raise ValueError(f\"Unknown resource: {uri}\")\n\n\n@server.list_prompts()\nasync def handle_list_prompts() -> list[Prompt]:\n    \"\"\"List available prompts.\"\"\"\n    return [\n        Prompt(\n            name=\"security_analysis\",\n            description=\"Analyze security threats using StealthMole data\",\n            arguments=[\n                PromptArgument(\n                    name=\"target\",\n                    description=\"Target to analyze (domain, IP, email, etc.)\",\n                    required=True,\n                ),\n                PromptArgument(\n                    name=\"analysis_type\",\n                    description=\"Type of analysis (threat_intelligence, credential_exposure, ransomware_monitoring)\",\n                    required=False,\n                ),\n            ],\n        ),\n        Prompt(\n            name=\"threat_investigation\",\n            description=\"Comprehensive threat investigation workflow\",\n            arguments=[\n                PromptArgument(\n                    name=\"indicator\",\n                    description=\"Threat indicator to investigate\",\n                    required=True,\n                ),\n                PromptArgument(\n                    name=\"scope\",\n                    description=\"Investigation scope (basic, comprehensive, deep)\",\n                    required=False,\n                ),\n            ],\n        ),\n    ]\n\n\n@server.get_prompt()\nasync def handle_get_prompt(name: str, arguments: dict[str, str]) -> list[PromptMessage]:\n    \"\"\"Generate prompt content based on the request.\"\"\"\n    if name == \"security_analysis\":\n        target = arguments.get(\"target\", \"\")\n        analysis_type = arguments.get(\"analysis_type\", \"comprehensive\")\n        \n        content = f\"\"\"# Security Analysis for {target}\n\n## Analysis Objective\nPerform a {analysis_type} security analysis of the target: {target}\n\n## Recommended Investigation Steps\n\n1. **Dark Web Intelligence**\n   - Search for mentions of {target} in dark web sources\n   - Look for potential threats, discussions, or planned attacks\n\n2. **Credential Exposure Check**\n   - Search for leaked credentials associated with {target}\n   - Identify potential account compromises\n\n3. **Ransomware Monitoring**\n   - Check if {target} appears in ransomware victim lists\n   - Monitor for ransomware group discussions\n\n4. **Compromised Data Analysis**\n   - Search for {target} in compromised datasets\n   - Identify data breach exposures\n\n## Analysis Commands\nUse the following StealthMole tools to gather intelligence:\n\n```\nsearch_darkweb(indicator=\"domain\", text=\"{target}\")\nsearch_credentials(indicator=\"domain:{target}\")\nsearch_ransomware(indicator=\"domain:{target}\")\nsearch_compromised_dataset(indicator=\"{target}\")\n```\n\n## Report Structure\nPlease structure your findings as:\n1. Executive Summary\n2. Threat Intelligence Findings\n3. Credential Exposure Assessment\n4. Data Breach Impact\n5. Recommendations\n\"\"\"\n        \n        return [\n            PromptMessage(\n                role=\"user\",\n                content=TextContent(type=\"text\", text=content),\n            )\n        ]\n    \n    elif name == \"threat_investigation\":\n        indicator = arguments.get(\"indicator\", \"\")\n        scope = arguments.get(\"scope\", \"comprehensive\")\n        \n        content = f\"\"\"# Threat Investigation: {indicator}\n\n## Investigation Scope: {scope.upper()}\n\n### Target Information\n- **Indicator**: {indicator}\n- **Investigation Date**: {{current_date}}\n- **Scope Level**: {scope}\n\n### Investigation Methodology\n\n#### Phase 1: Initial Intelligence Gathering\n- Search dark web sources for threat intelligence\n- Check Telegram channels for discussions\n- Review government and enterprise monitoring feeds\n\n#### Phase 2: Exposure Assessment\n- Credential compromise analysis\n- Data breach involvement\n- Ransomware victim verification\n\n#### Phase 3: Advanced Analysis\n- Node detail examination\n- File downloads (if applicable)\n- Cross-reference with known threat actors\n\n### Recommended Tool Sequence\n\n1. **Multi-source Search**\n```\nsearch_darkweb(indicator=\"keyword\", text=\"{indicator}\")\nsearch_telegram(indicator=\"keyword\", text=\"{indicator}\")\nsearch_government_monitoring(indicator=\"id:{indicator}\")\nsearch_leaked_monitoring(indicator=\"id:{indicator}\")\n```\n\n2. **Credential and Data Analysis**\n```\nsearch_credentials(indicator=\"{indicator}\")\nsearch_compromised_dataset(indicator=\"{indicator}\")\nsearch_ransomware(indicator=\"{indicator}\")\n```\n\n3. **Detailed Investigation** (if nodes found)\n```\nget_node_details(service=\"dt\", node_id=\"<found_node_id>\")\nget_targets(service=\"dt\", indicator=\"keyword\")\n```\n\n### Output Requirements\n- Comprehensive threat profile\n- Risk assessment\n- Actionable recommendations\n- Technical indicators for monitoring\n\"\"\"\n        \n        return [\n            PromptMessage(\n                role=\"user\",\n                content=TextContent(type=\"text\", text=content),\n            )\n        ]\n    \n    else:\n        raise ValueError(f\"Unknown prompt: {name}\")\n\n\n@server.list_tools()\nasync def handle_list_tools() -> list[Tool]:\n    \"\"\"List available StealthMole tools.\"\"\"\n    try:\n        print(\"Returning StealthMole tools list\", file=sys.stderr)\n        return [\n            Tool(\n                name=\"search_darkweb\",\n                description=\"Search dark web content for indicators like domains, IPs, emails, etc.\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type to search for\",\n                            \"enum\": [\n                                \"adsense\",\n                                \"analyticsid\",\n                                \"band\",\n                                \"bitcoin\",\n                                \"blueprint\",\n                                \"creditcard\",\n                                \"cve\",\n                                \"discord\",\n                                \"document\",\n                                \"domain\",\n                                \"email\",\n                                \"ethereum\",\n                                \"exefile\",\n                                \"facebook\",\n                                \"filehosting\",\n                                \"googledrive\",\n                                \"gps\",\n                                \"hash\",\n                                \"hashstring\",\n                                \"i2p\",\n                                \"i2purl\",\n                                \"id\",\n                                \"image\",\n                                \"instagram\",\n                                \"ioc\",\n                                \"ip\",\n                                \"kakaotalk\",\n                                \"keyword\",\n                                \"kssn\",\n                                \"leakedaudio\",\n                                \"leakedemailfile\",\n                                \"leakedvideo\",\n                                \"line\",\n                                \"linkedin\",\n                                \"malware\",\n                                \"monero\",\n                                \"otherfile\",\n                                \"pastebin\",\n                                \"pgp\",\n                                \"serverstatus\",\n                                \"session\",\n                                \"shorten\",\n                                \"sshkey\",\n                                \"sslkey\",\n                                \"tel\",\n                                \"telegram\",\n                                \"tor\",\n                                \"torurl\",\n                                \"twitter\",\n                                \"url\",\n                            ],\n                        },\n                        \"text\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search keyword or data to find. Supports AND, OR, NOT operators (max 3 OR, 5 total operators)\",\n                        },\n                        \"target\": {\n                            \"type\": \"string\",\n                            \"description\": \"Target type to search (default: 'all'). Use comma-separated values for multiple targets\",\n                            \"default\": \"all\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Ordering type\",\n                            \"enum\": [\"createDate\", \"value\"],\n                            \"default\": \"createDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\", \"text\"],\n                },\n            ),\n            Tool(\n                name=\"search_telegram\",\n                description=\"Search Telegram content for indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type to search for\",\n                            \"enum\": [\n                                \"band\",\n                                \"bitcoin\",\n                                \"creditcard\",\n                                \"cve\",\n                                \"discord\",\n                                \"document\",\n                                \"domain\",\n                                \"email\",\n                                \"ethereum\",\n                                \"exefile\",\n                                \"facebook\",\n                                \"filehosting\",\n                                \"googledrive\",\n                                \"gps\",\n                                \"hash\",\n                                \"hashstring\",\n                                \"i2p\",\n                                \"i2purl\",\n                                \"id\",\n                                \"image\",\n                                \"instagram\",\n                                \"ip\",\n                                \"kakaotalk\",\n                                \"keyword\",\n                                \"kssn\",\n                                \"line\",\n                                \"monero\",\n                                \"otherfile\",\n                                \"pastebin\",\n                                \"pgp\",\n                                \"tel\",\n                                \"session\",\n                                \"shorten\",\n                                \"telegram\",\n                                \"telegram.channel\",\n                                \"telegram.message\",\n                                \"telegram.user\",\n                                \"tor\",\n                                \"torurl\",\n                                \"tox\",\n                                \"twitter\",\n                                \"url\",\n                            ],\n                        },\n                        \"text\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search keyword or data to find. Supports AND, OR, NOT operators (max 3 OR, 5 total operators)\",\n                        },\n                        \"target\": {\n                            \"type\": \"string\",\n                            \"description\": \"Target type to search (default: 'all'). Use comma-separated values for multiple targets\",\n                            \"default\": \"all\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Ordering type\",\n                            \"enum\": [\"createDate\", \"value\"],\n                            \"default\": \"createDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\", \"text\"],\n                },\n            ),\n            Tool(\n                name=\"search_credentials\",\n                description=\"Search for leaked credentials using keywords or specific indicators (domain:, email:, id:, password:, after:, before:)\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - can use indicators like 'domain:example.com', 'email:user@domain.com', 'id:username', 'password:pass123', 'after:2023-01', 'before:2024-01' or plain keywords\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\n                                \"leakedDate\",\n                                \"domain\",\n                                \"email\",\n                                \"password\",\n                                \"leakedFrom\",\n                            ],\n                            \"default\": \"leakedDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                        \"start\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Filter data added to the system after start time (UTC timestamp)\",\n                        },\n                        \"end\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Filter data added to the system before end time (UTC timestamp)\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_ransomware\",\n                description=\"Search ransomware monitoring data using torurl: or domain: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'torurl:site.onion' to search ransomware sites or 'domain:victim.com' to search victim websites. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"victim\", \"attackGroup\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"get_node_details\",\n                description=\"Get detailed information about a specific node\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"node_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Node ID to get details for\",\n                        },\n                        \"pid\": {\n                            \"type\": \"string\",\n                            \"description\": \"Parent node ID (optional)\",\n                        },\n                        \"data_from\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Import data source list (default: False)\",\n                            \"default\": False,\n                        },\n                        \"include_url\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Import included URL list (default: False)\",\n                            \"default\": False,\n                        },\n                        \"include_contents\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Include HTML source contents for torurl, i2purl, url (default: True)\",\n                            \"default\": True,\n                        },\n                    },\n                    \"required\": [\"service\", \"node_id\"],\n                },\n            ),\n            Tool(\n                name=\"get_targets\",\n                description=\"Get available search targets for a service and indicator\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type\",\n                        },\n                    },\n                    \"required\": [\"service\", \"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_data\",\n                description=\"Export search results in specified format\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"service\", \"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_compromised_dataset\",\n                description=\"Search compromised data set information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_compromised_dataset\",\n                description=\"Export compromised data set as CSV/JSON\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"get_compromised_dataset_node\",\n                description=\"Get detailed compromised data set node information (Cyber Security Edition required)\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"node_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Node ID to get details for\",\n                        }\n                    },\n                    \"required\": [\"node_id\"],\n                },\n            ),\n            Tool(\n                name=\"search_combo_binder\",\n                description=\"Search leaked ID/Password combo information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_combo_binder\",\n                description=\"Export combo binder data as CSV/JSON\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_ulp_binder\",\n                description=\"Search URL-Login-Password combination information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_ulp_binder\",\n                description=\"Export ULP binder data as CSV/JSON\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_government_monitoring\",\n                description=\"Search government sector threat monitoring data using url: or id: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'url:hackersite.com' to search threat event URLs or 'id:hacker123' to search actor IDs. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"title\", \"author\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_leaked_monitoring\",\n                description=\"Search enterprise sector threat monitoring data using url: or id: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'url:hackersite.com' to search threat event URLs or 'id:hacker123' to search actor IDs. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"title\", \"author\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"download_file\",\n                description=\"Download file by hash from dt or tt service\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt or tt)\",\n                            \"enum\": [\"dt\", \"tt\"],\n                        },\n                        \"file_hash\": {\n                            \"type\": \"string\",\n                            \"description\": \"File hash to download\",\n                        },\n                    },\n                    \"required\": [\"service\", \"file_hash\"],\n                },\n            ),\n            Tool(\n                name=\"search_pagination\",\n                description=\"Pagination search using search ID for dt or tt service\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt or tt)\",\n                            \"enum\": [\"dt\", \"tt\"],\n                        },\n                        \"search_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search ID from previous search\",\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"service\", \"search_id\"],\n                },\n            ),\n            Tool(\n                name=\"get_user_quotas\",\n                description=\"Get API usage quotas by service\",\n                inputSchema={\"type\": \"object\", \"properties\": {}, \"required\": []},\n            ),\n        ]\n    except Exception as e:\n        print(f\"Error in handle_list_tools: {e}\", file=sys.stderr)\n        import traceback\n\n        traceback.print_exc(file=sys.stderr)\n        return []\n\n\n@server.call_tool()\nasync def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:\n    \"\"\"Handle tool calls.\"\"\"\n    global client\n\n    if client is None:\n        return [\n            TextContent(\n                type=\"text\",\n                text=\"Error: StealthMole client not initialized. Please check your API credentials.\",\n            )\n        ]\n\n    try:\n        if name == \"search_darkweb\":\n            result = await client.search_darkweb(\n                indicator=arguments[\"indicator\"],\n                text=arguments[\"text\"],\n                target=arguments.get(\"target\", \"all\"),\n                limit=arguments.get(\"limit\", 50),\n                orderType=arguments.get(\"orderType\", \"createDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_telegram\":\n            result = await client.search_telegram(\n                indicator=arguments[\"indicator\"],\n                text=arguments[\"text\"],\n                target=arguments.get(\"target\", \"all\"),\n                limit=arguments.get(\"limit\", 50),\n                orderType=arguments.get(\"orderType\", \"createDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_credentials\":\n            result = await client.search_credentials(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"leakedDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n                start=arguments.get(\"start\"),\n                end=arguments.get(\"end\"),\n            )\n        elif name == \"search_ransomware\":\n            result = await client.search_ransomware(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"get_node_details\":\n            result = await client.get_node_details(\n                service=arguments[\"service\"],\n                node_id=arguments[\"node_id\"],\n                pid=arguments.get(\"pid\"),\n                data_from=arguments.get(\"data_from\", False),\n                include_url=arguments.get(\"include_url\", False),\n                include_contents=arguments.get(\"include_contents\", True),\n            )\n        elif name == \"get_targets\":\n            result = await client.get_targets(\n                service=arguments[\"service\"], indicator=arguments[\"indicator\"]\n            )\n        elif name == \"export_data\":\n            result = await client.export_data(\n                service=arguments[\"service\"],\n                indicator=arguments[\"indicator\"],\n                format=arguments.get(\"format\", \"json\"),\n            )\n        elif name == \"search_compromised_dataset\":\n            result = await client.search_compromised_dataset(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"export_compromised_dataset\":\n            result = await client.export_compromised_dataset(\n                indicator=arguments[\"indicator\"], format=arguments.get(\"format\", \"json\")\n            )\n        elif name == \"get_compromised_dataset_node\":\n            result = await client.get_compromised_dataset_node(\n                node_id=arguments[\"node_id\"]\n            )\n        elif name == \"search_combo_binder\":\n            result = await client.search_combo_binder(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"export_combo_binder\":\n            result = await client.export_combo_binder(\n                indicator=arguments[\"indicator\"], format=arguments.get(\"format\", \"json\")\n            )\n        elif name == \"search_ulp_binder\":\n            result = await client.search_ulp_binder(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"export_ulp_binder\":\n            result = await client.export_ulp_binder(\n                indicator=arguments[\"indicator\"], format=arguments.get(\"format\", \"json\")\n            )\n        elif name == \"search_government_monitoring\":\n            result = await client.search_government_monitoring(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_leaked_monitoring\":\n            result = await client.search_leaked_monitoring(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"download_file\":\n            file_content = await client.download_file(\n                service=arguments[\"service\"], file_hash=arguments[\"file_hash\"]\n            )\n            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"Downloaded file {arguments['file_hash']} from {arguments['service']} service. File size: {len(file_content)} bytes\",\n                )\n            ]\n        elif name == \"search_pagination\":\n            result = await client.search_pagination(\n                service=arguments[\"service\"],\n                search_id=arguments[\"search_id\"],\n                cursor=arguments.get(\"cursor\", 0),\n                limit=arguments.get(\"limit\", 50),\n            )\n        elif name == \"get_user_quotas\":\n            result = await client.get_user_quotas()\n        else:\n            return [TextContent(type=\"text\", text=f\"Unknown tool: {name}\")]\n\n        return [TextContent(type=\"text\", text=f\"StealthMole API Results:\\n\\n{result}\")]\n\n    except asyncio.TimeoutError:\n        return [\n            TextContent(\n                type=\"text\",\n                text=\"Request timed out. The API request took too long to complete.\",\n            )\n        ]\n    except Exception as e:\n        error_msg = str(e)\n        if \"timeout\" in error_msg.lower():\n            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"Timeout error: {error_msg}. Try reducing the result limit or check your network connection.\",\n                )\n            ]\n        return [\n            TextContent(type=\"text\", text=f\"Error calling StealthMole API: {error_msg}\")\n        ]\n\n\nasync def run_server():\n    \"\"\"Run the MCP server.\"\"\"\n    global client\n\n    try:\n        print(\"Starting StealthMole MCP server...\", file=sys.stderr)\n\n        # Initialize StealthMole client\n        access_key = os.getenv(\"STEALTHMOLE_ACCESS_KEY\")\n        secret_key = os.getenv(\"STEALTHMOLE_SECRET_KEY\")\n\n        print(f\"Access key: {'SET' if access_key else 'NOT SET'}\", file=sys.stderr)\n        print(f\"Secret key: {'SET' if secret_key else 'NOT SET'}\", file=sys.stderr)\n\n        if not access_key or not secret_key:\n            print(\n                \"Warning: STEALTHMOLE_ACCESS_KEY and STEALTHMOLE_SECRET_KEY environment variables not set\",\n                file=sys.stderr,\n            )\n            print(\"MCP server will start but tools will not function\", file=sys.stderr)\n        else:\n            try:\n                config = StealthMoleConfig(access_key=access_key, secret_key=secret_key)\n                print(\"StealthMole config created\", file=sys.stderr)\n                client = StealthMoleClient(config)\n                print(\"StealthMole client initialized\", file=sys.stderr)\n\n                # API 연결 테스트 (타임아웃 없이 간단히)\n                try:\n                    quotas = await client.get_user_quotas()\n                    print(\n                        f\"✓ API connection successful. Available quotas: {quotas}\",\n                        file=sys.stderr,\n                    )\n                except Exception as api_error:\n                    print(f\"Warning: API test failed: {api_error}\", file=sys.stderr)\n                    print(\"Continuing with server startup...\", file=sys.stderr)\n\n            except Exception as e:\n                print(\n                    f\"Warning: Error creating StealthMole client: {e}\", file=sys.stderr\n                )\n                print(\n                    \"MCP server will start but tools may not function properly\",\n                    file=sys.stderr,\n                )\n                import traceback\n\n                traceback.print_exc(file=sys.stderr)\n\n        print(\"Creating stdio server...\", file=sys.stderr)\n        async with stdio_server() as (read_stream, write_stream):\n            print(\"Starting MCP server...\", file=sys.stderr)\n            try:\n                await server.run(\n                    read_stream,\n                    write_stream,\n                    InitializationOptions(\n                        server_name=\"stealthmole-mcp\",\n                        server_version=\"0.1.0\",\n                        capabilities=server.get_capabilities(\n                            notification_options=NotificationOptions(),\n                            experimental_capabilities={},\n                        ),\n                    ),\n                )\n                print(\"MCP server completed normally\", file=sys.stderr)\n            except Exception as e:\n                print(f\"Error in MCP server.run: {e}\", file=sys.stderr)\n                import traceback\n\n                traceback.print_exc(file=sys.stderr)\n                raise\n    except Exception as e:\n        print(f\"Error in run_server: {e}\", file=sys.stderr)\n        import traceback\n\n        traceback.print_exc(file=sys.stderr)\n\n\ndef main():\n    \"\"\"Main entry point for the MCP server.\"\"\"\n    asyncio.run(run_server())\n\n\nif __name__ == \"__main__\":\n    main()\n","structuredPatch":[{"oldStart":848,"oldLines":9,"newStart":848,"newLines":28,"lines":["         return []"," "," ","+def apply_default_behavior(name: str, arguments: dict[str, Any]) -> dict[str, Any]:","+    \"\"\"Apply default behavior rules to tool arguments.\"\"\"","+    # Always set limit to maximum value","+    if \"limit\" in arguments:","+        if name in [\"search_darkweb\", \"search_telegram\"]:","+            arguments[\"limit\"] = 100","+        elif name in [\"search_credentials\", \"search_ransomware\", \"search_compromised_dataset\", ","+                      \"search_combo_binder\", \"search_ulp_binder\", \"search_government_monitoring\", ","+                      \"search_leaked_monitoring\"]:","+            arguments[\"limit\"] = 50","+    ","+    # Handle indicator defaults for search tools","+    if name in [\"search_darkweb\", \"search_telegram\"]:","+        if \"indicator\" not in arguments or not arguments[\"indicator\"]:","+            arguments[\"indicator\"] = \"keyword\"","+    ","+    return arguments","+","+"," @server.call_tool()"," async def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:","-    \"\"\"Handle tool calls.\"\"\"","+    \"\"\"Handle tool calls with default behavior applied.\"\"\"","     global client"," ","     if client is None:"]},{"oldStart":861,"oldLines":6,"newStart":880,"newLines":12,"lines":["             )","         ]"," ","+    # Apply default behavior rules","+    arguments = apply_default_behavior(name, arguments)","+    ","+    # Add system prompt context to response","+    response_prefix = f\"[Neo System Behavior Active]\\n{DEFAULT_SYSTEM_PROMPT}\\n\\n\"","+","     try:","         if name == \"search_darkweb\":","             result = await client.search_darkweb("]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"43c5c723-d55a-4a38-8a8a-93894a1d850b","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"e1862b0a-edaf-4305-96cf-2297be889bda","version":"1.0.51","message":{"id":"msg_015qpRugVJMi9QAhYPmq2NnE","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01JCMkp2JriP3sDeSdswxNRx","name":"Edit","input":{"file_path":"/Users/realsun/data/git/mole-mcp-server/src/server.py","old_string":"        else:\n            return [TextContent(type=\"text\", text=f\"Unknown tool: {name}\")]\n\n        return [TextContent(type=\"text\", text=f\"StealthMole API Results:\\n\\n{result}\")]","new_string":"        else:\n            return [TextContent(type=\"text\", text=f\"Unknown tool: {name}\")]\n\n        # Format response with system behavior context\n        response_text = f\"{response_prefix}StealthMole API Results:\\n\\n{result}\\n\\n---\\nWould you like to browse the next page of results?\"\n        return [TextContent(type=\"text\", text=response_text)]"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":1237,"cache_read_input_tokens":32023,"output_tokens":260,"service_tier":"standard"}},"requestId":"req_011CR8Bx9mN7hd93RWWHU1Wx","type":"assistant","uuid":"084c6784-4cb8-48bf-a6ad-83dd7b123216","timestamp":"2025-07-15T04:40:49.619Z"}
{"parentUuid":"084c6784-4cb8-48bf-a6ad-83dd7b123216","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"e1862b0a-edaf-4305-96cf-2297be889bda","version":"1.0.51","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JCMkp2JriP3sDeSdswxNRx","type":"tool_result","content":"The file /Users/realsun/data/git/mole-mcp-server/src/server.py has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  1004→                limit=arguments.get(\"limit\", 50),\n  1005→            )\n  1006→        elif name == \"get_user_quotas\":\n  1007→            result = await client.get_user_quotas()\n  1008→        else:\n  1009→            return [TextContent(type=\"text\", text=f\"Unknown tool: {name}\")]\n  1010→\n  1011→        # Format response with system behavior context\n  1012→        response_text = f\"{response_prefix}StealthMole API Results:\\n\\n{result}\\n\\n---\\nWould you like to browse the next page of results?\"\n  1013→        return [TextContent(type=\"text\", text=response_text)]\n  1014→\n  1015→    except asyncio.TimeoutError:\n  1016→        return [\n  1017→            TextContent("}]},"uuid":"dcd0b0a0-95af-48c8-8ac8-2f9960806c4f","timestamp":"2025-07-15T04:41:00.798Z","toolUseResult":{"filePath":"/Users/realsun/data/git/mole-mcp-server/src/server.py","oldString":"        else:\n            return [TextContent(type=\"text\", text=f\"Unknown tool: {name}\")]\n\n        return [TextContent(type=\"text\", text=f\"StealthMole API Results:\\n\\n{result}\")]","newString":"        else:\n            return [TextContent(type=\"text\", text=f\"Unknown tool: {name}\")]\n\n        # Format response with system behavior context\n        response_text = f\"{response_prefix}StealthMole API Results:\\n\\n{result}\\n\\n---\\nWould you like to browse the next page of results?\"\n        return [TextContent(type=\"text\", text=response_text)]","originalFile":"\"\"\"StealthMole MCP Server implementation.\"\"\"\n\nimport asyncio\nimport os\nimport sys\nfrom typing import Any, Optional, Sequence\n\nfrom dotenv import load_dotenv\nfrom mcp.server import NotificationOptions, Server\nfrom mcp.server.models import InitializationOptions\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import Prompt, PromptArgument, PromptMessage, Resource, TextContent, Tool\nfrom pydantic import AnyUrl\n\nfrom src.tools import *\nfrom src.utils.client import StealthMoleClient\nfrom src.utils.config import StealthMoleConfig\n\nload_dotenv()\n\n# Global client instance\nclient: Optional[StealthMoleClient] = None\n\n# Default system prompt for Neo behavior\nDEFAULT_SYSTEM_PROMPT = \"\"\"If you don't mention a specific indicator, Neo will default to searching by keyword.\nIf a different indicator is requested, but not explicitly in the form indicator:query, it will say \"also search keyword for more information\" and proceed. \nAlways set limit to the maximum value.\nWe also ask the user if they want to browse the next page:\"\"\"\n\nserver: Server = Server(\n    \"stealthmole-mcp\",\n    \"0.2.0\",\n)\n\n\n@server.list_resources()\nasync def handle_list_resources() -> list[Resource]:\n    \"\"\"List available resources.\"\"\"\n    return []\n\n\n@server.read_resource()\nasync def handle_read_resource(uri: AnyUrl) -> str:\n    \"\"\"Read a specific resource.\"\"\"\n    raise ValueError(f\"Unknown resource: {uri}\")\n\n\n@server.list_prompts()\nasync def handle_list_prompts() -> list[Prompt]:\n    \"\"\"List available prompts.\"\"\"\n    return [\n        Prompt(\n            name=\"security_analysis\",\n            description=\"Analyze security threats using StealthMole data\",\n            arguments=[\n                PromptArgument(\n                    name=\"target\",\n                    description=\"Target to analyze (domain, IP, email, etc.)\",\n                    required=True,\n                ),\n                PromptArgument(\n                    name=\"analysis_type\",\n                    description=\"Type of analysis (threat_intelligence, credential_exposure, ransomware_monitoring)\",\n                    required=False,\n                ),\n            ],\n        ),\n        Prompt(\n            name=\"threat_investigation\",\n            description=\"Comprehensive threat investigation workflow\",\n            arguments=[\n                PromptArgument(\n                    name=\"indicator\",\n                    description=\"Threat indicator to investigate\",\n                    required=True,\n                ),\n                PromptArgument(\n                    name=\"scope\",\n                    description=\"Investigation scope (basic, comprehensive, deep)\",\n                    required=False,\n                ),\n            ],\n        ),\n    ]\n\n\n@server.get_prompt()\nasync def handle_get_prompt(name: str, arguments: dict[str, str]) -> list[PromptMessage]:\n    \"\"\"Generate prompt content based on the request.\"\"\"\n    if name == \"security_analysis\":\n        target = arguments.get(\"target\", \"\")\n        analysis_type = arguments.get(\"analysis_type\", \"comprehensive\")\n        \n        content = f\"\"\"# Security Analysis for {target}\n\n## Analysis Objective\nPerform a {analysis_type} security analysis of the target: {target}\n\n## Recommended Investigation Steps\n\n1. **Dark Web Intelligence**\n   - Search for mentions of {target} in dark web sources\n   - Look for potential threats, discussions, or planned attacks\n\n2. **Credential Exposure Check**\n   - Search for leaked credentials associated with {target}\n   - Identify potential account compromises\n\n3. **Ransomware Monitoring**\n   - Check if {target} appears in ransomware victim lists\n   - Monitor for ransomware group discussions\n\n4. **Compromised Data Analysis**\n   - Search for {target} in compromised datasets\n   - Identify data breach exposures\n\n## Analysis Commands\nUse the following StealthMole tools to gather intelligence:\n\n```\nsearch_darkweb(indicator=\"domain\", text=\"{target}\")\nsearch_credentials(indicator=\"domain:{target}\")\nsearch_ransomware(indicator=\"domain:{target}\")\nsearch_compromised_dataset(indicator=\"{target}\")\n```\n\n## Report Structure\nPlease structure your findings as:\n1. Executive Summary\n2. Threat Intelligence Findings\n3. Credential Exposure Assessment\n4. Data Breach Impact\n5. Recommendations\n\"\"\"\n        \n        return [\n            PromptMessage(\n                role=\"user\",\n                content=TextContent(type=\"text\", text=content),\n            )\n        ]\n    \n    elif name == \"threat_investigation\":\n        indicator = arguments.get(\"indicator\", \"\")\n        scope = arguments.get(\"scope\", \"comprehensive\")\n        \n        content = f\"\"\"# Threat Investigation: {indicator}\n\n## Investigation Scope: {scope.upper()}\n\n### Target Information\n- **Indicator**: {indicator}\n- **Investigation Date**: {{current_date}}\n- **Scope Level**: {scope}\n\n### Investigation Methodology\n\n#### Phase 1: Initial Intelligence Gathering\n- Search dark web sources for threat intelligence\n- Check Telegram channels for discussions\n- Review government and enterprise monitoring feeds\n\n#### Phase 2: Exposure Assessment\n- Credential compromise analysis\n- Data breach involvement\n- Ransomware victim verification\n\n#### Phase 3: Advanced Analysis\n- Node detail examination\n- File downloads (if applicable)\n- Cross-reference with known threat actors\n\n### Recommended Tool Sequence\n\n1. **Multi-source Search**\n```\nsearch_darkweb(indicator=\"keyword\", text=\"{indicator}\")\nsearch_telegram(indicator=\"keyword\", text=\"{indicator}\")\nsearch_government_monitoring(indicator=\"id:{indicator}\")\nsearch_leaked_monitoring(indicator=\"id:{indicator}\")\n```\n\n2. **Credential and Data Analysis**\n```\nsearch_credentials(indicator=\"{indicator}\")\nsearch_compromised_dataset(indicator=\"{indicator}\")\nsearch_ransomware(indicator=\"{indicator}\")\n```\n\n3. **Detailed Investigation** (if nodes found)\n```\nget_node_details(service=\"dt\", node_id=\"<found_node_id>\")\nget_targets(service=\"dt\", indicator=\"keyword\")\n```\n\n### Output Requirements\n- Comprehensive threat profile\n- Risk assessment\n- Actionable recommendations\n- Technical indicators for monitoring\n\"\"\"\n        \n        return [\n            PromptMessage(\n                role=\"user\",\n                content=TextContent(type=\"text\", text=content),\n            )\n        ]\n    \n    else:\n        raise ValueError(f\"Unknown prompt: {name}\")\n\n\n@server.list_tools()\nasync def handle_list_tools() -> list[Tool]:\n    \"\"\"List available StealthMole tools.\"\"\"\n    try:\n        print(\"Returning StealthMole tools list\", file=sys.stderr)\n        return [\n            Tool(\n                name=\"search_darkweb\",\n                description=\"Search dark web content for indicators like domains, IPs, emails, etc.\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type to search for\",\n                            \"enum\": [\n                                \"adsense\",\n                                \"analyticsid\",\n                                \"band\",\n                                \"bitcoin\",\n                                \"blueprint\",\n                                \"creditcard\",\n                                \"cve\",\n                                \"discord\",\n                                \"document\",\n                                \"domain\",\n                                \"email\",\n                                \"ethereum\",\n                                \"exefile\",\n                                \"facebook\",\n                                \"filehosting\",\n                                \"googledrive\",\n                                \"gps\",\n                                \"hash\",\n                                \"hashstring\",\n                                \"i2p\",\n                                \"i2purl\",\n                                \"id\",\n                                \"image\",\n                                \"instagram\",\n                                \"ioc\",\n                                \"ip\",\n                                \"kakaotalk\",\n                                \"keyword\",\n                                \"kssn\",\n                                \"leakedaudio\",\n                                \"leakedemailfile\",\n                                \"leakedvideo\",\n                                \"line\",\n                                \"linkedin\",\n                                \"malware\",\n                                \"monero\",\n                                \"otherfile\",\n                                \"pastebin\",\n                                \"pgp\",\n                                \"serverstatus\",\n                                \"session\",\n                                \"shorten\",\n                                \"sshkey\",\n                                \"sslkey\",\n                                \"tel\",\n                                \"telegram\",\n                                \"tor\",\n                                \"torurl\",\n                                \"twitter\",\n                                \"url\",\n                            ],\n                        },\n                        \"text\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search keyword or data to find. Supports AND, OR, NOT operators (max 3 OR, 5 total operators)\",\n                        },\n                        \"target\": {\n                            \"type\": \"string\",\n                            \"description\": \"Target type to search (default: 'all'). Use comma-separated values for multiple targets\",\n                            \"default\": \"all\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Ordering type\",\n                            \"enum\": [\"createDate\", \"value\"],\n                            \"default\": \"createDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\", \"text\"],\n                },\n            ),\n            Tool(\n                name=\"search_telegram\",\n                description=\"Search Telegram content for indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type to search for\",\n                            \"enum\": [\n                                \"band\",\n                                \"bitcoin\",\n                                \"creditcard\",\n                                \"cve\",\n                                \"discord\",\n                                \"document\",\n                                \"domain\",\n                                \"email\",\n                                \"ethereum\",\n                                \"exefile\",\n                                \"facebook\",\n                                \"filehosting\",\n                                \"googledrive\",\n                                \"gps\",\n                                \"hash\",\n                                \"hashstring\",\n                                \"i2p\",\n                                \"i2purl\",\n                                \"id\",\n                                \"image\",\n                                \"instagram\",\n                                \"ip\",\n                                \"kakaotalk\",\n                                \"keyword\",\n                                \"kssn\",\n                                \"line\",\n                                \"monero\",\n                                \"otherfile\",\n                                \"pastebin\",\n                                \"pgp\",\n                                \"tel\",\n                                \"session\",\n                                \"shorten\",\n                                \"telegram\",\n                                \"telegram.channel\",\n                                \"telegram.message\",\n                                \"telegram.user\",\n                                \"tor\",\n                                \"torurl\",\n                                \"tox\",\n                                \"twitter\",\n                                \"url\",\n                            ],\n                        },\n                        \"text\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search keyword or data to find. Supports AND, OR, NOT operators (max 3 OR, 5 total operators)\",\n                        },\n                        \"target\": {\n                            \"type\": \"string\",\n                            \"description\": \"Target type to search (default: 'all'). Use comma-separated values for multiple targets\",\n                            \"default\": \"all\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Ordering type\",\n                            \"enum\": [\"createDate\", \"value\"],\n                            \"default\": \"createDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\", \"text\"],\n                },\n            ),\n            Tool(\n                name=\"search_credentials\",\n                description=\"Search for leaked credentials using keywords or specific indicators (domain:, email:, id:, password:, after:, before:)\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - can use indicators like 'domain:example.com', 'email:user@domain.com', 'id:username', 'password:pass123', 'after:2023-01', 'before:2024-01' or plain keywords\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\n                                \"leakedDate\",\n                                \"domain\",\n                                \"email\",\n                                \"password\",\n                                \"leakedFrom\",\n                            ],\n                            \"default\": \"leakedDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                        \"start\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Filter data added to the system after start time (UTC timestamp)\",\n                        },\n                        \"end\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Filter data added to the system before end time (UTC timestamp)\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_ransomware\",\n                description=\"Search ransomware monitoring data using torurl: or domain: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'torurl:site.onion' to search ransomware sites or 'domain:victim.com' to search victim websites. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"victim\", \"attackGroup\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"get_node_details\",\n                description=\"Get detailed information about a specific node\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"node_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Node ID to get details for\",\n                        },\n                        \"pid\": {\n                            \"type\": \"string\",\n                            \"description\": \"Parent node ID (optional)\",\n                        },\n                        \"data_from\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Import data source list (default: False)\",\n                            \"default\": False,\n                        },\n                        \"include_url\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Import included URL list (default: False)\",\n                            \"default\": False,\n                        },\n                        \"include_contents\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Include HTML source contents for torurl, i2purl, url (default: True)\",\n                            \"default\": True,\n                        },\n                    },\n                    \"required\": [\"service\", \"node_id\"],\n                },\n            ),\n            Tool(\n                name=\"get_targets\",\n                description=\"Get available search targets for a service and indicator\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type\",\n                        },\n                    },\n                    \"required\": [\"service\", \"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_data\",\n                description=\"Export search results in specified format\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"service\", \"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_compromised_dataset\",\n                description=\"Search compromised data set information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_compromised_dataset\",\n                description=\"Export compromised data set as CSV/JSON\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"get_compromised_dataset_node\",\n                description=\"Get detailed compromised data set node information (Cyber Security Edition required)\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"node_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Node ID to get details for\",\n                        }\n                    },\n                    \"required\": [\"node_id\"],\n                },\n            ),\n            Tool(\n                name=\"search_combo_binder\",\n                description=\"Search leaked ID/Password combo information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_combo_binder\",\n                description=\"Export combo binder data as CSV/JSON\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_ulp_binder\",\n                description=\"Search URL-Login-Password combination information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_ulp_binder\",\n                description=\"Export ULP binder data as CSV/JSON\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_government_monitoring\",\n                description=\"Search government sector threat monitoring data using url: or id: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'url:hackersite.com' to search threat event URLs or 'id:hacker123' to search actor IDs. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"title\", \"author\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_leaked_monitoring\",\n                description=\"Search enterprise sector threat monitoring data using url: or id: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'url:hackersite.com' to search threat event URLs or 'id:hacker123' to search actor IDs. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"title\", \"author\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"download_file\",\n                description=\"Download file by hash from dt or tt service\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt or tt)\",\n                            \"enum\": [\"dt\", \"tt\"],\n                        },\n                        \"file_hash\": {\n                            \"type\": \"string\",\n                            \"description\": \"File hash to download\",\n                        },\n                    },\n                    \"required\": [\"service\", \"file_hash\"],\n                },\n            ),\n            Tool(\n                name=\"search_pagination\",\n                description=\"Pagination search using search ID for dt or tt service\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt or tt)\",\n                            \"enum\": [\"dt\", \"tt\"],\n                        },\n                        \"search_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search ID from previous search\",\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"service\", \"search_id\"],\n                },\n            ),\n            Tool(\n                name=\"get_user_quotas\",\n                description=\"Get API usage quotas by service\",\n                inputSchema={\"type\": \"object\", \"properties\": {}, \"required\": []},\n            ),\n        ]\n    except Exception as e:\n        print(f\"Error in handle_list_tools: {e}\", file=sys.stderr)\n        import traceback\n\n        traceback.print_exc(file=sys.stderr)\n        return []\n\n\ndef apply_default_behavior(name: str, arguments: dict[str, Any]) -> dict[str, Any]:\n    \"\"\"Apply default behavior rules to tool arguments.\"\"\"\n    # Always set limit to maximum value\n    if \"limit\" in arguments:\n        if name in [\"search_darkweb\", \"search_telegram\"]:\n            arguments[\"limit\"] = 100\n        elif name in [\"search_credentials\", \"search_ransomware\", \"search_compromised_dataset\", \n                      \"search_combo_binder\", \"search_ulp_binder\", \"search_government_monitoring\", \n                      \"search_leaked_monitoring\"]:\n            arguments[\"limit\"] = 50\n    \n    # Handle indicator defaults for search tools\n    if name in [\"search_darkweb\", \"search_telegram\"]:\n        if \"indicator\" not in arguments or not arguments[\"indicator\"]:\n            arguments[\"indicator\"] = \"keyword\"\n    \n    return arguments\n\n\n@server.call_tool()\nasync def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:\n    \"\"\"Handle tool calls with default behavior applied.\"\"\"\n    global client\n\n    if client is None:\n        return [\n            TextContent(\n                type=\"text\",\n                text=\"Error: StealthMole client not initialized. Please check your API credentials.\",\n            )\n        ]\n\n    # Apply default behavior rules\n    arguments = apply_default_behavior(name, arguments)\n    \n    # Add system prompt context to response\n    response_prefix = f\"[Neo System Behavior Active]\\n{DEFAULT_SYSTEM_PROMPT}\\n\\n\"\n\n    try:\n        if name == \"search_darkweb\":\n            result = await client.search_darkweb(\n                indicator=arguments[\"indicator\"],\n                text=arguments[\"text\"],\n                target=arguments.get(\"target\", \"all\"),\n                limit=arguments.get(\"limit\", 50),\n                orderType=arguments.get(\"orderType\", \"createDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_telegram\":\n            result = await client.search_telegram(\n                indicator=arguments[\"indicator\"],\n                text=arguments[\"text\"],\n                target=arguments.get(\"target\", \"all\"),\n                limit=arguments.get(\"limit\", 50),\n                orderType=arguments.get(\"orderType\", \"createDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_credentials\":\n            result = await client.search_credentials(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"leakedDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n                start=arguments.get(\"start\"),\n                end=arguments.get(\"end\"),\n            )\n        elif name == \"search_ransomware\":\n            result = await client.search_ransomware(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"get_node_details\":\n            result = await client.get_node_details(\n                service=arguments[\"service\"],\n                node_id=arguments[\"node_id\"],\n                pid=arguments.get(\"pid\"),\n                data_from=arguments.get(\"data_from\", False),\n                include_url=arguments.get(\"include_url\", False),\n                include_contents=arguments.get(\"include_contents\", True),\n            )\n        elif name == \"get_targets\":\n            result = await client.get_targets(\n                service=arguments[\"service\"], indicator=arguments[\"indicator\"]\n            )\n        elif name == \"export_data\":\n            result = await client.export_data(\n                service=arguments[\"service\"],\n                indicator=arguments[\"indicator\"],\n                format=arguments.get(\"format\", \"json\"),\n            )\n        elif name == \"search_compromised_dataset\":\n            result = await client.search_compromised_dataset(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"export_compromised_dataset\":\n            result = await client.export_compromised_dataset(\n                indicator=arguments[\"indicator\"], format=arguments.get(\"format\", \"json\")\n            )\n        elif name == \"get_compromised_dataset_node\":\n            result = await client.get_compromised_dataset_node(\n                node_id=arguments[\"node_id\"]\n            )\n        elif name == \"search_combo_binder\":\n            result = await client.search_combo_binder(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"export_combo_binder\":\n            result = await client.export_combo_binder(\n                indicator=arguments[\"indicator\"], format=arguments.get(\"format\", \"json\")\n            )\n        elif name == \"search_ulp_binder\":\n            result = await client.search_ulp_binder(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"export_ulp_binder\":\n            result = await client.export_ulp_binder(\n                indicator=arguments[\"indicator\"], format=arguments.get(\"format\", \"json\")\n            )\n        elif name == \"search_government_monitoring\":\n            result = await client.search_government_monitoring(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_leaked_monitoring\":\n            result = await client.search_leaked_monitoring(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"download_file\":\n            file_content = await client.download_file(\n                service=arguments[\"service\"], file_hash=arguments[\"file_hash\"]\n            )\n            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"Downloaded file {arguments['file_hash']} from {arguments['service']} service. File size: {len(file_content)} bytes\",\n                )\n            ]\n        elif name == \"search_pagination\":\n            result = await client.search_pagination(\n                service=arguments[\"service\"],\n                search_id=arguments[\"search_id\"],\n                cursor=arguments.get(\"cursor\", 0),\n                limit=arguments.get(\"limit\", 50),\n            )\n        elif name == \"get_user_quotas\":\n            result = await client.get_user_quotas()\n        else:\n            return [TextContent(type=\"text\", text=f\"Unknown tool: {name}\")]\n\n        return [TextContent(type=\"text\", text=f\"StealthMole API Results:\\n\\n{result}\")]\n\n    except asyncio.TimeoutError:\n        return [\n            TextContent(\n                type=\"text\",\n                text=\"Request timed out. The API request took too long to complete.\",\n            )\n        ]\n    except Exception as e:\n        error_msg = str(e)\n        if \"timeout\" in error_msg.lower():\n            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"Timeout error: {error_msg}. Try reducing the result limit or check your network connection.\",\n                )\n            ]\n        return [\n            TextContent(type=\"text\", text=f\"Error calling StealthMole API: {error_msg}\")\n        ]\n\n\nasync def run_server():\n    \"\"\"Run the MCP server.\"\"\"\n    global client\n\n    try:\n        print(\"Starting StealthMole MCP server...\", file=sys.stderr)\n\n        # Initialize StealthMole client\n        access_key = os.getenv(\"STEALTHMOLE_ACCESS_KEY\")\n        secret_key = os.getenv(\"STEALTHMOLE_SECRET_KEY\")\n\n        print(f\"Access key: {'SET' if access_key else 'NOT SET'}\", file=sys.stderr)\n        print(f\"Secret key: {'SET' if secret_key else 'NOT SET'}\", file=sys.stderr)\n\n        if not access_key or not secret_key:\n            print(\n                \"Warning: STEALTHMOLE_ACCESS_KEY and STEALTHMOLE_SECRET_KEY environment variables not set\",\n                file=sys.stderr,\n            )\n            print(\"MCP server will start but tools will not function\", file=sys.stderr)\n        else:\n            try:\n                config = StealthMoleConfig(access_key=access_key, secret_key=secret_key)\n                print(\"StealthMole config created\", file=sys.stderr)\n                client = StealthMoleClient(config)\n                print(\"StealthMole client initialized\", file=sys.stderr)\n\n                # API 연결 테스트 (타임아웃 없이 간단히)\n                try:\n                    quotas = await client.get_user_quotas()\n                    print(\n                        f\"✓ API connection successful. Available quotas: {quotas}\",\n                        file=sys.stderr,\n                    )\n                except Exception as api_error:\n                    print(f\"Warning: API test failed: {api_error}\", file=sys.stderr)\n                    print(\"Continuing with server startup...\", file=sys.stderr)\n\n            except Exception as e:\n                print(\n                    f\"Warning: Error creating StealthMole client: {e}\", file=sys.stderr\n                )\n                print(\n                    \"MCP server will start but tools may not function properly\",\n                    file=sys.stderr,\n                )\n                import traceback\n\n                traceback.print_exc(file=sys.stderr)\n\n        print(\"Creating stdio server...\", file=sys.stderr)\n        async with stdio_server() as (read_stream, write_stream):\n            print(\"Starting MCP server...\", file=sys.stderr)\n            try:\n                await server.run(\n                    read_stream,\n                    write_stream,\n                    InitializationOptions(\n                        server_name=\"stealthmole-mcp\",\n                        server_version=\"0.1.0\",\n                        capabilities=server.get_capabilities(\n                            notification_options=NotificationOptions(),\n                            experimental_capabilities={},\n                        ),\n                    ),\n                )\n                print(\"MCP server completed normally\", file=sys.stderr)\n            except Exception as e:\n                print(f\"Error in MCP server.run: {e}\", file=sys.stderr)\n                import traceback\n\n                traceback.print_exc(file=sys.stderr)\n                raise\n    except Exception as e:\n        print(f\"Error in run_server: {e}\", file=sys.stderr)\n        import traceback\n\n        traceback.print_exc(file=sys.stderr)\n\n\ndef main():\n    \"\"\"Main entry point for the MCP server.\"\"\"\n    asyncio.run(run_server())\n\n\nif __name__ == \"__main__\":\n    main()\n","structuredPatch":[{"oldStart":1008,"oldLines":7,"newStart":1008,"newLines":9,"lines":["         else:","             return [TextContent(type=\"text\", text=f\"Unknown tool: {name}\")]"," ","-        return [TextContent(type=\"text\", text=f\"StealthMole API Results:\\n\\n{result}\")]","+        # Format response with system behavior context","+        response_text = f\"{response_prefix}StealthMole API Results:\\n\\n{result}\\n\\n---\\nWould you like to browse the next page of results?\"","+        return [TextContent(type=\"text\", text=response_text)]"," ","     except asyncio.TimeoutError:","         return ["]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"dcd0b0a0-95af-48c8-8ac8-2f9960806c4f","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"e1862b0a-edaf-4305-96cf-2297be889bda","version":"1.0.51","message":{"id":"msg_01STbYPhoRPNPpsNQ32jrr7m","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01G7CTQCTMqQZzXwxaWCZBPV","name":"Edit","input":{"file_path":"/Users/realsun/data/git/mole-mcp-server/src/server.py","old_string":"    except asyncio.TimeoutError:\n        return [\n            TextContent(\n                type=\"text\",\n                text=\"Request timed out. The API request took too long to complete.\",\n            )\n        ]\n    except Exception as e:\n        error_msg = str(e)\n        if \"timeout\" in error_msg.lower():\n            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"Timeout error: {error_msg}. Try reducing the result limit or check your network connection.\",\n                )\n            ]\n        return [\n            TextContent(type=\"text\", text=f\"Error calling StealthMole API: {error_msg}\")\n        ]","new_string":"    except asyncio.TimeoutError:\n        return [\n            TextContent(\n                type=\"text\",\n                text=f\"{response_prefix}Request timed out. The API request took too long to complete.\",\n            )\n        ]\n    except Exception as e:\n        error_msg = str(e)\n        if \"timeout\" in error_msg.lower():\n            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"{response_prefix}Timeout error: {error_msg}. Try reducing the result limit or check your network connection.\",\n                )\n            ]\n        return [\n            TextContent(type=\"text\", text=f\"{response_prefix}Error calling StealthMole API: {error_msg}\")\n        ]"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":536,"cache_read_input_tokens":33260,"output_tokens":448,"service_tier":"standard"}},"requestId":"req_011CR8ByP4LiMjtBg4meamVi","type":"assistant","uuid":"560c39c9-06a8-4aea-86ab-bf45f9d3c986","timestamp":"2025-07-15T04:41:07.599Z"}
{"parentUuid":"560c39c9-06a8-4aea-86ab-bf45f9d3c986","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"e1862b0a-edaf-4305-96cf-2297be889bda","version":"1.0.51","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01G7CTQCTMqQZzXwxaWCZBPV","type":"tool_result","content":"The file /Users/realsun/data/git/mole-mcp-server/src/server.py has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  1011→        # Format response with system behavior context\n  1012→        response_text = f\"{response_prefix}StealthMole API Results:\\n\\n{result}\\n\\n---\\nWould you like to browse the next page of results?\"\n  1013→        return [TextContent(type=\"text\", text=response_text)]\n  1014→\n  1015→    except asyncio.TimeoutError:\n  1016→        return [\n  1017→            TextContent(\n  1018→                type=\"text\",\n  1019→                text=f\"{response_prefix}Request timed out. The API request took too long to complete.\",\n  1020→            )\n  1021→        ]\n  1022→    except Exception as e:\n  1023→        error_msg = str(e)\n  1024→        if \"timeout\" in error_msg.lower():\n  1025→            return [\n  1026→                TextContent(\n  1027→                    type=\"text\",\n  1028→                    text=f\"{response_prefix}Timeout error: {error_msg}. Try reducing the result limit or check your network connection.\",\n  1029→                )\n  1030→            ]\n  1031→        return [\n  1032→            TextContent(type=\"text\", text=f\"{response_prefix}Error calling StealthMole API: {error_msg}\")\n  1033→        ]\n  1034→\n  1035→\n  1036→async def run_server():\n  1037→    \"\"\"Run the MCP server.\"\"\""}]},"uuid":"bd5d8fa5-4f04-4354-89a6-9d9ec74c32da","timestamp":"2025-07-15T04:41:10.572Z","toolUseResult":{"filePath":"/Users/realsun/data/git/mole-mcp-server/src/server.py","oldString":"    except asyncio.TimeoutError:\n        return [\n            TextContent(\n                type=\"text\",\n                text=\"Request timed out. The API request took too long to complete.\",\n            )\n        ]\n    except Exception as e:\n        error_msg = str(e)\n        if \"timeout\" in error_msg.lower():\n            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"Timeout error: {error_msg}. Try reducing the result limit or check your network connection.\",\n                )\n            ]\n        return [\n            TextContent(type=\"text\", text=f\"Error calling StealthMole API: {error_msg}\")\n        ]","newString":"    except asyncio.TimeoutError:\n        return [\n            TextContent(\n                type=\"text\",\n                text=f\"{response_prefix}Request timed out. The API request took too long to complete.\",\n            )\n        ]\n    except Exception as e:\n        error_msg = str(e)\n        if \"timeout\" in error_msg.lower():\n            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"{response_prefix}Timeout error: {error_msg}. Try reducing the result limit or check your network connection.\",\n                )\n            ]\n        return [\n            TextContent(type=\"text\", text=f\"{response_prefix}Error calling StealthMole API: {error_msg}\")\n        ]","originalFile":"\"\"\"StealthMole MCP Server implementation.\"\"\"\n\nimport asyncio\nimport os\nimport sys\nfrom typing import Any, Optional, Sequence\n\nfrom dotenv import load_dotenv\nfrom mcp.server import NotificationOptions, Server\nfrom mcp.server.models import InitializationOptions\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import Prompt, PromptArgument, PromptMessage, Resource, TextContent, Tool\nfrom pydantic import AnyUrl\n\nfrom src.tools import *\nfrom src.utils.client import StealthMoleClient\nfrom src.utils.config import StealthMoleConfig\n\nload_dotenv()\n\n# Global client instance\nclient: Optional[StealthMoleClient] = None\n\n# Default system prompt for Neo behavior\nDEFAULT_SYSTEM_PROMPT = \"\"\"If you don't mention a specific indicator, Neo will default to searching by keyword.\nIf a different indicator is requested, but not explicitly in the form indicator:query, it will say \"also search keyword for more information\" and proceed. \nAlways set limit to the maximum value.\nWe also ask the user if they want to browse the next page:\"\"\"\n\nserver: Server = Server(\n    \"stealthmole-mcp\",\n    \"0.2.0\",\n)\n\n\n@server.list_resources()\nasync def handle_list_resources() -> list[Resource]:\n    \"\"\"List available resources.\"\"\"\n    return []\n\n\n@server.read_resource()\nasync def handle_read_resource(uri: AnyUrl) -> str:\n    \"\"\"Read a specific resource.\"\"\"\n    raise ValueError(f\"Unknown resource: {uri}\")\n\n\n@server.list_prompts()\nasync def handle_list_prompts() -> list[Prompt]:\n    \"\"\"List available prompts.\"\"\"\n    return [\n        Prompt(\n            name=\"security_analysis\",\n            description=\"Analyze security threats using StealthMole data\",\n            arguments=[\n                PromptArgument(\n                    name=\"target\",\n                    description=\"Target to analyze (domain, IP, email, etc.)\",\n                    required=True,\n                ),\n                PromptArgument(\n                    name=\"analysis_type\",\n                    description=\"Type of analysis (threat_intelligence, credential_exposure, ransomware_monitoring)\",\n                    required=False,\n                ),\n            ],\n        ),\n        Prompt(\n            name=\"threat_investigation\",\n            description=\"Comprehensive threat investigation workflow\",\n            arguments=[\n                PromptArgument(\n                    name=\"indicator\",\n                    description=\"Threat indicator to investigate\",\n                    required=True,\n                ),\n                PromptArgument(\n                    name=\"scope\",\n                    description=\"Investigation scope (basic, comprehensive, deep)\",\n                    required=False,\n                ),\n            ],\n        ),\n    ]\n\n\n@server.get_prompt()\nasync def handle_get_prompt(name: str, arguments: dict[str, str]) -> list[PromptMessage]:\n    \"\"\"Generate prompt content based on the request.\"\"\"\n    if name == \"security_analysis\":\n        target = arguments.get(\"target\", \"\")\n        analysis_type = arguments.get(\"analysis_type\", \"comprehensive\")\n        \n        content = f\"\"\"# Security Analysis for {target}\n\n## Analysis Objective\nPerform a {analysis_type} security analysis of the target: {target}\n\n## Recommended Investigation Steps\n\n1. **Dark Web Intelligence**\n   - Search for mentions of {target} in dark web sources\n   - Look for potential threats, discussions, or planned attacks\n\n2. **Credential Exposure Check**\n   - Search for leaked credentials associated with {target}\n   - Identify potential account compromises\n\n3. **Ransomware Monitoring**\n   - Check if {target} appears in ransomware victim lists\n   - Monitor for ransomware group discussions\n\n4. **Compromised Data Analysis**\n   - Search for {target} in compromised datasets\n   - Identify data breach exposures\n\n## Analysis Commands\nUse the following StealthMole tools to gather intelligence:\n\n```\nsearch_darkweb(indicator=\"domain\", text=\"{target}\")\nsearch_credentials(indicator=\"domain:{target}\")\nsearch_ransomware(indicator=\"domain:{target}\")\nsearch_compromised_dataset(indicator=\"{target}\")\n```\n\n## Report Structure\nPlease structure your findings as:\n1. Executive Summary\n2. Threat Intelligence Findings\n3. Credential Exposure Assessment\n4. Data Breach Impact\n5. Recommendations\n\"\"\"\n        \n        return [\n            PromptMessage(\n                role=\"user\",\n                content=TextContent(type=\"text\", text=content),\n            )\n        ]\n    \n    elif name == \"threat_investigation\":\n        indicator = arguments.get(\"indicator\", \"\")\n        scope = arguments.get(\"scope\", \"comprehensive\")\n        \n        content = f\"\"\"# Threat Investigation: {indicator}\n\n## Investigation Scope: {scope.upper()}\n\n### Target Information\n- **Indicator**: {indicator}\n- **Investigation Date**: {{current_date}}\n- **Scope Level**: {scope}\n\n### Investigation Methodology\n\n#### Phase 1: Initial Intelligence Gathering\n- Search dark web sources for threat intelligence\n- Check Telegram channels for discussions\n- Review government and enterprise monitoring feeds\n\n#### Phase 2: Exposure Assessment\n- Credential compromise analysis\n- Data breach involvement\n- Ransomware victim verification\n\n#### Phase 3: Advanced Analysis\n- Node detail examination\n- File downloads (if applicable)\n- Cross-reference with known threat actors\n\n### Recommended Tool Sequence\n\n1. **Multi-source Search**\n```\nsearch_darkweb(indicator=\"keyword\", text=\"{indicator}\")\nsearch_telegram(indicator=\"keyword\", text=\"{indicator}\")\nsearch_government_monitoring(indicator=\"id:{indicator}\")\nsearch_leaked_monitoring(indicator=\"id:{indicator}\")\n```\n\n2. **Credential and Data Analysis**\n```\nsearch_credentials(indicator=\"{indicator}\")\nsearch_compromised_dataset(indicator=\"{indicator}\")\nsearch_ransomware(indicator=\"{indicator}\")\n```\n\n3. **Detailed Investigation** (if nodes found)\n```\nget_node_details(service=\"dt\", node_id=\"<found_node_id>\")\nget_targets(service=\"dt\", indicator=\"keyword\")\n```\n\n### Output Requirements\n- Comprehensive threat profile\n- Risk assessment\n- Actionable recommendations\n- Technical indicators for monitoring\n\"\"\"\n        \n        return [\n            PromptMessage(\n                role=\"user\",\n                content=TextContent(type=\"text\", text=content),\n            )\n        ]\n    \n    else:\n        raise ValueError(f\"Unknown prompt: {name}\")\n\n\n@server.list_tools()\nasync def handle_list_tools() -> list[Tool]:\n    \"\"\"List available StealthMole tools.\"\"\"\n    try:\n        print(\"Returning StealthMole tools list\", file=sys.stderr)\n        return [\n            Tool(\n                name=\"search_darkweb\",\n                description=\"Search dark web content for indicators like domains, IPs, emails, etc.\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type to search for\",\n                            \"enum\": [\n                                \"adsense\",\n                                \"analyticsid\",\n                                \"band\",\n                                \"bitcoin\",\n                                \"blueprint\",\n                                \"creditcard\",\n                                \"cve\",\n                                \"discord\",\n                                \"document\",\n                                \"domain\",\n                                \"email\",\n                                \"ethereum\",\n                                \"exefile\",\n                                \"facebook\",\n                                \"filehosting\",\n                                \"googledrive\",\n                                \"gps\",\n                                \"hash\",\n                                \"hashstring\",\n                                \"i2p\",\n                                \"i2purl\",\n                                \"id\",\n                                \"image\",\n                                \"instagram\",\n                                \"ioc\",\n                                \"ip\",\n                                \"kakaotalk\",\n                                \"keyword\",\n                                \"kssn\",\n                                \"leakedaudio\",\n                                \"leakedemailfile\",\n                                \"leakedvideo\",\n                                \"line\",\n                                \"linkedin\",\n                                \"malware\",\n                                \"monero\",\n                                \"otherfile\",\n                                \"pastebin\",\n                                \"pgp\",\n                                \"serverstatus\",\n                                \"session\",\n                                \"shorten\",\n                                \"sshkey\",\n                                \"sslkey\",\n                                \"tel\",\n                                \"telegram\",\n                                \"tor\",\n                                \"torurl\",\n                                \"twitter\",\n                                \"url\",\n                            ],\n                        },\n                        \"text\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search keyword or data to find. Supports AND, OR, NOT operators (max 3 OR, 5 total operators)\",\n                        },\n                        \"target\": {\n                            \"type\": \"string\",\n                            \"description\": \"Target type to search (default: 'all'). Use comma-separated values for multiple targets\",\n                            \"default\": \"all\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Ordering type\",\n                            \"enum\": [\"createDate\", \"value\"],\n                            \"default\": \"createDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\", \"text\"],\n                },\n            ),\n            Tool(\n                name=\"search_telegram\",\n                description=\"Search Telegram content for indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type to search for\",\n                            \"enum\": [\n                                \"band\",\n                                \"bitcoin\",\n                                \"creditcard\",\n                                \"cve\",\n                                \"discord\",\n                                \"document\",\n                                \"domain\",\n                                \"email\",\n                                \"ethereum\",\n                                \"exefile\",\n                                \"facebook\",\n                                \"filehosting\",\n                                \"googledrive\",\n                                \"gps\",\n                                \"hash\",\n                                \"hashstring\",\n                                \"i2p\",\n                                \"i2purl\",\n                                \"id\",\n                                \"image\",\n                                \"instagram\",\n                                \"ip\",\n                                \"kakaotalk\",\n                                \"keyword\",\n                                \"kssn\",\n                                \"line\",\n                                \"monero\",\n                                \"otherfile\",\n                                \"pastebin\",\n                                \"pgp\",\n                                \"tel\",\n                                \"session\",\n                                \"shorten\",\n                                \"telegram\",\n                                \"telegram.channel\",\n                                \"telegram.message\",\n                                \"telegram.user\",\n                                \"tor\",\n                                \"torurl\",\n                                \"tox\",\n                                \"twitter\",\n                                \"url\",\n                            ],\n                        },\n                        \"text\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search keyword or data to find. Supports AND, OR, NOT operators (max 3 OR, 5 total operators)\",\n                        },\n                        \"target\": {\n                            \"type\": \"string\",\n                            \"description\": \"Target type to search (default: 'all'). Use comma-separated values for multiple targets\",\n                            \"default\": \"all\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Ordering type\",\n                            \"enum\": [\"createDate\", \"value\"],\n                            \"default\": \"createDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\", \"text\"],\n                },\n            ),\n            Tool(\n                name=\"search_credentials\",\n                description=\"Search for leaked credentials using keywords or specific indicators (domain:, email:, id:, password:, after:, before:)\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - can use indicators like 'domain:example.com', 'email:user@domain.com', 'id:username', 'password:pass123', 'after:2023-01', 'before:2024-01' or plain keywords\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\n                                \"leakedDate\",\n                                \"domain\",\n                                \"email\",\n                                \"password\",\n                                \"leakedFrom\",\n                            ],\n                            \"default\": \"leakedDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                        \"start\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Filter data added to the system after start time (UTC timestamp)\",\n                        },\n                        \"end\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Filter data added to the system before end time (UTC timestamp)\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_ransomware\",\n                description=\"Search ransomware monitoring data using torurl: or domain: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'torurl:site.onion' to search ransomware sites or 'domain:victim.com' to search victim websites. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"victim\", \"attackGroup\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"get_node_details\",\n                description=\"Get detailed information about a specific node\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"node_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Node ID to get details for\",\n                        },\n                        \"pid\": {\n                            \"type\": \"string\",\n                            \"description\": \"Parent node ID (optional)\",\n                        },\n                        \"data_from\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Import data source list (default: False)\",\n                            \"default\": False,\n                        },\n                        \"include_url\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Import included URL list (default: False)\",\n                            \"default\": False,\n                        },\n                        \"include_contents\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Include HTML source contents for torurl, i2purl, url (default: True)\",\n                            \"default\": True,\n                        },\n                    },\n                    \"required\": [\"service\", \"node_id\"],\n                },\n            ),\n            Tool(\n                name=\"get_targets\",\n                description=\"Get available search targets for a service and indicator\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type\",\n                        },\n                    },\n                    \"required\": [\"service\", \"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_data\",\n                description=\"Export search results in specified format\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"service\", \"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_compromised_dataset\",\n                description=\"Search compromised data set information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_compromised_dataset\",\n                description=\"Export compromised data set as CSV/JSON\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"get_compromised_dataset_node\",\n                description=\"Get detailed compromised data set node information (Cyber Security Edition required)\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"node_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Node ID to get details for\",\n                        }\n                    },\n                    \"required\": [\"node_id\"],\n                },\n            ),\n            Tool(\n                name=\"search_combo_binder\",\n                description=\"Search leaked ID/Password combo information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_combo_binder\",\n                description=\"Export combo binder data as CSV/JSON\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_ulp_binder\",\n                description=\"Search URL-Login-Password combination information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_ulp_binder\",\n                description=\"Export ULP binder data as CSV/JSON\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_government_monitoring\",\n                description=\"Search government sector threat monitoring data using url: or id: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'url:hackersite.com' to search threat event URLs or 'id:hacker123' to search actor IDs. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"title\", \"author\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_leaked_monitoring\",\n                description=\"Search enterprise sector threat monitoring data using url: or id: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'url:hackersite.com' to search threat event URLs or 'id:hacker123' to search actor IDs. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"title\", \"author\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"download_file\",\n                description=\"Download file by hash from dt or tt service\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt or tt)\",\n                            \"enum\": [\"dt\", \"tt\"],\n                        },\n                        \"file_hash\": {\n                            \"type\": \"string\",\n                            \"description\": \"File hash to download\",\n                        },\n                    },\n                    \"required\": [\"service\", \"file_hash\"],\n                },\n            ),\n            Tool(\n                name=\"search_pagination\",\n                description=\"Pagination search using search ID for dt or tt service\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt or tt)\",\n                            \"enum\": [\"dt\", \"tt\"],\n                        },\n                        \"search_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search ID from previous search\",\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"service\", \"search_id\"],\n                },\n            ),\n            Tool(\n                name=\"get_user_quotas\",\n                description=\"Get API usage quotas by service\",\n                inputSchema={\"type\": \"object\", \"properties\": {}, \"required\": []},\n            ),\n        ]\n    except Exception as e:\n        print(f\"Error in handle_list_tools: {e}\", file=sys.stderr)\n        import traceback\n\n        traceback.print_exc(file=sys.stderr)\n        return []\n\n\ndef apply_default_behavior(name: str, arguments: dict[str, Any]) -> dict[str, Any]:\n    \"\"\"Apply default behavior rules to tool arguments.\"\"\"\n    # Always set limit to maximum value\n    if \"limit\" in arguments:\n        if name in [\"search_darkweb\", \"search_telegram\"]:\n            arguments[\"limit\"] = 100\n        elif name in [\"search_credentials\", \"search_ransomware\", \"search_compromised_dataset\", \n                      \"search_combo_binder\", \"search_ulp_binder\", \"search_government_monitoring\", \n                      \"search_leaked_monitoring\"]:\n            arguments[\"limit\"] = 50\n    \n    # Handle indicator defaults for search tools\n    if name in [\"search_darkweb\", \"search_telegram\"]:\n        if \"indicator\" not in arguments or not arguments[\"indicator\"]:\n            arguments[\"indicator\"] = \"keyword\"\n    \n    return arguments\n\n\n@server.call_tool()\nasync def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:\n    \"\"\"Handle tool calls with default behavior applied.\"\"\"\n    global client\n\n    if client is None:\n        return [\n            TextContent(\n                type=\"text\",\n                text=\"Error: StealthMole client not initialized. Please check your API credentials.\",\n            )\n        ]\n\n    # Apply default behavior rules\n    arguments = apply_default_behavior(name, arguments)\n    \n    # Add system prompt context to response\n    response_prefix = f\"[Neo System Behavior Active]\\n{DEFAULT_SYSTEM_PROMPT}\\n\\n\"\n\n    try:\n        if name == \"search_darkweb\":\n            result = await client.search_darkweb(\n                indicator=arguments[\"indicator\"],\n                text=arguments[\"text\"],\n                target=arguments.get(\"target\", \"all\"),\n                limit=arguments.get(\"limit\", 50),\n                orderType=arguments.get(\"orderType\", \"createDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_telegram\":\n            result = await client.search_telegram(\n                indicator=arguments[\"indicator\"],\n                text=arguments[\"text\"],\n                target=arguments.get(\"target\", \"all\"),\n                limit=arguments.get(\"limit\", 50),\n                orderType=arguments.get(\"orderType\", \"createDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_credentials\":\n            result = await client.search_credentials(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"leakedDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n                start=arguments.get(\"start\"),\n                end=arguments.get(\"end\"),\n            )\n        elif name == \"search_ransomware\":\n            result = await client.search_ransomware(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"get_node_details\":\n            result = await client.get_node_details(\n                service=arguments[\"service\"],\n                node_id=arguments[\"node_id\"],\n                pid=arguments.get(\"pid\"),\n                data_from=arguments.get(\"data_from\", False),\n                include_url=arguments.get(\"include_url\", False),\n                include_contents=arguments.get(\"include_contents\", True),\n            )\n        elif name == \"get_targets\":\n            result = await client.get_targets(\n                service=arguments[\"service\"], indicator=arguments[\"indicator\"]\n            )\n        elif name == \"export_data\":\n            result = await client.export_data(\n                service=arguments[\"service\"],\n                indicator=arguments[\"indicator\"],\n                format=arguments.get(\"format\", \"json\"),\n            )\n        elif name == \"search_compromised_dataset\":\n            result = await client.search_compromised_dataset(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"export_compromised_dataset\":\n            result = await client.export_compromised_dataset(\n                indicator=arguments[\"indicator\"], format=arguments.get(\"format\", \"json\")\n            )\n        elif name == \"get_compromised_dataset_node\":\n            result = await client.get_compromised_dataset_node(\n                node_id=arguments[\"node_id\"]\n            )\n        elif name == \"search_combo_binder\":\n            result = await client.search_combo_binder(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"export_combo_binder\":\n            result = await client.export_combo_binder(\n                indicator=arguments[\"indicator\"], format=arguments.get(\"format\", \"json\")\n            )\n        elif name == \"search_ulp_binder\":\n            result = await client.search_ulp_binder(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"export_ulp_binder\":\n            result = await client.export_ulp_binder(\n                indicator=arguments[\"indicator\"], format=arguments.get(\"format\", \"json\")\n            )\n        elif name == \"search_government_monitoring\":\n            result = await client.search_government_monitoring(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_leaked_monitoring\":\n            result = await client.search_leaked_monitoring(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"download_file\":\n            file_content = await client.download_file(\n                service=arguments[\"service\"], file_hash=arguments[\"file_hash\"]\n            )\n            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"Downloaded file {arguments['file_hash']} from {arguments['service']} service. File size: {len(file_content)} bytes\",\n                )\n            ]\n        elif name == \"search_pagination\":\n            result = await client.search_pagination(\n                service=arguments[\"service\"],\n                search_id=arguments[\"search_id\"],\n                cursor=arguments.get(\"cursor\", 0),\n                limit=arguments.get(\"limit\", 50),\n            )\n        elif name == \"get_user_quotas\":\n            result = await client.get_user_quotas()\n        else:\n            return [TextContent(type=\"text\", text=f\"Unknown tool: {name}\")]\n\n        # Format response with system behavior context\n        response_text = f\"{response_prefix}StealthMole API Results:\\n\\n{result}\\n\\n---\\nWould you like to browse the next page of results?\"\n        return [TextContent(type=\"text\", text=response_text)]\n\n    except asyncio.TimeoutError:\n        return [\n            TextContent(\n                type=\"text\",\n                text=\"Request timed out. The API request took too long to complete.\",\n            )\n        ]\n    except Exception as e:\n        error_msg = str(e)\n        if \"timeout\" in error_msg.lower():\n            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"Timeout error: {error_msg}. Try reducing the result limit or check your network connection.\",\n                )\n            ]\n        return [\n            TextContent(type=\"text\", text=f\"Error calling StealthMole API: {error_msg}\")\n        ]\n\n\nasync def run_server():\n    \"\"\"Run the MCP server.\"\"\"\n    global client\n\n    try:\n        print(\"Starting StealthMole MCP server...\", file=sys.stderr)\n\n        # Initialize StealthMole client\n        access_key = os.getenv(\"STEALTHMOLE_ACCESS_KEY\")\n        secret_key = os.getenv(\"STEALTHMOLE_SECRET_KEY\")\n\n        print(f\"Access key: {'SET' if access_key else 'NOT SET'}\", file=sys.stderr)\n        print(f\"Secret key: {'SET' if secret_key else 'NOT SET'}\", file=sys.stderr)\n\n        if not access_key or not secret_key:\n            print(\n                \"Warning: STEALTHMOLE_ACCESS_KEY and STEALTHMOLE_SECRET_KEY environment variables not set\",\n                file=sys.stderr,\n            )\n            print(\"MCP server will start but tools will not function\", file=sys.stderr)\n        else:\n            try:\n                config = StealthMoleConfig(access_key=access_key, secret_key=secret_key)\n                print(\"StealthMole config created\", file=sys.stderr)\n                client = StealthMoleClient(config)\n                print(\"StealthMole client initialized\", file=sys.stderr)\n\n                # API 연결 테스트 (타임아웃 없이 간단히)\n                try:\n                    quotas = await client.get_user_quotas()\n                    print(\n                        f\"✓ API connection successful. Available quotas: {quotas}\",\n                        file=sys.stderr,\n                    )\n                except Exception as api_error:\n                    print(f\"Warning: API test failed: {api_error}\", file=sys.stderr)\n                    print(\"Continuing with server startup...\", file=sys.stderr)\n\n            except Exception as e:\n                print(\n                    f\"Warning: Error creating StealthMole client: {e}\", file=sys.stderr\n                )\n                print(\n                    \"MCP server will start but tools may not function properly\",\n                    file=sys.stderr,\n                )\n                import traceback\n\n                traceback.print_exc(file=sys.stderr)\n\n        print(\"Creating stdio server...\", file=sys.stderr)\n        async with stdio_server() as (read_stream, write_stream):\n            print(\"Starting MCP server...\", file=sys.stderr)\n            try:\n                await server.run(\n                    read_stream,\n                    write_stream,\n                    InitializationOptions(\n                        server_name=\"stealthmole-mcp\",\n                        server_version=\"0.1.0\",\n                        capabilities=server.get_capabilities(\n                            notification_options=NotificationOptions(),\n                            experimental_capabilities={},\n                        ),\n                    ),\n                )\n                print(\"MCP server completed normally\", file=sys.stderr)\n            except Exception as e:\n                print(f\"Error in MCP server.run: {e}\", file=sys.stderr)\n                import traceback\n\n                traceback.print_exc(file=sys.stderr)\n                raise\n    except Exception as e:\n        print(f\"Error in run_server: {e}\", file=sys.stderr)\n        import traceback\n\n        traceback.print_exc(file=sys.stderr)\n\n\ndef main():\n    \"\"\"Main entry point for the MCP server.\"\"\"\n    asyncio.run(run_server())\n\n\nif __name__ == \"__main__\":\n    main()\n","structuredPatch":[{"oldStart":1016,"oldLines":7,"newStart":1016,"newLines":7,"lines":["         return [","             TextContent(","                 type=\"text\",","-                text=\"Request timed out. The API request took too long to complete.\",","+                text=f\"{response_prefix}Request timed out. The API request took too long to complete.\",","             )","         ]","     except Exception as e:"]},{"oldStart":1025,"oldLines":11,"newStart":1025,"newLines":11,"lines":["             return [","                 TextContent(","                     type=\"text\",","-                    text=f\"Timeout error: {error_msg}. Try reducing the result limit or check your network connection.\",","+                    text=f\"{response_prefix}Timeout error: {error_msg}. Try reducing the result limit or check your network connection.\",","                 )","             ]","         return [","-            TextContent(type=\"text\", text=f\"Error calling StealthMole API: {error_msg}\")","+            TextContent(type=\"text\", text=f\"{response_prefix}Error calling StealthMole API: {error_msg}\")","         ]"," "," "]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"bd5d8fa5-4f04-4354-89a6-9d9ec74c32da","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"e1862b0a-edaf-4305-96cf-2297be889bda","version":"1.0.51","message":{"id":"msg_01CRMnRzmGjJf29hLR5zkg9s","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01DnqXUnweBsLSuueUyye8s4","name":"TodoWrite","input":{"todos":[{"id":"1","content":"서버 초기화 시 기본 시스템 프롬프트 설정","status":"completed","priority":"high"},{"id":"2","content":"도구 호출 시 기본 동작 규칙 적용","status":"completed","priority":"medium"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":881,"cache_read_input_tokens":33796,"output_tokens":239,"service_tier":"standard"}},"requestId":"req_011CR8Bz6pK3NT5knyvirvoK","type":"assistant","uuid":"bb98ef08-bfc4-4a81-88ff-c2067cc57b8f","timestamp":"2025-07-15T04:41:17.340Z"}
{"parentUuid":"bb98ef08-bfc4-4a81-88ff-c2067cc57b8f","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"e1862b0a-edaf-4305-96cf-2297be889bda","version":"1.0.51","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DnqXUnweBsLSuueUyye8s4","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"f4160a79-5269-4ecb-afb0-47882da53845","timestamp":"2025-07-15T04:41:17.364Z","toolUseResult":{"oldTodos":[{"content":"서버 초기화 시 기본 시스템 프롬프트 설정","status":"in_progress","priority":"high","id":"1"},{"content":"도구 호출 시 기본 동작 규칙 적용","status":"pending","priority":"medium","id":"2"}],"newTodos":[{"content":"서버 초기화 시 기본 시스템 프롬프트 설정","status":"completed","priority":"high","id":"1"},{"content":"도구 호출 시 기본 동작 규칙 적용","status":"completed","priority":"medium","id":"2"}]}}
{"parentUuid":"f4160a79-5269-4ecb-afb0-47882da53845","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"e1862b0a-edaf-4305-96cf-2297be889bda","version":"1.0.51","message":{"id":"msg_01Jmntc78Ht7e7NA7upNyL6Q","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"완료했습니다! 서버 초기화 시 적용되는 기본 시스템 프롬프트를 설정했습니다.\n\n**적용된 기능:**\n\n1. **기본 시스템 프롬프트**: 요청하신 내용이 서버 상수로 정의됨\n2. **자동 기본값 적용**:\n   - indicator 미지정 시 자동으로 \"keyword\"로 설정\n   - limit을 항상 최대값으로 설정 (darkweb/telegram: 100, 기타: 50)\n3. **응답에 시스템 동작 표시**: 모든 도구 호출 결과에 Neo 시스템 동작이 활성화되었음을 표시\n4. **페이지네이션 안내**: 모든 결과 끝에 다음 페이지 탐색 여부를 묻는 메시지 추가\n\n이제 서버를 시작하면 Neo의 기본 동작 방식이 자동으로 적용됩니다."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":408,"cache_read_input_tokens":34677,"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CR8Bzc6T1SB6pS4qiHZYB","type":"assistant","uuid":"f464ef55-d85f-4f02-b837-b6ff957dee94","timestamp":"2025-07-15T04:41:24.852Z"}
