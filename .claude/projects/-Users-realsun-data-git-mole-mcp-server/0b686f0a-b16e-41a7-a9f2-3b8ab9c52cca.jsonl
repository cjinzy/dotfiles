{"parentUuid":null,"isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"0b686f0a-b16e-41a7-a9f2-3b8ab9c52cca","version":"1.0.57","gitBranch":"main","type":"user","message":{"role":"user","content":"apply_default_behavior  함수를 좀 더 디테일하게 수정하고싶은데, 저기에 prompt도 넣을 수 있나?"},"uuid":"ab9f7d1e-4829-4b53-8e01-d2f1b791735e","timestamp":"2025-07-22T10:09:13.612Z"}
{"type":"summary","summary":"Refactoring MCP Tool Calls to Resource-Based Responses","leafUuid":"5d2745be-e1fd-4042-b378-550906c12934"}
{"parentUuid":"ab9f7d1e-4829-4b53-8e01-d2f1b791735e","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"0b686f0a-b16e-41a7-a9f2-3b8ab9c52cca","version":"1.0.57","gitBranch":"main","message":{"id":"msg_01EYwK2unSM9PgAFhvYPwGua","type":"message","role":"assistant","model":"claude-opus-4-20250514","content":[{"type":"text","text":"네, `apply_default_behavior` 함수를 수정해서 prompt를 추가할 수 있습니다. 먼저 현재 구조를 확인해보겠습니다."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":14296,"cache_read_input_tokens":0,"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CRMsfT1BUk3UqUHK6TBte","type":"assistant","uuid":"05605e1f-7b26-4a8f-ad83-110cc312deec","timestamp":"2025-07-22T10:09:17.912Z"}
{"parentUuid":"05605e1f-7b26-4a8f-ad83-110cc312deec","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"0b686f0a-b16e-41a7-a9f2-3b8ab9c52cca","version":"1.0.57","gitBranch":"main","message":{"id":"msg_01EYwK2unSM9PgAFhvYPwGua","type":"message","role":"assistant","model":"claude-opus-4-20250514","content":[{"type":"tool_use","id":"toolu_019muaASKe2YV6p9c9ybzGmm","name":"Read","input":{"file_path":"/Users/realsun/data/git/mole-mcp-server/src/stealthmole_mcp/server.py","offset":1,"limit":50}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":14296,"cache_read_input_tokens":0,"output_tokens":175,"service_tier":"standard"}},"requestId":"req_011CRMsfT1BUk3UqUHK6TBte","type":"assistant","uuid":"517dffd1-9cfe-4734-acd4-bf1d229689e2","timestamp":"2025-07-22T10:09:19.551Z"}
{"parentUuid":"517dffd1-9cfe-4734-acd4-bf1d229689e2","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"0b686f0a-b16e-41a7-a9f2-3b8ab9c52cca","version":"1.0.57","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019muaASKe2YV6p9c9ybzGmm","type":"tool_result","content":"     1→\"\"\"StealthMole MCP Server implementation.\"\"\"\n     2→\n     3→import asyncio\n     4→import os\n     5→import sys\n     6→from typing import Any, Optional, Sequence\n     7→\n     8→from click import prompt\n     9→from dotenv import load_dotenv\n    10→from mcp.server import NotificationOptions, Server\n    11→from mcp.server.models import InitializationOptions\n    12→from mcp.server.stdio import stdio_server\n    13→from mcp.types import (\n    14→    GetPromptResult,\n    15→    Prompt,\n    16→    PromptArgument,\n    17→    PromptMessage,\n    18→    Resource,\n    19→    TextContent,\n    20→    Tool,\n    21→)\n    22→from pydantic import AnyUrl\n    23→\n    24→from .tools import *\n    25→\n    26→load_dotenv()\n    27→\n    28→prompts_path = os.path.join(os.path.dirname(__file__), \"prompt\")\n    29→\n    30→server: Server = Server(\n    31→    \"stealthmole-mcp\",\n    32→    \"250715\",\n    33→)\n    34→\n    35→\n    36→@server.list_resources()\n    37→async def handle_list_resources() -> list[Resource]:\n    38→    \"\"\"List available resources.\"\"\"\n    39→    return []\n    40→\n    41→\n    42→@server.read_resource()\n    43→async def handle_read_resource(uri: AnyUrl) -> str:\n    44→    \"\"\"Read a specific resource.\"\"\"\n    45→    raise ValueError(f\"Unknown resource: {uri}\")\n    46→\n    47→\n    48→@server.list_prompts()\n    49→async def handle_list_prompts() -> list[Prompt]:\n    50→    \"\"\"List available prompts.\"\"\"\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"3ddbc857-0f11-4f72-b94c-dbbe3e909705","timestamp":"2025-07-22T10:09:19.577Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/realsun/data/git/mole-mcp-server/src/stealthmole_mcp/server.py","content":"\"\"\"StealthMole MCP Server implementation.\"\"\"\n\nimport asyncio\nimport os\nimport sys\nfrom typing import Any, Optional, Sequence\n\nfrom click import prompt\nfrom dotenv import load_dotenv\nfrom mcp.server import NotificationOptions, Server\nfrom mcp.server.models import InitializationOptions\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import (\n    GetPromptResult,\n    Prompt,\n    PromptArgument,\n    PromptMessage,\n    Resource,\n    TextContent,\n    Tool,\n)\nfrom pydantic import AnyUrl\n\nfrom .tools import *\n\nload_dotenv()\n\nprompts_path = os.path.join(os.path.dirname(__file__), \"prompt\")\n\nserver: Server = Server(\n    \"stealthmole-mcp\",\n    \"250715\",\n)\n\n\n@server.list_resources()\nasync def handle_list_resources() -> list[Resource]:\n    \"\"\"List available resources.\"\"\"\n    return []\n\n\n@server.read_resource()\nasync def handle_read_resource(uri: AnyUrl) -> str:\n    \"\"\"Read a specific resource.\"\"\"\n    raise ValueError(f\"Unknown resource: {uri}\")\n\n\n@server.list_prompts()\nasync def handle_list_prompts() -> list[Prompt]:\n    \"\"\"List available prompts.\"\"\"","numLines":50,"startLine":1,"totalLines":914}}}
{"parentUuid":"3ddbc857-0f11-4f72-b94c-dbbe3e909705","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"0b686f0a-b16e-41a7-a9f2-3b8ab9c52cca","version":"1.0.57","gitBranch":"main","message":{"id":"msg_01Kuxyd5QHz6uo9BdeQCSmJm","type":"message","role":"assistant","model":"claude-opus-4-20250514","content":[{"type":"tool_use","id":"toolu_01VS7AedjpEoaEWfMZWve6iB","name":"Grep","input":{"pattern":"apply_default_behavior","path":"/Users/realsun/data/git/mole-mcp-server/src/stealthmole_mcp","output_mode":"content","-n":true}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":728,"cache_read_input_tokens":14296,"output_tokens":137,"service_tier":"standard"}},"requestId":"req_011CRMsfsaYLdT72pWzq5LLv","type":"assistant","uuid":"c26cf979-874e-46d0-b8f7-8c23668edf1d","timestamp":"2025-07-22T10:09:24.211Z"}
{"parentUuid":"c26cf979-874e-46d0-b8f7-8c23668edf1d","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"0b686f0a-b16e-41a7-a9f2-3b8ab9c52cca","version":"1.0.57","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VS7AedjpEoaEWfMZWve6iB","type":"tool_result","content":"/Users/realsun/data/git/mole-mcp-server/src/stealthmole_mcp/server.py:665:def apply_default_behavior(name: str, arguments: dict[str, Any]) -> dict[str, Any]:\n/Users/realsun/data/git/mole-mcp-server/src/stealthmole_mcp/server.py:694:    arguments = apply_default_behavior(name, arguments)"}]},"uuid":"66d508c0-fa91-45f3-811e-bfc87e289a25","timestamp":"2025-07-22T10:09:24.247Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"/Users/realsun/data/git/mole-mcp-server/src/stealthmole_mcp/server.py:665:def apply_default_behavior(name: str, arguments: dict[str, Any]) -> dict[str, Any]:\n/Users/realsun/data/git/mole-mcp-server/src/stealthmole_mcp/server.py:694:    arguments = apply_default_behavior(name, arguments)","numLines":2}}
{"parentUuid":"66d508c0-fa91-45f3-811e-bfc87e289a25","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"0b686f0a-b16e-41a7-a9f2-3b8ab9c52cca","version":"1.0.57","gitBranch":"main","message":{"id":"msg_01LDgvSdHGzn8b7faYJkMMf4","type":"message","role":"assistant","model":"claude-opus-4-20250514","content":[{"type":"tool_use","id":"toolu_01VG2fhAXroRJatMbLzf98Qm","name":"Read","input":{"file_path":"/Users/realsun/data/git/mole-mcp-server/src/stealthmole_mcp/server.py","offset":665,"limit":35}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":258,"cache_read_input_tokens":15024,"output_tokens":118,"service_tier":"standard"}},"requestId":"req_011CRMsgDRPruhbEa3e8SvWc","type":"assistant","uuid":"21886cfc-2b61-41ac-aebf-a032c4561685","timestamp":"2025-07-22T10:09:28.083Z"}
{"parentUuid":"21886cfc-2b61-41ac-aebf-a032c4561685","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"0b686f0a-b16e-41a7-a9f2-3b8ab9c52cca","version":"1.0.57","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VG2fhAXroRJatMbLzf98Qm","type":"tool_result","content":"   665→def apply_default_behavior(name: str, arguments: dict[str, Any]) -> dict[str, Any]:\n   666→    \"\"\"Apply default behavior rules to tool arguments.\"\"\"\n   667→    if \"limit\" in arguments:\n   668→        if name in [\"search_darkweb\", \"search_telegram\"]:\n   669→            arguments[\"limit\"] = 10\n   670→        elif name in [\n   671→            \"search_credentials\",\n   672→            \"search_ransomware\",\n   673→            \"search_compromised_dataset\",\n   674→            \"search_combo_binder\",\n   675→            \"search_ulp_binder\",\n   676→            \"search_government_monitoring\",\n   677→            \"search_leaked_monitoring\",\n   678→        ]:\n   679→            arguments[\"limit\"] = 50\n   680→\n   681→    # Handle indicator defaults for search tools\n   682→    if name in [\"search_darkweb\", \"search_telegram\"]:\n   683→        if \"indicator\" not in arguments or not arguments[\"indicator\"]:\n   684→            arguments[\"indicator\"] = \"keyword\"\n   685→\n   686→    return arguments\n   687→\n   688→\n   689→@server.call_tool()\n   690→async def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:\n   691→    \"\"\"Handle tool calls with default behavior applied.\"\"\"\n   692→\n   693→    # Apply default behavior rules\n   694→    arguments = apply_default_behavior(name, arguments)\n   695→\n   696→    try:\n   697→        if name == \"search_darkweb\":\n   698→            result = await search_darkweb(\n   699→                indicator=arguments[\"indicator\"],\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"207ae48d-6525-43ab-a019-49bfdcfc9635","timestamp":"2025-07-22T10:09:28.107Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/realsun/data/git/mole-mcp-server/src/stealthmole_mcp/server.py","content":"def apply_default_behavior(name: str, arguments: dict[str, Any]) -> dict[str, Any]:\n    \"\"\"Apply default behavior rules to tool arguments.\"\"\"\n    if \"limit\" in arguments:\n        if name in [\"search_darkweb\", \"search_telegram\"]:\n            arguments[\"limit\"] = 10\n        elif name in [\n            \"search_credentials\",\n            \"search_ransomware\",\n            \"search_compromised_dataset\",\n            \"search_combo_binder\",\n            \"search_ulp_binder\",\n            \"search_government_monitoring\",\n            \"search_leaked_monitoring\",\n        ]:\n            arguments[\"limit\"] = 50\n\n    # Handle indicator defaults for search tools\n    if name in [\"search_darkweb\", \"search_telegram\"]:\n        if \"indicator\" not in arguments or not arguments[\"indicator\"]:\n            arguments[\"indicator\"] = \"keyword\"\n\n    return arguments\n\n\n@server.call_tool()\nasync def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:\n    \"\"\"Handle tool calls with default behavior applied.\"\"\"\n\n    # Apply default behavior rules\n    arguments = apply_default_behavior(name, arguments)\n\n    try:\n        if name == \"search_darkweb\":\n            result = await search_darkweb(\n                indicator=arguments[\"indicator\"],","numLines":35,"startLine":665,"totalLines":914}}}
{"parentUuid":"207ae48d-6525-43ab-a019-49bfdcfc9635","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"0b686f0a-b16e-41a7-a9f2-3b8ab9c52cca","version":"1.0.57","gitBranch":"main","message":{"id":"msg_01X94ScHHkQq45pQdZhTbQ5j","type":"message","role":"assistant","model":"claude-opus-4-20250514","content":[{"type":"tool_use","id":"toolu_01P2qYB71mczsLbiLj4bDPzx","name":"TodoWrite","input":{"todos":[{"content":"apply_default_behavior 함수에 prompt 파라미터 추가 및 로직 구현","status":"in_progress","priority":"high","id":"1"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":624,"cache_read_input_tokens":15282,"output_tokens":120,"service_tier":"standard"}},"requestId":"req_011CRMsgWAThfZVVJxzTcGhZ","type":"assistant","uuid":"6e7ef975-eeaa-46ec-919f-da3d7e9c9c5e","timestamp":"2025-07-22T10:09:32.872Z"}
{"parentUuid":"6e7ef975-eeaa-46ec-919f-da3d7e9c9c5e","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"0b686f0a-b16e-41a7-a9f2-3b8ab9c52cca","version":"1.0.57","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01P2qYB71mczsLbiLj4bDPzx","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"e5a83a68-26b0-43d5-9ca7-bc08aa495d10","timestamp":"2025-07-22T10:09:32.920Z","toolUseResult":{"oldTodos":[],"newTodos":[{"content":"apply_default_behavior 함수에 prompt 파라미터 추가 및 로직 구현","status":"in_progress","priority":"high","id":"1"}]}}
{"parentUuid":"e5a83a68-26b0-43d5-9ca7-bc08aa495d10","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"0b686f0a-b16e-41a7-a9f2-3b8ab9c52cca","version":"1.0.57","gitBranch":"main","message":{"id":"msg_01Pw3w57afYnYkQJA3woLtAM","type":"message","role":"assistant","model":"claude-opus-4-20250514","content":[{"type":"text","text":"네, `apply_default_behavior` 함수에 prompt를 추가할 수 있습니다. 함수를 수정해보겠습니다:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":288,"cache_read_input_tokens":15906,"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CRMsgrhjQa67v43FcZNzN","type":"assistant","uuid":"e1b2a3f6-4579-4c1c-83f0-b9a0a60d2b23","timestamp":"2025-07-22T10:09:36.467Z"}
{"parentUuid":"e1b2a3f6-4579-4c1c-83f0-b9a0a60d2b23","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"0b686f0a-b16e-41a7-a9f2-3b8ab9c52cca","version":"1.0.57","gitBranch":"main","message":{"id":"msg_01Pw3w57afYnYkQJA3woLtAM","type":"message","role":"assistant","model":"claude-opus-4-20250514","content":[{"type":"tool_use","id":"toolu_01LjaFWVcjFxzniRz9rVURXG","name":"Edit","input":{"file_path":"/Users/realsun/data/git/mole-mcp-server/src/stealthmole_mcp/server.py","old_string":"def apply_default_behavior(name: str, arguments: dict[str, Any]) -> dict[str, Any]:\n    \"\"\"Apply default behavior rules to tool arguments.\"\"\"\n    if \"limit\" in arguments:\n        if name in [\"search_darkweb\", \"search_telegram\"]:\n            arguments[\"limit\"] = 10\n        elif name in [\n            \"search_credentials\",\n            \"search_ransomware\",\n            \"search_compromised_dataset\",\n            \"search_combo_binder\",\n            \"search_ulp_binder\",\n            \"search_government_monitoring\",\n            \"search_leaked_monitoring\",\n        ]:\n            arguments[\"limit\"] = 50\n\n    # Handle indicator defaults for search tools\n    if name in [\"search_darkweb\", \"search_telegram\"]:\n        if \"indicator\" not in arguments or not arguments[\"indicator\"]:\n            arguments[\"indicator\"] = \"keyword\"\n\n    return arguments","new_string":"def apply_default_behavior(name: str, arguments: dict[str, Any], prompt: Optional[str] = None) -> dict[str, Any]:\n    \"\"\"Apply default behavior rules to tool arguments based on tool name and optional prompt context.\n    \n    Args:\n        name: The tool name being called\n        arguments: The original arguments dictionary\n        prompt: Optional prompt context to influence behavior\n        \n    Returns:\n        Modified arguments dictionary with defaults applied\n    \"\"\"\n    # Create a copy to avoid mutating the original\n    modified_args = arguments.copy()\n    \n    # Apply limit defaults based on tool type\n    if \"limit\" in modified_args:\n        if name in [\"search_darkweb\", \"search_telegram\"]:\n            # For general searches, use smaller limit unless prompt suggests otherwise\n            if prompt and (\"detailed\" in prompt.lower() or \"comprehensive\" in prompt.lower()):\n                modified_args[\"limit\"] = 20\n            else:\n                modified_args[\"limit\"] = 10\n        elif name in [\n            \"search_credentials\",\n            \"search_ransomware\", \n            \"search_compromised_dataset\",\n            \"search_combo_binder\",\n            \"search_ulp_binder\",\n            \"search_government_monitoring\",\n            \"search_leaked_monitoring\",\n        ]:\n            # For sensitive data searches, use larger limit by default\n            if prompt and \"quick\" in prompt.lower():\n                modified_args[\"limit\"] = 20\n            else:\n                modified_args[\"limit\"] = 50\n\n    # Handle indicator defaults for search tools\n    if name in [\"search_darkweb\", \"search_telegram\"]:\n        if \"indicator\" not in modified_args or not modified_args[\"indicator\"]:\n            # Default to keyword search unless prompt suggests otherwise\n            if prompt:\n                if \"domain\" in prompt.lower():\n                    modified_args[\"indicator\"] = \"domain\"\n                elif \"ip\" in prompt.lower() or \"address\" in prompt.lower():\n                    modified_args[\"indicator\"] = \"ip\"\n                elif \"email\" in prompt.lower():\n                    modified_args[\"indicator\"] = \"email\"\n                else:\n                    modified_args[\"indicator\"] = \"keyword\"\n            else:\n                modified_args[\"indicator\"] = \"keyword\"\n    \n    # Add date range defaults based on prompt context\n    if prompt and \"start_date\" not in modified_args:\n        if \"recent\" in prompt.lower() or \"latest\" in prompt.lower():\n            # Set start_date to 7 days ago for recent searches\n            from datetime import datetime, timedelta\n            start_date = (datetime.now() - timedelta(days=7)).strftime(\"%Y-%m-%d\")\n            modified_args[\"start_date\"] = start_date\n        elif \"last month\" in prompt.lower():\n            from datetime import datetime, timedelta\n            start_date = (datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%d\")\n            modified_args[\"start_date\"] = start_date\n    \n    return modified_args"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":288,"cache_read_input_tokens":15906,"output_tokens":1100,"service_tier":"standard"}},"requestId":"req_011CRMsgrhjQa67v43FcZNzN","type":"assistant","uuid":"e8a9ba79-214f-4ac3-bc28-8b1ca2a5364c","timestamp":"2025-07-22T10:09:51.919Z"}
{"parentUuid":"e8a9ba79-214f-4ac3-bc28-8b1ca2a5364c","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"0b686f0a-b16e-41a7-a9f2-3b8ab9c52cca","version":"1.0.57","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LjaFWVcjFxzniRz9rVURXG","type":"tool_result","content":"The file /Users/realsun/data/git/mole-mcp-server/src/stealthmole_mcp/server.py has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   661→        traceback.print_exc(file=sys.stderr)\n   662→        return []\n   663→\n   664→\n   665→def apply_default_behavior(name: str, arguments: dict[str, Any], prompt: Optional[str] = None) -> dict[str, Any]:\n   666→    \"\"\"Apply default behavior rules to tool arguments based on tool name and optional prompt context.\n   667→    \n   668→    Args:\n   669→        name: The tool name being called\n   670→        arguments: The original arguments dictionary\n   671→        prompt: Optional prompt context to influence behavior\n   672→        \n   673→    Returns:\n   674→        Modified arguments dictionary with defaults applied\n   675→    \"\"\"\n   676→    # Create a copy to avoid mutating the original\n   677→    modified_args = arguments.copy()\n   678→    \n   679→    # Apply limit defaults based on tool type\n   680→    if \"limit\" in modified_args:\n   681→        if name in [\"search_darkweb\", \"search_telegram\"]:\n   682→            # For general searches, use smaller limit unless prompt suggests otherwise\n   683→            if prompt and (\"detailed\" in prompt.lower() or \"comprehensive\" in prompt.lower()):\n   684→                modified_args[\"limit\"] = 20\n   685→            else:\n   686→                modified_args[\"limit\"] = 10\n   687→        elif name in [\n   688→            \"search_credentials\",\n   689→            \"search_ransomware\", \n   690→            \"search_compromised_dataset\",\n   691→            \"search_combo_binder\",\n   692→            \"search_ulp_binder\",\n   693→            \"search_government_monitoring\",\n   694→            \"search_leaked_monitoring\",\n   695→        ]:\n   696→            # For sensitive data searches, use larger limit by default\n   697→            if prompt and \"quick\" in prompt.lower():\n   698→                modified_args[\"limit\"] = 20\n   699→            else:\n   700→                modified_args[\"limit\"] = 50\n   701→\n   702→    # Handle indicator defaults for search tools\n   703→    if name in [\"search_darkweb\", \"search_telegram\"]:\n   704→        if \"indicator\" not in modified_args or not modified_args[\"indicator\"]:\n   705→            # Default to keyword search unless prompt suggests otherwise\n   706→            if prompt:\n   707→                if \"domain\" in prompt.lower():\n   708→                    modified_args[\"indicator\"] = \"domain\"\n   709→                elif \"ip\" in prompt.lower() or \"address\" in prompt.lower():\n   710→                    modified_args[\"indicator\"] = \"ip\"\n   711→                elif \"email\" in prompt.lower():\n   712→                    modified_args[\"indicator\"] = \"email\"\n   713→                else:\n   714→                    modified_args[\"indicator\"] = \"keyword\"\n   715→            else:\n   716→                modified_args[\"indicator\"] = \"keyword\"\n   717→    \n   718→    # Add date range defaults based on prompt context\n   719→    if prompt and \"start_date\" not in modified_args:\n   720→        if \"recent\" in prompt.lower() or \"latest\" in prompt.lower():\n   721→            # Set start_date to 7 days ago for recent searches\n   722→            from datetime import datetime, timedelta\n   723→            start_date = (datetime.now() - timedelta(days=7)).strftime(\"%Y-%m-%d\")\n   724→            modified_args[\"start_date\"] = start_date\n   725→        elif \"last month\" in prompt.lower():\n   726→            from datetime import datetime, timedelta\n   727→            start_date = (datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%d\")\n   728→            modified_args[\"start_date\"] = start_date\n   729→    \n   730→    return modified_args\n   731→\n   732→\n   733→@server.call_tool()\n   734→async def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:"}]},"uuid":"0fcae166-a617-417f-b046-93ddb02faefb","timestamp":"2025-07-22T10:10:28.088Z","toolUseResult":{"filePath":"/Users/realsun/data/git/mole-mcp-server/src/stealthmole_mcp/server.py","oldString":"def apply_default_behavior(name: str, arguments: dict[str, Any]) -> dict[str, Any]:\n    \"\"\"Apply default behavior rules to tool arguments.\"\"\"\n    if \"limit\" in arguments:\n        if name in [\"search_darkweb\", \"search_telegram\"]:\n            arguments[\"limit\"] = 10\n        elif name in [\n            \"search_credentials\",\n            \"search_ransomware\",\n            \"search_compromised_dataset\",\n            \"search_combo_binder\",\n            \"search_ulp_binder\",\n            \"search_government_monitoring\",\n            \"search_leaked_monitoring\",\n        ]:\n            arguments[\"limit\"] = 50\n\n    # Handle indicator defaults for search tools\n    if name in [\"search_darkweb\", \"search_telegram\"]:\n        if \"indicator\" not in arguments or not arguments[\"indicator\"]:\n            arguments[\"indicator\"] = \"keyword\"\n\n    return arguments","newString":"def apply_default_behavior(name: str, arguments: dict[str, Any], prompt: Optional[str] = None) -> dict[str, Any]:\n    \"\"\"Apply default behavior rules to tool arguments based on tool name and optional prompt context.\n    \n    Args:\n        name: The tool name being called\n        arguments: The original arguments dictionary\n        prompt: Optional prompt context to influence behavior\n        \n    Returns:\n        Modified arguments dictionary with defaults applied\n    \"\"\"\n    # Create a copy to avoid mutating the original\n    modified_args = arguments.copy()\n    \n    # Apply limit defaults based on tool type\n    if \"limit\" in modified_args:\n        if name in [\"search_darkweb\", \"search_telegram\"]:\n            # For general searches, use smaller limit unless prompt suggests otherwise\n            if prompt and (\"detailed\" in prompt.lower() or \"comprehensive\" in prompt.lower()):\n                modified_args[\"limit\"] = 20\n            else:\n                modified_args[\"limit\"] = 10\n        elif name in [\n            \"search_credentials\",\n            \"search_ransomware\", \n            \"search_compromised_dataset\",\n            \"search_combo_binder\",\n            \"search_ulp_binder\",\n            \"search_government_monitoring\",\n            \"search_leaked_monitoring\",\n        ]:\n            # For sensitive data searches, use larger limit by default\n            if prompt and \"quick\" in prompt.lower():\n                modified_args[\"limit\"] = 20\n            else:\n                modified_args[\"limit\"] = 50\n\n    # Handle indicator defaults for search tools\n    if name in [\"search_darkweb\", \"search_telegram\"]:\n        if \"indicator\" not in modified_args or not modified_args[\"indicator\"]:\n            # Default to keyword search unless prompt suggests otherwise\n            if prompt:\n                if \"domain\" in prompt.lower():\n                    modified_args[\"indicator\"] = \"domain\"\n                elif \"ip\" in prompt.lower() or \"address\" in prompt.lower():\n                    modified_args[\"indicator\"] = \"ip\"\n                elif \"email\" in prompt.lower():\n                    modified_args[\"indicator\"] = \"email\"\n                else:\n                    modified_args[\"indicator\"] = \"keyword\"\n            else:\n                modified_args[\"indicator\"] = \"keyword\"\n    \n    # Add date range defaults based on prompt context\n    if prompt and \"start_date\" not in modified_args:\n        if \"recent\" in prompt.lower() or \"latest\" in prompt.lower():\n            # Set start_date to 7 days ago for recent searches\n            from datetime import datetime, timedelta\n            start_date = (datetime.now() - timedelta(days=7)).strftime(\"%Y-%m-%d\")\n            modified_args[\"start_date\"] = start_date\n        elif \"last month\" in prompt.lower():\n            from datetime import datetime, timedelta\n            start_date = (datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%d\")\n            modified_args[\"start_date\"] = start_date\n    \n    return modified_args","originalFile":"\"\"\"StealthMole MCP Server implementation.\"\"\"\n\nimport asyncio\nimport os\nimport sys\nfrom typing import Any, Optional, Sequence\n\nfrom click import prompt\nfrom dotenv import load_dotenv\nfrom mcp.server import NotificationOptions, Server\nfrom mcp.server.models import InitializationOptions\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import (\n    GetPromptResult,\n    Prompt,\n    PromptArgument,\n    PromptMessage,\n    Resource,\n    TextContent,\n    Tool,\n)\nfrom pydantic import AnyUrl\n\nfrom .tools import *\n\nload_dotenv()\n\nprompts_path = os.path.join(os.path.dirname(__file__), \"prompt\")\n\nserver: Server = Server(\n    \"stealthmole-mcp\",\n    \"250715\",\n)\n\n\n@server.list_resources()\nasync def handle_list_resources() -> list[Resource]:\n    \"\"\"List available resources.\"\"\"\n    return []\n\n\n@server.read_resource()\nasync def handle_read_resource(uri: AnyUrl) -> str:\n    \"\"\"Read a specific resource.\"\"\"\n    raise ValueError(f\"Unknown resource: {uri}\")\n\n\n@server.list_prompts()\nasync def handle_list_prompts() -> list[Prompt]:\n    \"\"\"List available prompts.\"\"\"\n    return [\n        Prompt(\n            name=\"stealthmole_default_prompt\",\n            description=\"Default behavior guidelines for StealthMole MCP\",\n            arguments=[\n                PromptArgument(\n                    name=\"context\",\n                    description=\"Current search context\",\n                    required=False,\n                )\n            ],\n        )\n    ]\n\n\n@server.get_prompt()\nasync def handle_get_prompt(\n    name: str, arguments: dict[str, str] | None = None\n) -> GetPromptResult:\n    \"\"\"Get a specific prompt.\"\"\"\n    if name == \"stealthmole_default_prompt\":\n        return GetPromptResult(\n            messages=[\n                PromptMessage(\n                    role=\"assistant\",\n                    content=TextContent(\n                        type=\"text\",\n                        text=open(f\"{prompts_path}/default_prompt.md\").read(),\n                    ),\n                )\n            ]\n        )\n    else:\n        raise ValueError(f\"Unknown prompt: {name}\")\n\n\n@server.list_tools()\nasync def handle_list_tools() -> list[Tool]:\n    \"\"\"List available StealthMole tools.\"\"\"\n    try:\n        print(\"Returning StealthMole tools list\", file=sys.stderr)\n        return [\n            Tool(\n                name=\"search_darkweb\",\n                description=\"Search dark web content for indicators like domains, IPs, emails, etc.\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type to search for\",\n                            \"enum\": [\n                                \"adsense\",\n                                \"analyticsid\",\n                                \"band\",\n                                \"bitcoin\",\n                                \"blueprint\",\n                                \"creditcard\",\n                                \"cve\",\n                                \"discord\",\n                                \"document\",\n                                \"domain\",\n                                \"email\",\n                                \"ethereum\",\n                                \"exefile\",\n                                \"facebook\",\n                                \"filehosting\",\n                                \"googledrive\",\n                                \"gps\",\n                                \"hash\",\n                                \"hashstring\",\n                                \"i2p\",\n                                \"i2purl\",\n                                \"id\",\n                                \"image\",\n                                \"instagram\",\n                                \"ioc\",\n                                \"ip\",\n                                \"kakaotalk\",\n                                \"keyword\",\n                                \"kssn\",\n                                \"leakedaudio\",\n                                \"leakedemailfile\",\n                                \"leakedvideo\",\n                                \"line\",\n                                \"linkedin\",\n                                \"malware\",\n                                \"monero\",\n                                \"otherfile\",\n                                \"pastebin\",\n                                \"pgp\",\n                                \"serverstatus\",\n                                \"session\",\n                                \"shorten\",\n                                \"sshkey\",\n                                \"sslkey\",\n                                \"tel\",\n                                \"telegram\",\n                                \"tor\",\n                                \"torurl\",\n                                \"twitter\",\n                                \"url\",\n                                \"iol\",\n                            ],\n                        },\n                        \"text\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search keyword or data to find. Supports AND, OR, NOT operators (max 3 OR, 5 total operators)\",\n                        },\n                        \"target\": {\n                            \"type\": \"string\",\n                            \"description\": \"Target type to search (default: 'all'). Use comma-separated values for multiple targets\",\n                            \"default\": \"all\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Ordering type\",\n                            \"enum\": [\"createDate\", \"value\"],\n                            \"default\": \"createDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\", \"text\"],\n                },\n            ),\n            Tool(\n                name=\"search_telegram\",\n                description=\"Search Telegram content for indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type to search for\",\n                            \"enum\": [\n                                \"band\",\n                                \"bitcoin\",\n                                \"creditcard\",\n                                \"cve\",\n                                \"discord\",\n                                \"document\",\n                                \"domain\",\n                                \"email\",\n                                \"ethereum\",\n                                \"exefile\",\n                                \"facebook\",\n                                \"filehosting\",\n                                \"googledrive\",\n                                \"gps\",\n                                \"hash\",\n                                \"hashstring\",\n                                \"i2p\",\n                                \"i2purl\",\n                                \"id\",\n                                \"image\",\n                                \"instagram\",\n                                \"ip\",\n                                \"kakaotalk\",\n                                \"keyword\",\n                                \"kssn\",\n                                \"line\",\n                                \"monero\",\n                                \"otherfile\",\n                                \"pastebin\",\n                                \"pgp\",\n                                \"tel\",\n                                \"session\",\n                                \"shorten\",\n                                \"telegram\",\n                                \"telegram.channel\",\n                                \"telegram.message\",\n                                \"telegram.user\",\n                                \"tor\",\n                                \"torurl\",\n                                \"tox\",\n                                \"twitter\",\n                                \"url\",\n                            ],\n                        },\n                        \"text\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search keyword or data to find. Supports AND, OR, NOT operators (max 3 OR, 5 total operators)\",\n                        },\n                        \"target\": {\n                            \"type\": \"string\",\n                            \"description\": \"Target type to search (default: 'all'). Use comma-separated values for multiple targets\",\n                            \"default\": \"all\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Ordering type\",\n                            \"enum\": [\"createDate\", \"value\"],\n                            \"default\": \"createDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\", \"text\"],\n                },\n            ),\n            Tool(\n                name=\"search_credentials\",\n                description=\"Search for leaked credentials using keywords or specific indicators (domain:, email:, id:, password:, after:, before:)\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - can use indicators like 'domain:example.com', 'email:user@domain.com', 'id:username', 'password:pass123', 'after:2023-01', 'before:2024-01' or plain keywords\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\n                                \"leakedDate\",\n                                \"domain\",\n                                \"email\",\n                                \"password\",\n                                \"leakedFrom\",\n                            ],\n                            \"default\": \"leakedDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                        \"start\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Filter data added to the system after start time (UTC timestamp)\",\n                        },\n                        \"end\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Filter data added to the system before end time (UTC timestamp)\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_ransomware\",\n                description=\"Search ransomware monitoring data using torurl: or domain: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'torurl:site.onion' to search ransomware sites or 'domain:victim.com' to search victim websites. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"victim\", \"attackGroup\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"get_node_details\",\n                description=\"Get detailed information about a specific node\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"node_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Node ID to get details for\",\n                        },\n                        \"pid\": {\n                            \"type\": \"string\",\n                            \"description\": \"Parent node ID (optional)\",\n                        },\n                        \"data_from\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Import data source list (default: False)\",\n                            \"default\": False,\n                        },\n                        \"include_url\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Import included URL list (default: False)\",\n                            \"default\": False,\n                        },\n                        \"include_contents\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Include HTML source contents for torurl, i2purl, url (default: True)\",\n                            \"default\": True,\n                        },\n                    },\n                    \"required\": [\"service\", \"node_id\"],\n                },\n            ),\n            Tool(\n                name=\"get_targets\",\n                description=\"Get available search targets for a service and indicator\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type\",\n                        },\n                    },\n                    \"required\": [\"service\", \"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_data\",\n                description=\"Export search results in specified format\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"service\", \"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_compromised_dataset\",\n                description=\"Search compromised data set information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"get_compromised_dataset_node\",\n                description=\"Get detailed compromised data set node information (Cyber Security Edition required)\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"node_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Node ID to get details for\",\n                        }\n                    },\n                    \"required\": [\"node_id\"],\n                },\n            ),\n            Tool(\n                name=\"search_combo_binder\",\n                description=\"Search leaked ID/Password combo information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_ulp_binder\",\n                description=\"Search URL-Login-Password combination information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_government_monitoring\",\n                description=\"Search government sector threat monitoring data using url: or id: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'url:hackersite.com' to search threat event URLs or 'id:hacker123' to search actor IDs. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"title\", \"author\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_leaked_monitoring\",\n                description=\"Search enterprise sector threat monitoring data using url: or id: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'url:hackersite.com' to search threat event URLs or 'id:hacker123' to search actor IDs. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"title\", \"author\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"download_file\",\n                description=\"Download file by hash from dt or tt service\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt or tt)\",\n                            \"enum\": [\"dt\", \"tt\"],\n                        },\n                        \"file_hash\": {\n                            \"type\": \"string\",\n                            \"description\": \"File hash to download\",\n                        },\n                    },\n                    \"required\": [\"service\", \"file_hash\"],\n                },\n            ),\n            Tool(\n                name=\"search_pagination\",\n                description=\"Pagination search using search ID for dt or tt service\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt or tt)\",\n                            \"enum\": [\"dt\", \"tt\"],\n                        },\n                        \"search_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search ID from previous search\",\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                    },\n                    \"required\": [\"service\", \"search_id\"],\n                },\n            ),\n            Tool(\n                name=\"get_user_quotas\",\n                description=\"Get API usage quotas by service\",\n                inputSchema={\"type\": \"object\", \"properties\": {}, \"required\": []},\n            ),\n        ]\n    except Exception as e:\n        print(f\"Error in handle_list_tools: {e}\", file=sys.stderr)\n        import traceback\n\n        traceback.print_exc(file=sys.stderr)\n        return []\n\n\ndef apply_default_behavior(name: str, arguments: dict[str, Any]) -> dict[str, Any]:\n    \"\"\"Apply default behavior rules to tool arguments.\"\"\"\n    if \"limit\" in arguments:\n        if name in [\"search_darkweb\", \"search_telegram\"]:\n            arguments[\"limit\"] = 10\n        elif name in [\n            \"search_credentials\",\n            \"search_ransomware\",\n            \"search_compromised_dataset\",\n            \"search_combo_binder\",\n            \"search_ulp_binder\",\n            \"search_government_monitoring\",\n            \"search_leaked_monitoring\",\n        ]:\n            arguments[\"limit\"] = 50\n\n    # Handle indicator defaults for search tools\n    if name in [\"search_darkweb\", \"search_telegram\"]:\n        if \"indicator\" not in arguments or not arguments[\"indicator\"]:\n            arguments[\"indicator\"] = \"keyword\"\n\n    return arguments\n\n\n@server.call_tool()\nasync def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:\n    \"\"\"Handle tool calls with default behavior applied.\"\"\"\n\n    # Apply default behavior rules\n    arguments = apply_default_behavior(name, arguments)\n\n    try:\n        if name == \"search_darkweb\":\n            result = await search_darkweb(\n                indicator=arguments[\"indicator\"],\n                text=arguments[\"text\"],\n                target=arguments.get(\"target\", \"all\"),\n                limit=arguments.get(\"limit\", 50),\n                orderType=arguments.get(\"orderType\", \"createDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_telegram\":\n            result = await search_telegram(\n                indicator=arguments[\"indicator\"],\n                text=arguments[\"text\"],\n                target=arguments.get(\"target\", \"all\"),\n                limit=arguments.get(\"limit\", 50),\n                orderType=arguments.get(\"orderType\", \"createDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_credentials\":\n            result = await search_credentials(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"leakedDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n                start=arguments.get(\"start\"),\n                end=arguments.get(\"end\"),\n            )\n        elif name == \"search_ransomware\":\n            result = await search_ransomware(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"get_node_details\":\n            result = await get_node_details(\n                service=arguments[\"service\"],\n                node_id=arguments[\"node_id\"],\n                pid=arguments.get(\"pid\"),\n                data_from=arguments.get(\"data_from\", False),\n                include_url=arguments.get(\"include_url\", False),\n                include_contents=arguments.get(\"include_contents\", True),\n            )\n        elif name == \"get_targets\":\n            result = await get_targets(\n                service=arguments[\"service\"], indicator=arguments[\"indicator\"]\n            )\n        elif name == \"export_data\":\n            result = await export_data(\n                service=arguments[\"service\"],\n                indicator=arguments[\"indicator\"],\n                format=arguments.get(\"format\", \"json\"),\n            )\n        elif name == \"search_compromised_dataset\":\n            result = await search_compromised_dataset(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"get_compromised_dataset_node\":\n            result = await get_compromised_dataset_node(\n                node_id=arguments[\"node_id\"]\n            )\n        elif name == \"search_combo_binder\":\n            result = await search_combo_binder(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"search_ulp_binder\":\n            result = await search_ulp_binder(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"search_government_monitoring\":\n            result = await search_government_monitoring(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_leaked_monitoring\":\n            result = await search_leaked_monitoring(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"download_file\":\n            file_content = await download_file(\n                service=arguments[\"service\"], file_hash=arguments[\"file_hash\"]\n            )\n            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"Downloaded file {arguments['file_hash']} from {arguments['service']} service. File size: {len(file_content)} bytes\",\n                )\n            ]\n        elif name == \"search_pagination\":\n            result = await search_pagination(\n                service=arguments[\"service\"],\n                search_id=arguments[\"search_id\"],\n                cursor=arguments.get(\"cursor\", 0),\n                limit=arguments.get(\"limit\", 50),\n            )\n        elif name == \"get_user_quotas\":\n            result = await get_user_quotas()\n        else:\n            return [TextContent(type=\"text\", text=f\"Unknown tool: {name}\")]\n\n        # Format response\n        response_text = f\"StealthMole API Results:{result}\"\n        return [TextContent(type=\"text\", text=response_text)]\n\n    except asyncio.TimeoutError:\n        return [\n            TextContent(\n                type=\"text\",\n                text=\"Request timed out. The API request took too long to complete.\",\n            )\n        ]\n    except Exception as e:\n        error_msg = str(e)\n        if \"timeout\" in error_msg.lower():\n            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"Timeout error: {error_msg}. Try reducing the result limit or check your network connection.\",\n                )\n            ]\n        return [\n            TextContent(\n                type=\"text\",\n                text=f\"Error calling StealthMole API: {error_msg}\",\n            )\n        ]\n\n\nasync def run_server():\n    \"\"\"Run the MCP server.\"\"\"\n    try:\n        print(\"Starting StealthMole MCP server...\", file=sys.stderr)\n\n        # Check environment variables\n        access_key = os.getenv(\"STEALTHMOLE_ACCESS_KEY\")\n        secret_key = os.getenv(\"STEALTHMOLE_SECRET_KEY\")\n\n        print(f\"Access key: {'SET' if access_key else 'NOT SET'}\", file=sys.stderr)\n        print(f\"Secret key: {'SET' if secret_key else 'NOT SET'}\", file=sys.stderr)\n\n        if not access_key or not secret_key:\n            print(\n                \"Warning: STEALTHMOLE_ACCESS_KEY and STEALTHMOLE_SECRET_KEY environment variables not set\",\n                file=sys.stderr,\n            )\n            print(\"MCP server will start but tools will not function\", file=sys.stderr)\n        else:\n            try:\n                # API 연결 테스트 (타임아웃 없이 간단히)\n                try:\n                    quotas = await get_user_quotas()\n                    print(\n                        f\"✓ API connection successful. Available quotas: {quotas}\",\n                        file=sys.stderr,\n                    )\n                except Exception as api_error:\n                    print(f\"Warning: API test failed: {api_error}\", file=sys.stderr)\n                    print(\"Continuing with server startup...\", file=sys.stderr)\n\n            except Exception as e:\n                print(\n                    f\"Warning: Error testing API connection: {e}\", file=sys.stderr\n                )\n                print(\n                    \"MCP server will start but tools may not function properly\",\n                    file=sys.stderr,\n                )\n                import traceback\n\n                traceback.print_exc(file=sys.stderr)\n\n        print(\"Creating stdio server...\", file=sys.stderr)\n        async with stdio_server() as (read_stream, write_stream):\n            print(\"Starting MCP server...\", file=sys.stderr)\n            try:\n                await server.run(\n                    read_stream,\n                    write_stream,\n                    InitializationOptions(\n                        server_name=\"stealthmole-mcp\",\n                        server_version=\"0.1.0\",\n                        capabilities=server.get_capabilities(\n                            notification_options=NotificationOptions(),\n                            experimental_capabilities={},\n                        ),\n                    ),\n                )\n                print(\"MCP server completed normally\", file=sys.stderr)\n            except Exception as e:\n                print(f\"Error in MCP server.run: {e}\", file=sys.stderr)\n                import traceback\n\n                traceback.print_exc(file=sys.stderr)\n                raise\n    except Exception as e:\n        print(f\"Error in run_server: {e}\", file=sys.stderr)\n        import traceback\n\n        traceback.print_exc(file=sys.stderr)\n\n\ndef main():\n    \"\"\"Main entry point for the MCP server.\"\"\"\n    asyncio.run(run_server())\n\n\nif __name__ == \"__main__\":\n    main()\n","structuredPatch":[{"oldStart":662,"oldLines":30,"newStart":662,"newLines":74,"lines":["         return []"," "," ","-def apply_default_behavior(name: str, arguments: dict[str, Any]) -> dict[str, Any]:","-    \"\"\"Apply default behavior rules to tool arguments.\"\"\"","-    if \"limit\" in arguments:","+def apply_default_behavior(name: str, arguments: dict[str, Any], prompt: Optional[str] = None) -> dict[str, Any]:","+    \"\"\"Apply default behavior rules to tool arguments based on tool name and optional prompt context.","+    ","+    Args:","+        name: The tool name being called","+        arguments: The original arguments dictionary","+        prompt: Optional prompt context to influence behavior","+        ","+    Returns:","+        Modified arguments dictionary with defaults applied","+    \"\"\"","+    # Create a copy to avoid mutating the original","+    modified_args = arguments.copy()","+    ","+    # Apply limit defaults based on tool type","+    if \"limit\" in modified_args:","         if name in [\"search_darkweb\", \"search_telegram\"]:","-            arguments[\"limit\"] = 10","+            # For general searches, use smaller limit unless prompt suggests otherwise","+            if prompt and (\"detailed\" in prompt.lower() or \"comprehensive\" in prompt.lower()):","+                modified_args[\"limit\"] = 20","+            else:","+                modified_args[\"limit\"] = 10","         elif name in [","             \"search_credentials\",","-            \"search_ransomware\",","+            \"search_ransomware\", ","             \"search_compromised_dataset\",","             \"search_combo_binder\",","             \"search_ulp_binder\",","             \"search_government_monitoring\",","             \"search_leaked_monitoring\",","         ]:","-            arguments[\"limit\"] = 50","+            # For sensitive data searches, use larger limit by default","+            if prompt and \"quick\" in prompt.lower():","+                modified_args[\"limit\"] = 20","+            else:","+                modified_args[\"limit\"] = 50"," ","     # Handle indicator defaults for search tools","     if name in [\"search_darkweb\", \"search_telegram\"]:","-        if \"indicator\" not in arguments or not arguments[\"indicator\"]:","-            arguments[\"indicator\"] = \"keyword\"","+        if \"indicator\" not in modified_args or not modified_args[\"indicator\"]:","+            # Default to keyword search unless prompt suggests otherwise","+            if prompt:","+                if \"domain\" in prompt.lower():","+                    modified_args[\"indicator\"] = \"domain\"","+                elif \"ip\" in prompt.lower() or \"address\" in prompt.lower():","+                    modified_args[\"indicator\"] = \"ip\"","+                elif \"email\" in prompt.lower():","+                    modified_args[\"indicator\"] = \"email\"","+                else:","+                    modified_args[\"indicator\"] = \"keyword\"","+            else:","+                modified_args[\"indicator\"] = \"keyword\"","+    ","+    # Add date range defaults based on prompt context","+    if prompt and \"start_date\" not in modified_args:","+        if \"recent\" in prompt.lower() or \"latest\" in prompt.lower():","+            # Set start_date to 7 days ago for recent searches","+            from datetime import datetime, timedelta","+            start_date = (datetime.now() - timedelta(days=7)).strftime(\"%Y-%m-%d\")","+            modified_args[\"start_date\"] = start_date","+        elif \"last month\" in prompt.lower():","+            from datetime import datetime, timedelta","+            start_date = (datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%d\")","+            modified_args[\"start_date\"] = start_date","+    ","+    return modified_args"," ","-    return arguments"," ","-"," @server.call_tool()"," async def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:","     \"\"\"Handle tool calls with default behavior applied.\"\"\""]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"0fcae166-a617-417f-b046-93ddb02faefb","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"0b686f0a-b16e-41a7-a9f2-3b8ab9c52cca","version":"1.0.57","gitBranch":"main","message":{"id":"msg_01M6tmVk3P5VbCiL5AxfDKQ4","type":"message","role":"assistant","model":"claude-opus-4-20250514","content":[{"type":"text","text":"이제 `handle_call_tool` 함수에서 prompt를 전달하도록 수정해야 합니다. 그런데 MCP 서버에서는 tool call 시 prompt를 직접 받지 않으므로, 다른 방법을 사용해야 합니다. 일단 현재 호출 부분을 수정하겠습니다:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":2173,"cache_read_input_tokens":16194,"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CRMskvkgArRn71Nxw1G9S","type":"assistant","uuid":"f0e095b1-6b77-47df-bc77-e73b4d9275ea","timestamp":"2025-07-22T10:10:33.720Z"}
{"parentUuid":"f0e095b1-6b77-47df-bc77-e73b4d9275ea","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"0b686f0a-b16e-41a7-a9f2-3b8ab9c52cca","version":"1.0.57","gitBranch":"main","message":{"id":"msg_01M6tmVk3P5VbCiL5AxfDKQ4","type":"message","role":"assistant","model":"claude-opus-4-20250514","content":[{"type":"tool_use","id":"toolu_0181fwyEa9NfpjQ1SesVq2KG","name":"Edit","input":{"file_path":"/Users/realsun/data/git/mole-mcp-server/src/stealthmole_mcp/server.py","old_string":"@server.call_tool()\nasync def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:\n    \"\"\"Handle tool calls with default behavior applied.\"\"\"\n\n    # Apply default behavior rules\n    arguments = apply_default_behavior(name, arguments)","new_string":"@server.call_tool()\nasync def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:\n    \"\"\"Handle tool calls with default behavior applied.\"\"\"\n\n    # Extract prompt from arguments if provided (for context-aware defaults)\n    prompt = arguments.pop(\"_prompt\", None) if \"_prompt\" in arguments else None\n    \n    # Apply default behavior rules with prompt context\n    arguments = apply_default_behavior(name, arguments, prompt)"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":2173,"cache_read_input_tokens":16194,"output_tokens":402,"service_tier":"standard"}},"requestId":"req_011CRMskvkgArRn71Nxw1G9S","type":"assistant","uuid":"ec706639-d6b8-4826-961c-1154c5ef0354","timestamp":"2025-07-22T10:10:38.641Z"}
{"parentUuid":"ec706639-d6b8-4826-961c-1154c5ef0354","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"0b686f0a-b16e-41a7-a9f2-3b8ab9c52cca","version":"1.0.57","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0181fwyEa9NfpjQ1SesVq2KG","type":"tool_result","content":"The file /Users/realsun/data/git/mole-mcp-server/src/stealthmole_mcp/server.py has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   729→    \n   730→    return modified_args\n   731→\n   732→\n   733→@server.call_tool()\n   734→async def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:\n   735→    \"\"\"Handle tool calls with default behavior applied.\"\"\"\n   736→\n   737→    # Extract prompt from arguments if provided (for context-aware defaults)\n   738→    prompt = arguments.pop(\"_prompt\", None) if \"_prompt\" in arguments else None\n   739→    \n   740→    # Apply default behavior rules with prompt context\n   741→    arguments = apply_default_behavior(name, arguments, prompt)\n   742→\n   743→    try:\n   744→        if name == \"search_darkweb\":\n   745→            result = await search_darkweb("}]},"uuid":"6ebd3038-a864-485f-ae10-21bb117e0bc2","timestamp":"2025-07-22T10:10:43.659Z","toolUseResult":{"filePath":"/Users/realsun/data/git/mole-mcp-server/src/stealthmole_mcp/server.py","oldString":"@server.call_tool()\nasync def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:\n    \"\"\"Handle tool calls with default behavior applied.\"\"\"\n\n    # Apply default behavior rules\n    arguments = apply_default_behavior(name, arguments)","newString":"@server.call_tool()\nasync def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:\n    \"\"\"Handle tool calls with default behavior applied.\"\"\"\n\n    # Extract prompt from arguments if provided (for context-aware defaults)\n    prompt = arguments.pop(\"_prompt\", None) if \"_prompt\" in arguments else None\n    \n    # Apply default behavior rules with prompt context\n    arguments = apply_default_behavior(name, arguments, prompt)","originalFile":"\"\"\"StealthMole MCP Server implementation.\"\"\"\n\nimport asyncio\nimport os\nimport sys\nfrom typing import Any, Optional, Sequence\n\nfrom click import prompt\nfrom dotenv import load_dotenv\nfrom mcp.server import NotificationOptions, Server\nfrom mcp.server.models import InitializationOptions\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import (\n    GetPromptResult,\n    Prompt,\n    PromptArgument,\n    PromptMessage,\n    Resource,\n    TextContent,\n    Tool,\n)\nfrom pydantic import AnyUrl\n\nfrom .tools import *\n\nload_dotenv()\n\nprompts_path = os.path.join(os.path.dirname(__file__), \"prompt\")\n\nserver: Server = Server(\n    \"stealthmole-mcp\",\n    \"250715\",\n)\n\n\n@server.list_resources()\nasync def handle_list_resources() -> list[Resource]:\n    \"\"\"List available resources.\"\"\"\n    return []\n\n\n@server.read_resource()\nasync def handle_read_resource(uri: AnyUrl) -> str:\n    \"\"\"Read a specific resource.\"\"\"\n    raise ValueError(f\"Unknown resource: {uri}\")\n\n\n@server.list_prompts()\nasync def handle_list_prompts() -> list[Prompt]:\n    \"\"\"List available prompts.\"\"\"\n    return [\n        Prompt(\n            name=\"stealthmole_default_prompt\",\n            description=\"Default behavior guidelines for StealthMole MCP\",\n            arguments=[\n                PromptArgument(\n                    name=\"context\",\n                    description=\"Current search context\",\n                    required=False,\n                )\n            ],\n        )\n    ]\n\n\n@server.get_prompt()\nasync def handle_get_prompt(\n    name: str, arguments: dict[str, str] | None = None\n) -> GetPromptResult:\n    \"\"\"Get a specific prompt.\"\"\"\n    if name == \"stealthmole_default_prompt\":\n        return GetPromptResult(\n            messages=[\n                PromptMessage(\n                    role=\"assistant\",\n                    content=TextContent(\n                        type=\"text\",\n                        text=open(f\"{prompts_path}/default_prompt.md\").read(),\n                    ),\n                )\n            ]\n        )\n    else:\n        raise ValueError(f\"Unknown prompt: {name}\")\n\n\n@server.list_tools()\nasync def handle_list_tools() -> list[Tool]:\n    \"\"\"List available StealthMole tools.\"\"\"\n    try:\n        print(\"Returning StealthMole tools list\", file=sys.stderr)\n        return [\n            Tool(\n                name=\"search_darkweb\",\n                description=\"Search dark web content for indicators like domains, IPs, emails, etc.\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type to search for\",\n                            \"enum\": [\n                                \"adsense\",\n                                \"analyticsid\",\n                                \"band\",\n                                \"bitcoin\",\n                                \"blueprint\",\n                                \"creditcard\",\n                                \"cve\",\n                                \"discord\",\n                                \"document\",\n                                \"domain\",\n                                \"email\",\n                                \"ethereum\",\n                                \"exefile\",\n                                \"facebook\",\n                                \"filehosting\",\n                                \"googledrive\",\n                                \"gps\",\n                                \"hash\",\n                                \"hashstring\",\n                                \"i2p\",\n                                \"i2purl\",\n                                \"id\",\n                                \"image\",\n                                \"instagram\",\n                                \"ioc\",\n                                \"ip\",\n                                \"kakaotalk\",\n                                \"keyword\",\n                                \"kssn\",\n                                \"leakedaudio\",\n                                \"leakedemailfile\",\n                                \"leakedvideo\",\n                                \"line\",\n                                \"linkedin\",\n                                \"malware\",\n                                \"monero\",\n                                \"otherfile\",\n                                \"pastebin\",\n                                \"pgp\",\n                                \"serverstatus\",\n                                \"session\",\n                                \"shorten\",\n                                \"sshkey\",\n                                \"sslkey\",\n                                \"tel\",\n                                \"telegram\",\n                                \"tor\",\n                                \"torurl\",\n                                \"twitter\",\n                                \"url\",\n                                \"iol\",\n                            ],\n                        },\n                        \"text\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search keyword or data to find. Supports AND, OR, NOT operators (max 3 OR, 5 total operators)\",\n                        },\n                        \"target\": {\n                            \"type\": \"string\",\n                            \"description\": \"Target type to search (default: 'all'). Use comma-separated values for multiple targets\",\n                            \"default\": \"all\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Ordering type\",\n                            \"enum\": [\"createDate\", \"value\"],\n                            \"default\": \"createDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\", \"text\"],\n                },\n            ),\n            Tool(\n                name=\"search_telegram\",\n                description=\"Search Telegram content for indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type to search for\",\n                            \"enum\": [\n                                \"band\",\n                                \"bitcoin\",\n                                \"creditcard\",\n                                \"cve\",\n                                \"discord\",\n                                \"document\",\n                                \"domain\",\n                                \"email\",\n                                \"ethereum\",\n                                \"exefile\",\n                                \"facebook\",\n                                \"filehosting\",\n                                \"googledrive\",\n                                \"gps\",\n                                \"hash\",\n                                \"hashstring\",\n                                \"i2p\",\n                                \"i2purl\",\n                                \"id\",\n                                \"image\",\n                                \"instagram\",\n                                \"ip\",\n                                \"kakaotalk\",\n                                \"keyword\",\n                                \"kssn\",\n                                \"line\",\n                                \"monero\",\n                                \"otherfile\",\n                                \"pastebin\",\n                                \"pgp\",\n                                \"tel\",\n                                \"session\",\n                                \"shorten\",\n                                \"telegram\",\n                                \"telegram.channel\",\n                                \"telegram.message\",\n                                \"telegram.user\",\n                                \"tor\",\n                                \"torurl\",\n                                \"tox\",\n                                \"twitter\",\n                                \"url\",\n                            ],\n                        },\n                        \"text\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search keyword or data to find. Supports AND, OR, NOT operators (max 3 OR, 5 total operators)\",\n                        },\n                        \"target\": {\n                            \"type\": \"string\",\n                            \"description\": \"Target type to search (default: 'all'). Use comma-separated values for multiple targets\",\n                            \"default\": \"all\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Ordering type\",\n                            \"enum\": [\"createDate\", \"value\"],\n                            \"default\": \"createDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\", \"text\"],\n                },\n            ),\n            Tool(\n                name=\"search_credentials\",\n                description=\"Search for leaked credentials using keywords or specific indicators (domain:, email:, id:, password:, after:, before:)\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - can use indicators like 'domain:example.com', 'email:user@domain.com', 'id:username', 'password:pass123', 'after:2023-01', 'before:2024-01' or plain keywords\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\n                                \"leakedDate\",\n                                \"domain\",\n                                \"email\",\n                                \"password\",\n                                \"leakedFrom\",\n                            ],\n                            \"default\": \"leakedDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                        \"start\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Filter data added to the system after start time (UTC timestamp)\",\n                        },\n                        \"end\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Filter data added to the system before end time (UTC timestamp)\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_ransomware\",\n                description=\"Search ransomware monitoring data using torurl: or domain: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'torurl:site.onion' to search ransomware sites or 'domain:victim.com' to search victim websites. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"victim\", \"attackGroup\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"get_node_details\",\n                description=\"Get detailed information about a specific node\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"node_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Node ID to get details for\",\n                        },\n                        \"pid\": {\n                            \"type\": \"string\",\n                            \"description\": \"Parent node ID (optional)\",\n                        },\n                        \"data_from\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Import data source list (default: False)\",\n                            \"default\": False,\n                        },\n                        \"include_url\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Import included URL list (default: False)\",\n                            \"default\": False,\n                        },\n                        \"include_contents\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Include HTML source contents for torurl, i2purl, url (default: True)\",\n                            \"default\": True,\n                        },\n                    },\n                    \"required\": [\"service\", \"node_id\"],\n                },\n            ),\n            Tool(\n                name=\"get_targets\",\n                description=\"Get available search targets for a service and indicator\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type\",\n                        },\n                    },\n                    \"required\": [\"service\", \"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_data\",\n                description=\"Export search results in specified format\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"service\", \"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_compromised_dataset\",\n                description=\"Search compromised data set information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"get_compromised_dataset_node\",\n                description=\"Get detailed compromised data set node information (Cyber Security Edition required)\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"node_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Node ID to get details for\",\n                        }\n                    },\n                    \"required\": [\"node_id\"],\n                },\n            ),\n            Tool(\n                name=\"search_combo_binder\",\n                description=\"Search leaked ID/Password combo information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_ulp_binder\",\n                description=\"Search URL-Login-Password combination information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_government_monitoring\",\n                description=\"Search government sector threat monitoring data using url: or id: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'url:hackersite.com' to search threat event URLs or 'id:hacker123' to search actor IDs. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"title\", \"author\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_leaked_monitoring\",\n                description=\"Search enterprise sector threat monitoring data using url: or id: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'url:hackersite.com' to search threat event URLs or 'id:hacker123' to search actor IDs. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"title\", \"author\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"download_file\",\n                description=\"Download file by hash from dt or tt service\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt or tt)\",\n                            \"enum\": [\"dt\", \"tt\"],\n                        },\n                        \"file_hash\": {\n                            \"type\": \"string\",\n                            \"description\": \"File hash to download\",\n                        },\n                    },\n                    \"required\": [\"service\", \"file_hash\"],\n                },\n            ),\n            Tool(\n                name=\"search_pagination\",\n                description=\"Pagination search using search ID for dt or tt service\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt or tt)\",\n                            \"enum\": [\"dt\", \"tt\"],\n                        },\n                        \"search_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search ID from previous search\",\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                    },\n                    \"required\": [\"service\", \"search_id\"],\n                },\n            ),\n            Tool(\n                name=\"get_user_quotas\",\n                description=\"Get API usage quotas by service\",\n                inputSchema={\"type\": \"object\", \"properties\": {}, \"required\": []},\n            ),\n        ]\n    except Exception as e:\n        print(f\"Error in handle_list_tools: {e}\", file=sys.stderr)\n        import traceback\n\n        traceback.print_exc(file=sys.stderr)\n        return []\n\n\ndef apply_default_behavior(name: str, arguments: dict[str, Any], prompt: Optional[str] = None) -> dict[str, Any]:\n    \"\"\"Apply default behavior rules to tool arguments based on tool name and optional prompt context.\n    \n    Args:\n        name: The tool name being called\n        arguments: The original arguments dictionary\n        prompt: Optional prompt context to influence behavior\n        \n    Returns:\n        Modified arguments dictionary with defaults applied\n    \"\"\"\n    # Create a copy to avoid mutating the original\n    modified_args = arguments.copy()\n    \n    # Apply limit defaults based on tool type\n    if \"limit\" in modified_args:\n        if name in [\"search_darkweb\", \"search_telegram\"]:\n            # For general searches, use smaller limit unless prompt suggests otherwise\n            if prompt and (\"detailed\" in prompt.lower() or \"comprehensive\" in prompt.lower()):\n                modified_args[\"limit\"] = 20\n            else:\n                modified_args[\"limit\"] = 10\n        elif name in [\n            \"search_credentials\",\n            \"search_ransomware\", \n            \"search_compromised_dataset\",\n            \"search_combo_binder\",\n            \"search_ulp_binder\",\n            \"search_government_monitoring\",\n            \"search_leaked_monitoring\",\n        ]:\n            # For sensitive data searches, use larger limit by default\n            if prompt and \"quick\" in prompt.lower():\n                modified_args[\"limit\"] = 20\n            else:\n                modified_args[\"limit\"] = 50\n\n    # Handle indicator defaults for search tools\n    if name in [\"search_darkweb\", \"search_telegram\"]:\n        if \"indicator\" not in modified_args or not modified_args[\"indicator\"]:\n            # Default to keyword search unless prompt suggests otherwise\n            if prompt:\n                if \"domain\" in prompt.lower():\n                    modified_args[\"indicator\"] = \"domain\"\n                elif \"ip\" in prompt.lower() or \"address\" in prompt.lower():\n                    modified_args[\"indicator\"] = \"ip\"\n                elif \"email\" in prompt.lower():\n                    modified_args[\"indicator\"] = \"email\"\n                else:\n                    modified_args[\"indicator\"] = \"keyword\"\n            else:\n                modified_args[\"indicator\"] = \"keyword\"\n    \n    # Add date range defaults based on prompt context\n    if prompt and \"start_date\" not in modified_args:\n        if \"recent\" in prompt.lower() or \"latest\" in prompt.lower():\n            # Set start_date to 7 days ago for recent searches\n            from datetime import datetime, timedelta\n            start_date = (datetime.now() - timedelta(days=7)).strftime(\"%Y-%m-%d\")\n            modified_args[\"start_date\"] = start_date\n        elif \"last month\" in prompt.lower():\n            from datetime import datetime, timedelta\n            start_date = (datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%d\")\n            modified_args[\"start_date\"] = start_date\n    \n    return modified_args\n\n\n@server.call_tool()\nasync def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:\n    \"\"\"Handle tool calls with default behavior applied.\"\"\"\n\n    # Apply default behavior rules\n    arguments = apply_default_behavior(name, arguments)\n\n    try:\n        if name == \"search_darkweb\":\n            result = await search_darkweb(\n                indicator=arguments[\"indicator\"],\n                text=arguments[\"text\"],\n                target=arguments.get(\"target\", \"all\"),\n                limit=arguments.get(\"limit\", 50),\n                orderType=arguments.get(\"orderType\", \"createDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_telegram\":\n            result = await search_telegram(\n                indicator=arguments[\"indicator\"],\n                text=arguments[\"text\"],\n                target=arguments.get(\"target\", \"all\"),\n                limit=arguments.get(\"limit\", 50),\n                orderType=arguments.get(\"orderType\", \"createDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_credentials\":\n            result = await search_credentials(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"leakedDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n                start=arguments.get(\"start\"),\n                end=arguments.get(\"end\"),\n            )\n        elif name == \"search_ransomware\":\n            result = await search_ransomware(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"get_node_details\":\n            result = await get_node_details(\n                service=arguments[\"service\"],\n                node_id=arguments[\"node_id\"],\n                pid=arguments.get(\"pid\"),\n                data_from=arguments.get(\"data_from\", False),\n                include_url=arguments.get(\"include_url\", False),\n                include_contents=arguments.get(\"include_contents\", True),\n            )\n        elif name == \"get_targets\":\n            result = await get_targets(\n                service=arguments[\"service\"], indicator=arguments[\"indicator\"]\n            )\n        elif name == \"export_data\":\n            result = await export_data(\n                service=arguments[\"service\"],\n                indicator=arguments[\"indicator\"],\n                format=arguments.get(\"format\", \"json\"),\n            )\n        elif name == \"search_compromised_dataset\":\n            result = await search_compromised_dataset(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"get_compromised_dataset_node\":\n            result = await get_compromised_dataset_node(\n                node_id=arguments[\"node_id\"]\n            )\n        elif name == \"search_combo_binder\":\n            result = await search_combo_binder(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"search_ulp_binder\":\n            result = await search_ulp_binder(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"search_government_monitoring\":\n            result = await search_government_monitoring(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_leaked_monitoring\":\n            result = await search_leaked_monitoring(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"download_file\":\n            file_content = await download_file(\n                service=arguments[\"service\"], file_hash=arguments[\"file_hash\"]\n            )\n            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"Downloaded file {arguments['file_hash']} from {arguments['service']} service. File size: {len(file_content)} bytes\",\n                )\n            ]\n        elif name == \"search_pagination\":\n            result = await search_pagination(\n                service=arguments[\"service\"],\n                search_id=arguments[\"search_id\"],\n                cursor=arguments.get(\"cursor\", 0),\n                limit=arguments.get(\"limit\", 50),\n            )\n        elif name == \"get_user_quotas\":\n            result = await get_user_quotas()\n        else:\n            return [TextContent(type=\"text\", text=f\"Unknown tool: {name}\")]\n\n        # Format response\n        response_text = f\"StealthMole API Results:{result}\"\n        return [TextContent(type=\"text\", text=response_text)]\n\n    except asyncio.TimeoutError:\n        return [\n            TextContent(\n                type=\"text\",\n                text=\"Request timed out. The API request took too long to complete.\",\n            )\n        ]\n    except Exception as e:\n        error_msg = str(e)\n        if \"timeout\" in error_msg.lower():\n            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"Timeout error: {error_msg}. Try reducing the result limit or check your network connection.\",\n                )\n            ]\n        return [\n            TextContent(\n                type=\"text\",\n                text=f\"Error calling StealthMole API: {error_msg}\",\n            )\n        ]\n\n\nasync def run_server():\n    \"\"\"Run the MCP server.\"\"\"\n    try:\n        print(\"Starting StealthMole MCP server...\", file=sys.stderr)\n\n        # Check environment variables\n        access_key = os.getenv(\"STEALTHMOLE_ACCESS_KEY\")\n        secret_key = os.getenv(\"STEALTHMOLE_SECRET_KEY\")\n\n        print(f\"Access key: {'SET' if access_key else 'NOT SET'}\", file=sys.stderr)\n        print(f\"Secret key: {'SET' if secret_key else 'NOT SET'}\", file=sys.stderr)\n\n        if not access_key or not secret_key:\n            print(\n                \"Warning: STEALTHMOLE_ACCESS_KEY and STEALTHMOLE_SECRET_KEY environment variables not set\",\n                file=sys.stderr,\n            )\n            print(\"MCP server will start but tools will not function\", file=sys.stderr)\n        else:\n            try:\n                # API 연결 테스트 (타임아웃 없이 간단히)\n                try:\n                    quotas = await get_user_quotas()\n                    print(\n                        f\"✓ API connection successful. Available quotas: {quotas}\",\n                        file=sys.stderr,\n                    )\n                except Exception as api_error:\n                    print(f\"Warning: API test failed: {api_error}\", file=sys.stderr)\n                    print(\"Continuing with server startup...\", file=sys.stderr)\n\n            except Exception as e:\n                print(\n                    f\"Warning: Error testing API connection: {e}\", file=sys.stderr\n                )\n                print(\n                    \"MCP server will start but tools may not function properly\",\n                    file=sys.stderr,\n                )\n                import traceback\n\n                traceback.print_exc(file=sys.stderr)\n\n        print(\"Creating stdio server...\", file=sys.stderr)\n        async with stdio_server() as (read_stream, write_stream):\n            print(\"Starting MCP server...\", file=sys.stderr)\n            try:\n                await server.run(\n                    read_stream,\n                    write_stream,\n                    InitializationOptions(\n                        server_name=\"stealthmole-mcp\",\n                        server_version=\"0.1.0\",\n                        capabilities=server.get_capabilities(\n                            notification_options=NotificationOptions(),\n                            experimental_capabilities={},\n                        ),\n                    ),\n                )\n                print(\"MCP server completed normally\", file=sys.stderr)\n            except Exception as e:\n                print(f\"Error in MCP server.run: {e}\", file=sys.stderr)\n                import traceback\n\n                traceback.print_exc(file=sys.stderr)\n                raise\n    except Exception as e:\n        print(f\"Error in run_server: {e}\", file=sys.stderr)\n        import traceback\n\n        traceback.print_exc(file=sys.stderr)\n\n\ndef main():\n    \"\"\"Main entry point for the MCP server.\"\"\"\n    asyncio.run(run_server())\n\n\nif __name__ == \"__main__\":\n    main()\n","structuredPatch":[{"oldStart":734,"oldLines":8,"newStart":734,"newLines":11,"lines":[" async def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:","     \"\"\"Handle tool calls with default behavior applied.\"\"\""," ","-    # Apply default behavior rules","-    arguments = apply_default_behavior(name, arguments)","+    # Extract prompt from arguments if provided (for context-aware defaults)","+    prompt = arguments.pop(\"_prompt\", None) if \"_prompt\" in arguments else None","+    ","+    # Apply default behavior rules with prompt context","+    arguments = apply_default_behavior(name, arguments, prompt)"," ","     try:","         if name == \"search_darkweb\":"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"6ebd3038-a864-485f-ae10-21bb117e0bc2","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"0b686f0a-b16e-41a7-a9f2-3b8ab9c52cca","version":"1.0.57","gitBranch":"main","message":{"id":"msg_01UEjmVEM4cyLSw15vJtpUUK","type":"message","role":"assistant","model":"claude-opus-4-20250514","content":[{"type":"tool_use","id":"toolu_01VMsyFZyNMqjLam9teBx4Zh","name":"TodoWrite","input":{"todos":[{"content":"apply_default_behavior 함수에 prompt 파라미터 추가 및 로직 구현","status":"completed","priority":"high","id":"1"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":672,"cache_read_input_tokens":18367,"output_tokens":103,"service_tier":"standard"}},"requestId":"req_011CRMsn5BDBnb94WNcxS7pq","type":"assistant","uuid":"a93b4fe3-87b8-4ba7-ae8a-476cb9e26a34","timestamp":"2025-07-22T10:10:48.091Z"}
{"parentUuid":"a93b4fe3-87b8-4ba7-ae8a-476cb9e26a34","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"0b686f0a-b16e-41a7-a9f2-3b8ab9c52cca","version":"1.0.57","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VMsyFZyNMqjLam9teBx4Zh","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"a8b6a905-f0f2-429b-b32c-f856adb6413c","timestamp":"2025-07-22T10:10:48.123Z","toolUseResult":{"oldTodos":[{"content":"apply_default_behavior 함수에 prompt 파라미터 추가 및 로직 구현","status":"in_progress","priority":"high","id":"1"}],"newTodos":[{"content":"apply_default_behavior 함수에 prompt 파라미터 추가 및 로직 구현","status":"completed","priority":"high","id":"1"}]}}
{"parentUuid":"a8b6a905-f0f2-429b-b32c-f856adb6413c","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"0b686f0a-b16e-41a7-a9f2-3b8ab9c52cca","version":"1.0.57","gitBranch":"main","message":{"id":"msg_01J4gHfmzZfx4VXVwaYAD6Ff","type":"message","role":"assistant","model":"claude-opus-4-20250514","content":[{"type":"text","text":"`apply_default_behavior` 함수를 다음과 같이 수정했습니다:\n\n1. **prompt 파라미터 추가**: 선택적 `prompt` 파라미터를 받아 프롬프트 컨텍스트에 따라 동작을 조정합니다.\n\n2. **향상된 기능들**:\n   - **동적 limit 조정**: 프롬프트에 \"detailed\", \"comprehensive\", \"quick\" 등의 키워드가 있으면 검색 결과 수를 조정합니다.\n   - **스마트 indicator 선택**: 프롬프트에서 \"domain\", \"ip\", \"email\" 등의 키워드를 감지하여 적절한 indicator 타입을 자동 설정합니다.\n   - **날짜 범위 자동 설정**: \"recent\", \"latest\", \"last month\" 등의 키워드를 감지하여 start_date를 자동으로 설정합니다.\n\n3. **사용 방법**: \n   - MCP 프로토콜의 제약으로 인해 `_prompt`라는 특별한 키를 통해 프롬프트를 전달할 수 있도록 했습니다.\n   - 클라이언트에서 도구를 호출할 때 `_prompt` 인자에 컨텍스트를 전달하면 됩니다.\n\n이제 프롬프트 컨텍스트에 따라 더 지능적으로 기본값을 설정할 수 있습니다."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":284,"cache_read_input_tokens":19039,"output_tokens":444,"service_tier":"standard"}},"requestId":"req_011CRMsnQChsojSqUghFfWD5","type":"assistant","uuid":"42e4e461-bb45-45c5-b3e2-d3d548b9ed38","timestamp":"2025-07-22T10:11:00.754Z"}
