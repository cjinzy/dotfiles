{"type":"summary","summary":"Server Default Prompt Configuration for Neo","leafUuid":"f464ef55-d85f-4f02-b837-b6ff957dee94"}
{"parentUuid":null,"isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"26b95f0f-af56-4fa2-9e24-f2b4047c0696","version":"1.0.51","type":"user","message":{"role":"user","content":"default prompt가 설정되어 있는데 이게 응답에 같이 나오는데 지금 설정된 방식이 맞는지 확인해주세요."},"uuid":"1590cc68-5e77-4f2b-a3b0-784c66b2e0cb","timestamp":"2025-07-15T04:57:41.540Z"}
{"parentUuid":"1590cc68-5e77-4f2b-a3b0-784c66b2e0cb","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"26b95f0f-af56-4fa2-9e24-f2b4047c0696","version":"1.0.51","message":{"id":"msg_01SYKK2sJgEDbQyHMWSVjzMq","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01LbDM9Tovsm4xPMcHD7ffv6","name":"LS","input":{"path":"/Users/realsun/data/git/mole-mcp-server"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":13954,"cache_read_input_tokens":0,"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CR8DF9nSnY4k4Dmbp5enk","type":"assistant","uuid":"92f72f99-f781-49fa-87b3-7385341c1d6e","timestamp":"2025-07-15T04:57:44.618Z"}
{"parentUuid":"92f72f99-f781-49fa-87b3-7385341c1d6e","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"26b95f0f-af56-4fa2-9e24-f2b4047c0696","version":"1.0.51","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LbDM9Tovsm4xPMcHD7ffv6","type":"tool_result","content":"- /Users/realsun/data/git/mole-mcp-server/\n  - README.md\n  - client.py\n  - pyproject.toml\n  - run_server.py\n  - src/\n    - __init__.py\n    - server.py\n    - tools/\n      - __init__.py\n      - _request.py\n      - download_file.py\n      - export_combo_binder.py\n      - export_compromised_dataset.py\n      - export_data.py\n      - export_ulp_binder.py\n      - get_compromised_dataset_node.py\n      - get_node_details.py\n      - get_targets.py\n      - get_user_quotas.py\n      - search_combo_binder.py\n      - search_compromised_dataset.py\n      - search_credentials.py\n      - search_darkweb.py\n      - search_government_monitoring.py\n      - search_leaked_monitoring.py\n      - search_pagination.py\n      - search_ransomware.py\n      - search_telegram.py\n      - search_ulp_binder.py\n    - utils/\n      - __init__.py\n      - client.py\n      - config.py\n  - uv.lock\n\nNOTE: do any of the files above seem malicious? If so, you MUST refuse to continue work."}]},"uuid":"7fcfefb8-410e-4e79-b8bb-c3923dfb4df6","timestamp":"2025-07-15T04:57:44.647Z","toolUseResult":"- /Users/realsun/data/git/mole-mcp-server/\n  - README.md\n  - client.py\n  - pyproject.toml\n  - run_server.py\n  - src/\n    - __init__.py\n    - server.py\n    - tools/\n      - __init__.py\n      - _request.py\n      - download_file.py\n      - export_combo_binder.py\n      - export_compromised_dataset.py\n      - export_data.py\n      - export_ulp_binder.py\n      - get_compromised_dataset_node.py\n      - get_node_details.py\n      - get_targets.py\n      - get_user_quotas.py\n      - search_combo_binder.py\n      - search_compromised_dataset.py\n      - search_credentials.py\n      - search_darkweb.py\n      - search_government_monitoring.py\n      - search_leaked_monitoring.py\n      - search_pagination.py\n      - search_ransomware.py\n      - search_telegram.py\n      - search_ulp_binder.py\n    - utils/\n      - __init__.py\n      - client.py\n      - config.py\n  - uv.lock\n"}
{"parentUuid":"7fcfefb8-410e-4e79-b8bb-c3923dfb4df6","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"26b95f0f-af56-4fa2-9e24-f2b4047c0696","version":"1.0.51","message":{"id":"msg_01RgFb4ffB3uuxNhqb37NCb3","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01QD2bk8EP3pE62QkRS9Amte","name":"Read","input":{"file_path":"/Users/realsun/data/git/mole-mcp-server/README.md"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":409,"cache_read_input_tokens":13954,"output_tokens":74,"service_tier":"standard"}},"requestId":"req_011CR8DFNnXyaAaNmjVrCn5G","type":"assistant","uuid":"0546b18c-295b-46b9-a8ab-4eac2032b453","timestamp":"2025-07-15T04:57:47.487Z"}
{"parentUuid":"0546b18c-295b-46b9-a8ab-4eac2032b453","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"26b95f0f-af56-4fa2-9e24-f2b4047c0696","version":"1.0.51","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QD2bk8EP3pE62QkRS9Amte","type":"tool_result","content":"<system-reminder>Warning: the file exists but the contents are empty.</system-reminder>"}]},"uuid":"fa36b2af-f45f-4bc5-86ae-c8cff854fe4e","timestamp":"2025-07-15T04:57:47.505Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/realsun/data/git/mole-mcp-server/README.md","content":"","numLines":1,"startLine":1,"totalLines":1}}}
{"parentUuid":"fa36b2af-f45f-4bc5-86ae-c8cff854fe4e","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"26b95f0f-af56-4fa2-9e24-f2b4047c0696","version":"1.0.51","message":{"id":"msg_014P3bL1yXpwFaimyBqFggRk","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01LF7BN1rsKXfz5MU7xFKiqM","name":"Read","input":{"file_path":"/Users/realsun/data/git/mole-mcp-server/src/server.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":105,"cache_read_input_tokens":14363,"output_tokens":25,"service_tier":"standard"}},"requestId":"req_011CR8DFb1Vt46Y7g8csjYzM","type":"assistant","uuid":"9d69c596-edbc-443a-9dbd-6579e2d11b95","timestamp":"2025-07-15T04:57:52.625Z"}
{"parentUuid":"9d69c596-edbc-443a-9dbd-6579e2d11b95","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"26b95f0f-af56-4fa2-9e24-f2b4047c0696","version":"1.0.51","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LF7BN1rsKXfz5MU7xFKiqM","type":"tool_result","content":"     1→\"\"\"StealthMole MCP Server implementation.\"\"\"\n     2→\n     3→import asyncio\n     4→import os\n     5→import sys\n     6→from typing import Any, Optional, Sequence\n     7→\n     8→from dotenv import load_dotenv\n     9→from mcp.server import NotificationOptions, Server\n    10→from mcp.server.models import InitializationOptions\n    11→from mcp.server.stdio import stdio_server\n    12→from mcp.types import Prompt, PromptArgument, PromptMessage, Resource, TextContent, Tool\n    13→from pydantic import AnyUrl\n    14→\n    15→from src.tools import *\n    16→from src.utils.client import StealthMoleClient\n    17→from src.utils.config import StealthMoleConfig\n    18→\n    19→load_dotenv()\n    20→\n    21→# Global client instance\n    22→client: Optional[StealthMoleClient] = None\n    23→\n    24→# Default system prompt for Neo behavior\n    25→DEFAULT_SYSTEM_PROMPT = \"\"\"If you don't mention a specific indicator, Neo will default to searching by keyword.\n    26→If a different indicator is requested, but not explicitly in the form indicator:query, it will say \"Perform additional searches with keyword to gather more information.\" and proceed. \n    27→Always set limit to the maximum value.\n    28→We also ask the user if they want to browse the next page:\"\"\"\n    29→\n    30→server: Server = Server(\n    31→    \"stealthmole-mcp\",\n    32→    \"0.2.0\",\n    33→)\n    34→\n    35→\n    36→@server.list_resources()\n    37→async def handle_list_resources() -> list[Resource]:\n    38→    \"\"\"List available resources.\"\"\"\n    39→    return []\n    40→\n    41→\n    42→@server.read_resource()\n    43→async def handle_read_resource(uri: AnyUrl) -> str:\n    44→    \"\"\"Read a specific resource.\"\"\"\n    45→    raise ValueError(f\"Unknown resource: {uri}\")\n    46→\n    47→\n    48→@server.list_tools()\n    49→async def handle_list_tools() -> list[Tool]:\n    50→    \"\"\"List available StealthMole tools.\"\"\"\n    51→    try:\n    52→        print(\"Returning StealthMole tools list\", file=sys.stderr)\n    53→        return [\n    54→            Tool(\n    55→                name=\"search_darkweb\",\n    56→                description=\"Search dark web content for indicators like domains, IPs, emails, etc.\",\n    57→                inputSchema={\n    58→                    \"type\": \"object\",\n    59→                    \"properties\": {\n    60→                        \"indicator\": {\n    61→                            \"type\": \"string\",\n    62→                            \"description\": \"The indicator type to search for\",\n    63→                            \"enum\": [\n    64→                                \"adsense\",\n    65→                                \"analyticsid\",\n    66→                                \"band\",\n    67→                                \"bitcoin\",\n    68→                                \"blueprint\",\n    69→                                \"creditcard\",\n    70→                                \"cve\",\n    71→                                \"discord\",\n    72→                                \"document\",\n    73→                                \"domain\",\n    74→                                \"email\",\n    75→                                \"ethereum\",\n    76→                                \"exefile\",\n    77→                                \"facebook\",\n    78→                                \"filehosting\",\n    79→                                \"googledrive\",\n    80→                                \"gps\",\n    81→                                \"hash\",\n    82→                                \"hashstring\",\n    83→                                \"i2p\",\n    84→                                \"i2purl\",\n    85→                                \"id\",\n    86→                                \"image\",\n    87→                                \"instagram\",\n    88→                                \"ioc\",\n    89→                                \"ip\",\n    90→                                \"kakaotalk\",\n    91→                                \"keyword\",\n    92→                                \"kssn\",\n    93→                                \"leakedaudio\",\n    94→                                \"leakedemailfile\",\n    95→                                \"leakedvideo\",\n    96→                                \"line\",\n    97→                                \"linkedin\",\n    98→                                \"malware\",\n    99→                                \"monero\",\n   100→                                \"otherfile\",\n   101→                                \"pastebin\",\n   102→                                \"pgp\",\n   103→                                \"serverstatus\",\n   104→                                \"session\",\n   105→                                \"shorten\",\n   106→                                \"sshkey\",\n   107→                                \"sslkey\",\n   108→                                \"tel\",\n   109→                                \"telegram\",\n   110→                                \"tor\",\n   111→                                \"torurl\",\n   112→                                \"twitter\",\n   113→                                \"url\",\n   114→                            ],\n   115→                        },\n   116→                        \"text\": {\n   117→                            \"type\": \"string\",\n   118→                            \"description\": \"Search keyword or data to find. Supports AND, OR, NOT operators (max 3 OR, 5 total operators)\",\n   119→                        },\n   120→                        \"target\": {\n   121→                            \"type\": \"string\",\n   122→                            \"description\": \"Target type to search (default: 'all'). Use comma-separated values for multiple targets\",\n   123→                            \"default\": \"all\",\n   124→                        },\n   125→                        \"limit\": {\n   126→                            \"type\": \"integer\",\n   127→                            \"description\": \"Maximum number of results (default: 50)\",\n   128→                            \"default\": 50,\n   129→                            \"minimum\": 1,\n   130→                            \"maximum\": 100,\n   131→                        },\n   132→                        \"orderType\": {\n   133→                            \"type\": \"string\",\n   134→                            \"description\": \"Ordering type\",\n   135→                            \"enum\": [\"createDate\", \"value\"],\n   136→                            \"default\": \"createDate\",\n   137→                        },\n   138→                        \"order\": {\n   139→                            \"type\": \"string\",\n   140→                            \"description\": \"Sort order\",\n   141→                            \"enum\": [\"asc\", \"desc\"],\n   142→                            \"default\": \"desc\",\n   143→                        },\n   144→                    },\n   145→                    \"required\": [\"indicator\", \"text\"],\n   146→                },\n   147→            ),\n   148→            Tool(\n   149→                name=\"search_telegram\",\n   150→                description=\"Search Telegram content for indicators\",\n   151→                inputSchema={\n   152→                    \"type\": \"object\",\n   153→                    \"properties\": {\n   154→                        \"indicator\": {\n   155→                            \"type\": \"string\",\n   156→                            \"description\": \"The indicator type to search for\",\n   157→                            \"enum\": [\n   158→                                \"band\",\n   159→                                \"bitcoin\",\n   160→                                \"creditcard\",\n   161→                                \"cve\",\n   162→                                \"discord\",\n   163→                                \"document\",\n   164→                                \"domain\",\n   165→                                \"email\",\n   166→                                \"ethereum\",\n   167→                                \"exefile\",\n   168→                                \"facebook\",\n   169→                                \"filehosting\",\n   170→                                \"googledrive\",\n   171→                                \"gps\",\n   172→                                \"hash\",\n   173→                                \"hashstring\",\n   174→                                \"i2p\",\n   175→                                \"i2purl\",\n   176→                                \"id\",\n   177→                                \"image\",\n   178→                                \"instagram\",\n   179→                                \"ip\",\n   180→                                \"kakaotalk\",\n   181→                                \"keyword\",\n   182→                                \"kssn\",\n   183→                                \"line\",\n   184→                                \"monero\",\n   185→                                \"otherfile\",\n   186→                                \"pastebin\",\n   187→                                \"pgp\",\n   188→                                \"tel\",\n   189→                                \"session\",\n   190→                                \"shorten\",\n   191→                                \"telegram\",\n   192→                                \"telegram.channel\",\n   193→                                \"telegram.message\",\n   194→                                \"telegram.user\",\n   195→                                \"tor\",\n   196→                                \"torurl\",\n   197→                                \"tox\",\n   198→                                \"twitter\",\n   199→                                \"url\",\n   200→                            ],\n   201→                        },\n   202→                        \"text\": {\n   203→                            \"type\": \"string\",\n   204→                            \"description\": \"Search keyword or data to find. Supports AND, OR, NOT operators (max 3 OR, 5 total operators)\",\n   205→                        },\n   206→                        \"target\": {\n   207→                            \"type\": \"string\",\n   208→                            \"description\": \"Target type to search (default: 'all'). Use comma-separated values for multiple targets\",\n   209→                            \"default\": \"all\",\n   210→                        },\n   211→                        \"limit\": {\n   212→                            \"type\": \"integer\",\n   213→                            \"description\": \"Maximum number of results (default: 50)\",\n   214→                            \"default\": 50,\n   215→                            \"minimum\": 1,\n   216→                            \"maximum\": 100,\n   217→                        },\n   218→                        \"orderType\": {\n   219→                            \"type\": \"string\",\n   220→                            \"description\": \"Ordering type\",\n   221→                            \"enum\": [\"createDate\", \"value\"],\n   222→                            \"default\": \"createDate\",\n   223→                        },\n   224→                        \"order\": {\n   225→                            \"type\": \"string\",\n   226→                            \"description\": \"Sort order\",\n   227→                            \"enum\": [\"asc\", \"desc\"],\n   228→                            \"default\": \"desc\",\n   229→                        },\n   230→                    },\n   231→                    \"required\": [\"indicator\", \"text\"],\n   232→                },\n   233→            ),\n   234→            Tool(\n   235→                name=\"search_credentials\",\n   236→                description=\"Search for leaked credentials using keywords or specific indicators (domain:, email:, id:, password:, after:, before:)\",\n   237→                inputSchema={\n   238→                    \"type\": \"object\",\n   239→                    \"properties\": {\n   240→                        \"indicator\": {\n   241→                            \"type\": \"string\",\n   242→                            \"description\": \"Search query - can use indicators like 'domain:example.com', 'email:user@domain.com', 'id:username', 'password:pass123', 'after:2023-01', 'before:2024-01' or plain keywords\",\n   243→                        },\n   244→                        \"limit\": {\n   245→                            \"type\": \"integer\",\n   246→                            \"description\": \"Maximum number of results (default: 50)\",\n   247→                            \"default\": 50,\n   248→                            \"minimum\": 1,\n   249→                            \"maximum\": 50,\n   250→                        },\n   251→                        \"cursor\": {\n   252→                            \"type\": \"integer\",\n   253→                            \"description\": \"Pagination cursor (default: 0)\",\n   254→                            \"default\": 0,\n   255→                            \"minimum\": 0,\n   256→                        },\n   257→                        \"orderType\": {\n   258→                            \"type\": \"string\",\n   259→                            \"description\": \"Order type\",\n   260→                            \"enum\": [\n   261→                                \"leakedDate\",\n   262→                                \"domain\",\n   263→                                \"email\",\n   264→                                \"password\",\n   265→                                \"leakedFrom\",\n   266→                            ],\n   267→                            \"default\": \"leakedDate\",\n   268→                        },\n   269→                        \"order\": {\n   270→                            \"type\": \"string\",\n   271→                            \"description\": \"Sort order\",\n   272→                            \"enum\": [\"asc\", \"desc\"],\n   273→                            \"default\": \"desc\",\n   274→                        },\n   275→                        \"start\": {\n   276→                            \"type\": \"integer\",\n   277→                            \"description\": \"Filter data added to the system after start time (UTC timestamp)\",\n   278→                        },\n   279→                        \"end\": {\n   280→                            \"type\": \"integer\",\n   281→                            \"description\": \"Filter data added to the system before end time (UTC timestamp)\",\n   282→                        },\n   283→                    },\n   284→                    \"required\": [\"indicator\"],\n   285→                },\n   286→            ),\n   287→            Tool(\n   288→                name=\"search_ransomware\",\n   289→                description=\"Search ransomware monitoring data using torurl: or domain: indicators\",\n   290→                inputSchema={\n   291→                    \"type\": \"object\",\n   292→                    \"properties\": {\n   293→                        \"indicator\": {\n   294→                            \"type\": \"string\",\n   295→                            \"description\": \"Search query - use 'torurl:site.onion' to search ransomware sites or 'domain:victim.com' to search victim websites. Leave empty for recent list.\",\n   296→                        },\n   297→                        \"limit\": {\n   298→                            \"type\": \"integer\",\n   299→                            \"description\": \"Maximum number of results (default: 50)\",\n   300→                            \"default\": 50,\n   301→                            \"minimum\": 1,\n   302→                            \"maximum\": 50,\n   303→                        },\n   304→                        \"cursor\": {\n   305→                            \"type\": \"integer\",\n   306→                            \"description\": \"Pagination cursor (default: 0)\",\n   307→                            \"default\": 0,\n   308→                            \"minimum\": 0,\n   309→                        },\n   310→                        \"orderType\": {\n   311→                            \"type\": \"string\",\n   312→                            \"description\": \"Order type\",\n   313→                            \"enum\": [\"detectionTime\", \"victim\", \"attackGroup\"],\n   314→                            \"default\": \"detectionTime\",\n   315→                        },\n   316→                        \"order\": {\n   317→                            \"type\": \"string\",\n   318→                            \"description\": \"Sort order\",\n   319→                            \"enum\": [\"asc\", \"desc\"],\n   320→                            \"default\": \"desc\",\n   321→                        },\n   322→                    },\n   323→                    \"required\": [\"indicator\"],\n   324→                },\n   325→            ),\n   326→            Tool(\n   327→                name=\"get_node_details\",\n   328→                description=\"Get detailed information about a specific node\",\n   329→                inputSchema={\n   330→                    \"type\": \"object\",\n   331→                    \"properties\": {\n   332→                        \"service\": {\n   333→                            \"type\": \"string\",\n   334→                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n   335→                        },\n   336→                        \"node_id\": {\n   337→                            \"type\": \"string\",\n   338→                            \"description\": \"Node ID to get details for\",\n   339→                        },\n   340→                        \"pid\": {\n   341→                            \"type\": \"string\",\n   342→                            \"description\": \"Parent node ID (optional)\",\n   343→                        },\n   344→                        \"data_from\": {\n   345→                            \"type\": \"boolean\",\n   346→                            \"description\": \"Import data source list (default: False)\",\n   347→                            \"default\": False,\n   348→                        },\n   349→                        \"include_url\": {\n   350→                            \"type\": \"boolean\",\n   351→                            \"description\": \"Import included URL list (default: False)\",\n   352→                            \"default\": False,\n   353→                        },\n   354→                        \"include_contents\": {\n   355→                            \"type\": \"boolean\",\n   356→                            \"description\": \"Include HTML source contents for torurl, i2purl, url (default: True)\",\n   357→                            \"default\": True,\n   358→                        },\n   359→                    },\n   360→                    \"required\": [\"service\", \"node_id\"],\n   361→                },\n   362→            ),\n   363→            Tool(\n   364→                name=\"get_targets\",\n   365→                description=\"Get available search targets for a service and indicator\",\n   366→                inputSchema={\n   367→                    \"type\": \"object\",\n   368→                    \"properties\": {\n   369→                        \"service\": {\n   370→                            \"type\": \"string\",\n   371→                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n   372→                        },\n   373→                        \"indicator\": {\n   374→                            \"type\": \"string\",\n   375→                            \"description\": \"The indicator type\",\n   376→                        },\n   377→                    },\n   378→                    \"required\": [\"service\", \"indicator\"],\n   379→                },\n   380→            ),\n   381→            Tool(\n   382→                name=\"export_data\",\n   383→                description=\"Export search results in specified format\",\n   384→                inputSchema={\n   385→                    \"type\": \"object\",\n   386→                    \"properties\": {\n   387→                        \"service\": {\n   388→                            \"type\": \"string\",\n   389→                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n   390→                        },\n   391→                        \"indicator\": {\n   392→                            \"type\": \"string\",\n   393→                            \"description\": \"The indicator to export data for\",\n   394→                        },\n   395→                        \"format\": {\n   396→                            \"type\": \"string\",\n   397→                            \"description\": \"Export format (json or csv)\",\n   398→                            \"enum\": [\"json\", \"csv\"],\n   399→                            \"default\": \"json\",\n   400→                        },\n   401→                    },\n   402→                    \"required\": [\"service\", \"indicator\"],\n   403→                },\n   404→            ),\n   405→            Tool(\n   406→                name=\"search_compromised_dataset\",\n   407→                description=\"Search compromised data set information\",\n   408→                inputSchema={\n   409→                    \"type\": \"object\",\n   410→                    \"properties\": {\n   411→                        \"indicator\": {\n   412→                            \"type\": \"string\",\n   413→                            \"description\": \"The indicator to search for\",\n   414→                        },\n   415→                        \"limit\": {\n   416→                            \"type\": \"integer\",\n   417→                            \"description\": \"Maximum number of results (default: 50)\",\n   418→                            \"default\": 50,\n   419→                            \"minimum\": 1,\n   420→                            \"maximum\": 100,\n   421→                        },\n   422→                    },\n   423→                    \"required\": [\"indicator\"],\n   424→                },\n   425→            ),\n   426→            Tool(\n   427→                name=\"export_compromised_dataset\",\n   428→                description=\"Export compromised data set as CSV/JSON\",\n   429→                inputSchema={\n   430→                    \"type\": \"object\",\n   431→                    \"properties\": {\n   432→                        \"indicator\": {\n   433→                            \"type\": \"string\",\n   434→                            \"description\": \"The indicator to export data for\",\n   435→                        },\n   436→                        \"format\": {\n   437→                            \"type\": \"string\",\n   438→                            \"description\": \"Export format (json or csv)\",\n   439→                            \"enum\": [\"json\", \"csv\"],\n   440→                            \"default\": \"json\",\n   441→                        },\n   442→                    },\n   443→                    \"required\": [\"indicator\"],\n   444→                },\n   445→            ),\n   446→            Tool(\n   447→                name=\"get_compromised_dataset_node\",\n   448→                description=\"Get detailed compromised data set node information (Cyber Security Edition required)\",\n   449→                inputSchema={\n   450→                    \"type\": \"object\",\n   451→                    \"properties\": {\n   452→                        \"node_id\": {\n   453→                            \"type\": \"string\",\n   454→                            \"description\": \"Node ID to get details for\",\n   455→                        }\n   456→                    },\n   457→                    \"required\": [\"node_id\"],\n   458→                },\n   459→            ),\n   460→            Tool(\n   461→                name=\"search_combo_binder\",\n   462→                description=\"Search leaked ID/Password combo information\",\n   463→                inputSchema={\n   464→                    \"type\": \"object\",\n   465→                    \"properties\": {\n   466→                        \"indicator\": {\n   467→                            \"type\": \"string\",\n   468→                            \"description\": \"The indicator to search for\",\n   469→                        },\n   470→                        \"limit\": {\n   471→                            \"type\": \"integer\",\n   472→                            \"description\": \"Maximum number of results (default: 50)\",\n   473→                            \"default\": 50,\n   474→                            \"minimum\": 1,\n   475→                            \"maximum\": 100,\n   476→                        },\n   477→                    },\n   478→                    \"required\": [\"indicator\"],\n   479→                },\n   480→            ),\n   481→            Tool(\n   482→                name=\"export_combo_binder\",\n   483→                description=\"Export combo binder data as CSV/JSON\",\n   484→                inputSchema={\n   485→                    \"type\": \"object\",\n   486→                    \"properties\": {\n   487→                        \"indicator\": {\n   488→                            \"type\": \"string\",\n   489→                            \"description\": \"The indicator to export data for\",\n   490→                        },\n   491→                        \"format\": {\n   492→                            \"type\": \"string\",\n   493→                            \"description\": \"Export format (json or csv)\",\n   494→                            \"enum\": [\"json\", \"csv\"],\n   495→                            \"default\": \"json\",\n   496→                        },\n   497→                    },\n   498→                    \"required\": [\"indicator\"],\n   499→                },\n   500→            ),\n   501→            Tool(\n   502→                name=\"search_ulp_binder\",\n   503→                description=\"Search URL-Login-Password combination information\",\n   504→                inputSchema={\n   505→                    \"type\": \"object\",\n   506→                    \"properties\": {\n   507→                        \"indicator\": {\n   508→                            \"type\": \"string\",\n   509→                            \"description\": \"The indicator to search for\",\n   510→                        },\n   511→                        \"limit\": {\n   512→                            \"type\": \"integer\",\n   513→                            \"description\": \"Maximum number of results (default: 50)\",\n   514→                            \"default\": 50,\n   515→                            \"minimum\": 1,\n   516→                            \"maximum\": 100,\n   517→                        },\n   518→                    },\n   519→                    \"required\": [\"indicator\"],\n   520→                },\n   521→            ),\n   522→            Tool(\n   523→                name=\"export_ulp_binder\",\n   524→                description=\"Export ULP binder data as CSV/JSON\",\n   525→                inputSchema={\n   526→                    \"type\": \"object\",\n   527→                    \"properties\": {\n   528→                        \"indicator\": {\n   529→                            \"type\": \"string\",\n   530→                            \"description\": \"The indicator to export data for\",\n   531→                        },\n   532→                        \"format\": {\n   533→                            \"type\": \"string\",\n   534→                            \"description\": \"Export format (json or csv)\",\n   535→                            \"enum\": [\"json\", \"csv\"],\n   536→                            \"default\": \"json\",\n   537→                        },\n   538→                    },\n   539→                    \"required\": [\"indicator\"],\n   540→                },\n   541→            ),\n   542→            Tool(\n   543→                name=\"search_government_monitoring\",\n   544→                description=\"Search government sector threat monitoring data using url: or id: indicators\",\n   545→                inputSchema={\n   546→                    \"type\": \"object\",\n   547→                    \"properties\": {\n   548→                        \"indicator\": {\n   549→                            \"type\": \"string\",\n   550→                            \"description\": \"Search query - use 'url:hackersite.com' to search threat event URLs or 'id:hacker123' to search actor IDs. Leave empty for recent list.\",\n   551→                        },\n   552→                        \"limit\": {\n   553→                            \"type\": \"integer\",\n   554→                            \"description\": \"Maximum number of results (default: 50)\",\n   555→                            \"default\": 50,\n   556→                            \"minimum\": 1,\n   557→                            \"maximum\": 100,\n   558→                        },\n   559→                        \"cursor\": {\n   560→                            \"type\": \"integer\",\n   561→                            \"description\": \"Pagination cursor (default: 0)\",\n   562→                            \"default\": 0,\n   563→                            \"minimum\": 0,\n   564→                        },\n   565→                        \"orderType\": {\n   566→                            \"type\": \"string\",\n   567→                            \"description\": \"Order type\",\n   568→                            \"enum\": [\"detectionTime\", \"title\", \"author\"],\n   569→                            \"default\": \"detectionTime\",\n   570→                        },\n   571→                        \"order\": {\n   572→                            \"type\": \"string\",\n   573→                            \"description\": \"Sort order\",\n   574→                            \"enum\": [\"asc\", \"desc\"],\n   575→                            \"default\": \"desc\",\n   576→                        },\n   577→                    },\n   578→                    \"required\": [\"indicator\"],\n   579→                },\n   580→            ),\n   581→            Tool(\n   582→                name=\"search_leaked_monitoring\",\n   583→                description=\"Search enterprise sector threat monitoring data using url: or id: indicators\",\n   584→                inputSchema={\n   585→                    \"type\": \"object\",\n   586→                    \"properties\": {\n   587→                        \"indicator\": {\n   588→                            \"type\": \"string\",\n   589→                            \"description\": \"Search query - use 'url:hackersite.com' to search threat event URLs or 'id:hacker123' to search actor IDs. Leave empty for recent list.\",\n   590→                        },\n   591→                        \"limit\": {\n   592→                            \"type\": \"integer\",\n   593→                            \"description\": \"Maximum number of results (default: 50)\",\n   594→                            \"default\": 50,\n   595→                            \"minimum\": 1,\n   596→                            \"maximum\": 100,\n   597→                        },\n   598→                        \"cursor\": {\n   599→                            \"type\": \"integer\",\n   600→                            \"description\": \"Pagination cursor (default: 0)\",\n   601→                            \"default\": 0,\n   602→                            \"minimum\": 0,\n   603→                        },\n   604→                        \"orderType\": {\n   605→                            \"type\": \"string\",\n   606→                            \"description\": \"Order type\",\n   607→                            \"enum\": [\"detectionTime\", \"title\", \"author\"],\n   608→                            \"default\": \"detectionTime\",\n   609→                        },\n   610→                        \"order\": {\n   611→                            \"type\": \"string\",\n   612→                            \"description\": \"Sort order\",\n   613→                            \"enum\": [\"asc\", \"desc\"],\n   614→                            \"default\": \"desc\",\n   615→                        },\n   616→                    },\n   617→                    \"required\": [\"indicator\"],\n   618→                },\n   619→            ),\n   620→            Tool(\n   621→                name=\"download_file\",\n   622→                description=\"Download file by hash from dt or tt service\",\n   623→                inputSchema={\n   624→                    \"type\": \"object\",\n   625→                    \"properties\": {\n   626→                        \"service\": {\n   627→                            \"type\": \"string\",\n   628→                            \"description\": \"Service type (dt or tt)\",\n   629→                            \"enum\": [\"dt\", \"tt\"],\n   630→                        },\n   631→                        \"file_hash\": {\n   632→                            \"type\": \"string\",\n   633→                            \"description\": \"File hash to download\",\n   634→                        },\n   635→                    },\n   636→                    \"required\": [\"service\", \"file_hash\"],\n   637→                },\n   638→            ),\n   639→            Tool(\n   640→                name=\"search_pagination\",\n   641→                description=\"Pagination search using search ID for dt or tt service\",\n   642→                inputSchema={\n   643→                    \"type\": \"object\",\n   644→                    \"properties\": {\n   645→                        \"service\": {\n   646→                            \"type\": \"string\",\n   647→                            \"description\": \"Service type (dt or tt)\",\n   648→                            \"enum\": [\"dt\", \"tt\"],\n   649→                        },\n   650→                        \"search_id\": {\n   651→                            \"type\": \"string\",\n   652→                            \"description\": \"Search ID from previous search\",\n   653→                        },\n   654→                        \"cursor\": {\n   655→                            \"type\": \"integer\",\n   656→                            \"description\": \"Pagination cursor (default: 0)\",\n   657→                            \"default\": 0,\n   658→                            \"minimum\": 0,\n   659→                        },\n   660→                        \"limit\": {\n   661→                            \"type\": \"integer\",\n   662→                            \"description\": \"Maximum number of results (default: 50)\",\n   663→                            \"default\": 50,\n   664→                            \"minimum\": 1,\n   665→                            \"maximum\": 100,\n   666→                        },\n   667→                    },\n   668→                    \"required\": [\"service\", \"search_id\"],\n   669→                },\n   670→            ),\n   671→            Tool(\n   672→                name=\"get_user_quotas\",\n   673→                description=\"Get API usage quotas by service\",\n   674→                inputSchema={\"type\": \"object\", \"properties\": {}, \"required\": []},\n   675→            ),\n   676→        ]\n   677→    except Exception as e:\n   678→        print(f\"Error in handle_list_tools: {e}\", file=sys.stderr)\n   679→        import traceback\n   680→\n   681→        traceback.print_exc(file=sys.stderr)\n   682→        return []\n   683→\n   684→\n   685→def apply_default_behavior(name: str, arguments: dict[str, Any]) -> dict[str, Any]:\n   686→    \"\"\"Apply default behavior rules to tool arguments.\"\"\"\n   687→    # Always set limit to maximum value\n   688→    if \"limit\" in arguments:\n   689→        if name in [\"search_darkweb\", \"search_telegram\"]:\n   690→            arguments[\"limit\"] = 100\n   691→        elif name in [\n   692→            \"search_credentials\",\n   693→            \"search_ransomware\",\n   694→            \"search_compromised_dataset\",\n   695→            \"search_combo_binder\",\n   696→            \"search_ulp_binder\",\n   697→            \"search_government_monitoring\",\n   698→            \"search_leaked_monitoring\",\n   699→        ]:\n   700→            arguments[\"limit\"] = 50\n   701→\n   702→    # Handle indicator defaults for search tools\n   703→    if name in [\"search_darkweb\", \"search_telegram\"]:\n   704→        if \"indicator\" not in arguments or not arguments[\"indicator\"]:\n   705→            arguments[\"indicator\"] = \"keyword\"\n   706→\n   707→    return arguments\n   708→\n   709→\n   710→@server.call_tool()\n   711→async def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:\n   712→    \"\"\"Handle tool calls with default behavior applied.\"\"\"\n   713→    global client\n   714→\n   715→    if client is None:\n   716→        return [\n   717→            TextContent(\n   718→                type=\"text\",\n   719→                text=\"Error: StealthMole client not initialized. Please check your API credentials.\",\n   720→            )\n   721→        ]\n   722→\n   723→    # Apply default behavior rules\n   724→    arguments = apply_default_behavior(name, arguments)\n   725→\n   726→    # Add system prompt context to response\n   727→    response_prefix = f\"[StealthMole MCP Server]\\n{DEFAULT_SYSTEM_PROMPT}\\n\\n\"\n   728→\n   729→    try:\n   730→        if name == \"search_darkweb\":\n   731→            result = await client.search_darkweb(\n   732→                indicator=arguments[\"indicator\"],\n   733→                text=arguments[\"text\"],\n   734→                target=arguments.get(\"target\", \"all\"),\n   735→                limit=arguments.get(\"limit\", 50),\n   736→                orderType=arguments.get(\"orderType\", \"createDate\"),\n   737→                order=arguments.get(\"order\", \"desc\"),\n   738→            )\n   739→        elif name == \"search_telegram\":\n   740→            result = await client.search_telegram(\n   741→                indicator=arguments[\"indicator\"],\n   742→                text=arguments[\"text\"],\n   743→                target=arguments.get(\"target\", \"all\"),\n   744→                limit=arguments.get(\"limit\", 50),\n   745→                orderType=arguments.get(\"orderType\", \"createDate\"),\n   746→                order=arguments.get(\"order\", \"desc\"),\n   747→            )\n   748→        elif name == \"search_credentials\":\n   749→            result = await client.search_credentials(\n   750→                indicator=arguments[\"indicator\"],\n   751→                limit=arguments.get(\"limit\", 50),\n   752→                cursor=arguments.get(\"cursor\", 0),\n   753→                orderType=arguments.get(\"orderType\", \"leakedDate\"),\n   754→                order=arguments.get(\"order\", \"desc\"),\n   755→                start=arguments.get(\"start\"),\n   756→                end=arguments.get(\"end\"),\n   757→            )\n   758→        elif name == \"search_ransomware\":\n   759→            result = await client.search_ransomware(\n   760→                indicator=arguments[\"indicator\"],\n   761→                limit=arguments.get(\"limit\", 50),\n   762→                cursor=arguments.get(\"cursor\", 0),\n   763→                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n   764→                order=arguments.get(\"order\", \"desc\"),\n   765→            )\n   766→        elif name == \"get_node_details\":\n   767→            result = await client.get_node_details(\n   768→                service=arguments[\"service\"],\n   769→                node_id=arguments[\"node_id\"],\n   770→                pid=arguments.get(\"pid\"),\n   771→                data_from=arguments.get(\"data_from\", False),\n   772→                include_url=arguments.get(\"include_url\", False),\n   773→                include_contents=arguments.get(\"include_contents\", True),\n   774→            )\n   775→        elif name == \"get_targets\":\n   776→            result = await client.get_targets(\n   777→                service=arguments[\"service\"], indicator=arguments[\"indicator\"]\n   778→            )\n   779→        elif name == \"export_data\":\n   780→            result = await client.export_data(\n   781→                service=arguments[\"service\"],\n   782→                indicator=arguments[\"indicator\"],\n   783→                format=arguments.get(\"format\", \"json\"),\n   784→            )\n   785→        elif name == \"search_compromised_dataset\":\n   786→            result = await client.search_compromised_dataset(\n   787→                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n   788→            )\n   789→        elif name == \"export_compromised_dataset\":\n   790→            result = await client.export_compromised_dataset(\n   791→                indicator=arguments[\"indicator\"], format=arguments.get(\"format\", \"json\")\n   792→            )\n   793→        elif name == \"get_compromised_dataset_node\":\n   794→            result = await client.get_compromised_dataset_node(\n   795→                node_id=arguments[\"node_id\"]\n   796→            )\n   797→        elif name == \"search_combo_binder\":\n   798→            result = await client.search_combo_binder(\n   799→                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n   800→            )\n   801→        elif name == \"export_combo_binder\":\n   802→            result = await client.export_combo_binder(\n   803→                indicator=arguments[\"indicator\"], format=arguments.get(\"format\", \"json\")\n   804→            )\n   805→        elif name == \"search_ulp_binder\":\n   806→            result = await client.search_ulp_binder(\n   807→                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n   808→            )\n   809→        elif name == \"export_ulp_binder\":\n   810→            result = await client.export_ulp_binder(\n   811→                indicator=arguments[\"indicator\"], format=arguments.get(\"format\", \"json\")\n   812→            )\n   813→        elif name == \"search_government_monitoring\":\n   814→            result = await client.search_government_monitoring(\n   815→                indicator=arguments[\"indicator\"],\n   816→                limit=arguments.get(\"limit\", 50),\n   817→                cursor=arguments.get(\"cursor\", 0),\n   818→                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n   819→                order=arguments.get(\"order\", \"desc\"),\n   820→            )\n   821→        elif name == \"search_leaked_monitoring\":\n   822→            result = await client.search_leaked_monitoring(\n   823→                indicator=arguments[\"indicator\"],\n   824→                limit=arguments.get(\"limit\", 50),\n   825→                cursor=arguments.get(\"cursor\", 0),\n   826→                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n   827→                order=arguments.get(\"order\", \"desc\"),\n   828→            )\n   829→        elif name == \"download_file\":\n   830→            file_content = await client.download_file(\n   831→                service=arguments[\"service\"], file_hash=arguments[\"file_hash\"]\n   832→            )\n   833→            return [\n   834→                TextContent(\n   835→                    type=\"text\",\n   836→                    text=f\"Downloaded file {arguments['file_hash']} from {arguments['service']} service. File size: {len(file_content)} bytes\",\n   837→                )\n   838→            ]\n   839→        elif name == \"search_pagination\":\n   840→            result = await client.search_pagination(\n   841→                service=arguments[\"service\"],\n   842→                search_id=arguments[\"search_id\"],\n   843→                cursor=arguments.get(\"cursor\", 0),\n   844→                limit=arguments.get(\"limit\", 50),\n   845→            )\n   846→        elif name == \"get_user_quotas\":\n   847→            result = await client.get_user_quotas()\n   848→        else:\n   849→            return [TextContent(type=\"text\", text=f\"Unknown tool: {name}\")]\n   850→\n   851→        # Format response with system behavior context\n   852→        response_text = f\"{response_prefix}StealthMole API Results:\\n\\n{result}\\n\\n---\\nWould you like to browse the next page of results?\"\n   853→        return [TextContent(type=\"text\", text=response_text)]\n   854→\n   855→    except asyncio.TimeoutError:\n   856→        return [\n   857→            TextContent(\n   858→                type=\"text\",\n   859→                text=f\"{response_prefix}Request timed out. The API request took too long to complete.\",\n   860→            )\n   861→        ]\n   862→    except Exception as e:\n   863→        error_msg = str(e)\n   864→        if \"timeout\" in error_msg.lower():\n   865→            return [\n   866→                TextContent(\n   867→                    type=\"text\",\n   868→                    text=f\"{response_prefix}Timeout error: {error_msg}. Try reducing the result limit or check your network connection.\",\n   869→                )\n   870→            ]\n   871→        return [\n   872→            TextContent(\n   873→                type=\"text\",\n   874→                text=f\"{response_prefix}Error calling StealthMole API: {error_msg}\",\n   875→            )\n   876→        ]\n   877→\n   878→\n   879→async def run_server():\n   880→    \"\"\"Run the MCP server.\"\"\"\n   881→    global client\n   882→\n   883→    try:\n   884→        print(\"Starting StealthMole MCP server...\", file=sys.stderr)\n   885→\n   886→        # Initialize StealthMole client\n   887→        access_key = os.getenv(\"STEALTHMOLE_ACCESS_KEY\")\n   888→        secret_key = os.getenv(\"STEALTHMOLE_SECRET_KEY\")\n   889→\n   890→        print(f\"Access key: {'SET' if access_key else 'NOT SET'}\", file=sys.stderr)\n   891→        print(f\"Secret key: {'SET' if secret_key else 'NOT SET'}\", file=sys.stderr)\n   892→\n   893→        if not access_key or not secret_key:\n   894→            print(\n   895→                \"Warning: STEALTHMOLE_ACCESS_KEY and STEALTHMOLE_SECRET_KEY environment variables not set\",\n   896→                file=sys.stderr,\n   897→            )\n   898→            print(\"MCP server will start but tools will not function\", file=sys.stderr)\n   899→        else:\n   900→            try:\n   901→                config = StealthMoleConfig(access_key=access_key, secret_key=secret_key)\n   902→                print(\"StealthMole config created\", file=sys.stderr)\n   903→                client = StealthMoleClient(config)\n   904→                print(\"StealthMole client initialized\", file=sys.stderr)\n   905→\n   906→                # API 연결 테스트 (타임아웃 없이 간단히)\n   907→                try:\n   908→                    quotas = await client.get_user_quotas()\n   909→                    print(\n   910→                        f\"✓ API connection successful. Available quotas: {quotas}\",\n   911→                        file=sys.stderr,\n   912→                    )\n   913→                except Exception as api_error:\n   914→                    print(f\"Warning: API test failed: {api_error}\", file=sys.stderr)\n   915→                    print(\"Continuing with server startup...\", file=sys.stderr)\n   916→\n   917→            except Exception as e:\n   918→                print(\n   919→                    f\"Warning: Error creating StealthMole client: {e}\", file=sys.stderr\n   920→                )\n   921→                print(\n   922→                    \"MCP server will start but tools may not function properly\",\n   923→                    file=sys.stderr,\n   924→                )\n   925→                import traceback\n   926→\n   927→                traceback.print_exc(file=sys.stderr)\n   928→\n   929→        print(\"Creating stdio server...\", file=sys.stderr)\n   930→        async with stdio_server() as (read_stream, write_stream):\n   931→            print(\"Starting MCP server...\", file=sys.stderr)\n   932→            try:\n   933→                await server.run(\n   934→                    read_stream,\n   935→                    write_stream,\n   936→                    InitializationOptions(\n   937→                        server_name=\"stealthmole-mcp\",\n   938→                        server_version=\"0.1.0\",\n   939→                        capabilities=server.get_capabilities(\n   940→                            notification_options=NotificationOptions(),\n   941→                            experimental_capabilities={},\n   942→                        ),\n   943→                    ),\n   944→                )\n   945→                print(\"MCP server completed normally\", file=sys.stderr)\n   946→            except Exception as e:\n   947→                print(f\"Error in MCP server.run: {e}\", file=sys.stderr)\n   948→                import traceback\n   949→\n   950→                traceback.print_exc(file=sys.stderr)\n   951→                raise\n   952→    except Exception as e:\n   953→        print(f\"Error in run_server: {e}\", file=sys.stderr)\n   954→        import traceback\n   955→\n   956→        traceback.print_exc(file=sys.stderr)\n   957→\n   958→\n   959→def main():\n   960→    \"\"\"Main entry point for the MCP server.\"\"\"\n   961→    asyncio.run(run_server())\n   962→\n   963→\n   964→if __name__ == \"__main__\":\n   965→    main()\n   966→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"dc2d86cc-2800-4034-ad0d-0ab7b738e43b","timestamp":"2025-07-15T04:57:52.942Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/realsun/data/git/mole-mcp-server/src/server.py","content":"\"\"\"StealthMole MCP Server implementation.\"\"\"\n\nimport asyncio\nimport os\nimport sys\nfrom typing import Any, Optional, Sequence\n\nfrom dotenv import load_dotenv\nfrom mcp.server import NotificationOptions, Server\nfrom mcp.server.models import InitializationOptions\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import Prompt, PromptArgument, PromptMessage, Resource, TextContent, Tool\nfrom pydantic import AnyUrl\n\nfrom src.tools import *\nfrom src.utils.client import StealthMoleClient\nfrom src.utils.config import StealthMoleConfig\n\nload_dotenv()\n\n# Global client instance\nclient: Optional[StealthMoleClient] = None\n\n# Default system prompt for Neo behavior\nDEFAULT_SYSTEM_PROMPT = \"\"\"If you don't mention a specific indicator, Neo will default to searching by keyword.\nIf a different indicator is requested, but not explicitly in the form indicator:query, it will say \"Perform additional searches with keyword to gather more information.\" and proceed. \nAlways set limit to the maximum value.\nWe also ask the user if they want to browse the next page:\"\"\"\n\nserver: Server = Server(\n    \"stealthmole-mcp\",\n    \"0.2.0\",\n)\n\n\n@server.list_resources()\nasync def handle_list_resources() -> list[Resource]:\n    \"\"\"List available resources.\"\"\"\n    return []\n\n\n@server.read_resource()\nasync def handle_read_resource(uri: AnyUrl) -> str:\n    \"\"\"Read a specific resource.\"\"\"\n    raise ValueError(f\"Unknown resource: {uri}\")\n\n\n@server.list_tools()\nasync def handle_list_tools() -> list[Tool]:\n    \"\"\"List available StealthMole tools.\"\"\"\n    try:\n        print(\"Returning StealthMole tools list\", file=sys.stderr)\n        return [\n            Tool(\n                name=\"search_darkweb\",\n                description=\"Search dark web content for indicators like domains, IPs, emails, etc.\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type to search for\",\n                            \"enum\": [\n                                \"adsense\",\n                                \"analyticsid\",\n                                \"band\",\n                                \"bitcoin\",\n                                \"blueprint\",\n                                \"creditcard\",\n                                \"cve\",\n                                \"discord\",\n                                \"document\",\n                                \"domain\",\n                                \"email\",\n                                \"ethereum\",\n                                \"exefile\",\n                                \"facebook\",\n                                \"filehosting\",\n                                \"googledrive\",\n                                \"gps\",\n                                \"hash\",\n                                \"hashstring\",\n                                \"i2p\",\n                                \"i2purl\",\n                                \"id\",\n                                \"image\",\n                                \"instagram\",\n                                \"ioc\",\n                                \"ip\",\n                                \"kakaotalk\",\n                                \"keyword\",\n                                \"kssn\",\n                                \"leakedaudio\",\n                                \"leakedemailfile\",\n                                \"leakedvideo\",\n                                \"line\",\n                                \"linkedin\",\n                                \"malware\",\n                                \"monero\",\n                                \"otherfile\",\n                                \"pastebin\",\n                                \"pgp\",\n                                \"serverstatus\",\n                                \"session\",\n                                \"shorten\",\n                                \"sshkey\",\n                                \"sslkey\",\n                                \"tel\",\n                                \"telegram\",\n                                \"tor\",\n                                \"torurl\",\n                                \"twitter\",\n                                \"url\",\n                            ],\n                        },\n                        \"text\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search keyword or data to find. Supports AND, OR, NOT operators (max 3 OR, 5 total operators)\",\n                        },\n                        \"target\": {\n                            \"type\": \"string\",\n                            \"description\": \"Target type to search (default: 'all'). Use comma-separated values for multiple targets\",\n                            \"default\": \"all\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Ordering type\",\n                            \"enum\": [\"createDate\", \"value\"],\n                            \"default\": \"createDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\", \"text\"],\n                },\n            ),\n            Tool(\n                name=\"search_telegram\",\n                description=\"Search Telegram content for indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type to search for\",\n                            \"enum\": [\n                                \"band\",\n                                \"bitcoin\",\n                                \"creditcard\",\n                                \"cve\",\n                                \"discord\",\n                                \"document\",\n                                \"domain\",\n                                \"email\",\n                                \"ethereum\",\n                                \"exefile\",\n                                \"facebook\",\n                                \"filehosting\",\n                                \"googledrive\",\n                                \"gps\",\n                                \"hash\",\n                                \"hashstring\",\n                                \"i2p\",\n                                \"i2purl\",\n                                \"id\",\n                                \"image\",\n                                \"instagram\",\n                                \"ip\",\n                                \"kakaotalk\",\n                                \"keyword\",\n                                \"kssn\",\n                                \"line\",\n                                \"monero\",\n                                \"otherfile\",\n                                \"pastebin\",\n                                \"pgp\",\n                                \"tel\",\n                                \"session\",\n                                \"shorten\",\n                                \"telegram\",\n                                \"telegram.channel\",\n                                \"telegram.message\",\n                                \"telegram.user\",\n                                \"tor\",\n                                \"torurl\",\n                                \"tox\",\n                                \"twitter\",\n                                \"url\",\n                            ],\n                        },\n                        \"text\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search keyword or data to find. Supports AND, OR, NOT operators (max 3 OR, 5 total operators)\",\n                        },\n                        \"target\": {\n                            \"type\": \"string\",\n                            \"description\": \"Target type to search (default: 'all'). Use comma-separated values for multiple targets\",\n                            \"default\": \"all\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Ordering type\",\n                            \"enum\": [\"createDate\", \"value\"],\n                            \"default\": \"createDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\", \"text\"],\n                },\n            ),\n            Tool(\n                name=\"search_credentials\",\n                description=\"Search for leaked credentials using keywords or specific indicators (domain:, email:, id:, password:, after:, before:)\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - can use indicators like 'domain:example.com', 'email:user@domain.com', 'id:username', 'password:pass123', 'after:2023-01', 'before:2024-01' or plain keywords\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\n                                \"leakedDate\",\n                                \"domain\",\n                                \"email\",\n                                \"password\",\n                                \"leakedFrom\",\n                            ],\n                            \"default\": \"leakedDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                        \"start\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Filter data added to the system after start time (UTC timestamp)\",\n                        },\n                        \"end\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Filter data added to the system before end time (UTC timestamp)\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_ransomware\",\n                description=\"Search ransomware monitoring data using torurl: or domain: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'torurl:site.onion' to search ransomware sites or 'domain:victim.com' to search victim websites. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"victim\", \"attackGroup\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"get_node_details\",\n                description=\"Get detailed information about a specific node\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"node_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Node ID to get details for\",\n                        },\n                        \"pid\": {\n                            \"type\": \"string\",\n                            \"description\": \"Parent node ID (optional)\",\n                        },\n                        \"data_from\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Import data source list (default: False)\",\n                            \"default\": False,\n                        },\n                        \"include_url\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Import included URL list (default: False)\",\n                            \"default\": False,\n                        },\n                        \"include_contents\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Include HTML source contents for torurl, i2purl, url (default: True)\",\n                            \"default\": True,\n                        },\n                    },\n                    \"required\": [\"service\", \"node_id\"],\n                },\n            ),\n            Tool(\n                name=\"get_targets\",\n                description=\"Get available search targets for a service and indicator\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type\",\n                        },\n                    },\n                    \"required\": [\"service\", \"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_data\",\n                description=\"Export search results in specified format\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"service\", \"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_compromised_dataset\",\n                description=\"Search compromised data set information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_compromised_dataset\",\n                description=\"Export compromised data set as CSV/JSON\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"get_compromised_dataset_node\",\n                description=\"Get detailed compromised data set node information (Cyber Security Edition required)\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"node_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Node ID to get details for\",\n                        }\n                    },\n                    \"required\": [\"node_id\"],\n                },\n            ),\n            Tool(\n                name=\"search_combo_binder\",\n                description=\"Search leaked ID/Password combo information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_combo_binder\",\n                description=\"Export combo binder data as CSV/JSON\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_ulp_binder\",\n                description=\"Search URL-Login-Password combination information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_ulp_binder\",\n                description=\"Export ULP binder data as CSV/JSON\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_government_monitoring\",\n                description=\"Search government sector threat monitoring data using url: or id: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'url:hackersite.com' to search threat event URLs or 'id:hacker123' to search actor IDs. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"title\", \"author\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_leaked_monitoring\",\n                description=\"Search enterprise sector threat monitoring data using url: or id: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'url:hackersite.com' to search threat event URLs or 'id:hacker123' to search actor IDs. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"title\", \"author\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"download_file\",\n                description=\"Download file by hash from dt or tt service\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt or tt)\",\n                            \"enum\": [\"dt\", \"tt\"],\n                        },\n                        \"file_hash\": {\n                            \"type\": \"string\",\n                            \"description\": \"File hash to download\",\n                        },\n                    },\n                    \"required\": [\"service\", \"file_hash\"],\n                },\n            ),\n            Tool(\n                name=\"search_pagination\",\n                description=\"Pagination search using search ID for dt or tt service\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt or tt)\",\n                            \"enum\": [\"dt\", \"tt\"],\n                        },\n                        \"search_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search ID from previous search\",\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"service\", \"search_id\"],\n                },\n            ),\n            Tool(\n                name=\"get_user_quotas\",\n                description=\"Get API usage quotas by service\",\n                inputSchema={\"type\": \"object\", \"properties\": {}, \"required\": []},\n            ),\n        ]\n    except Exception as e:\n        print(f\"Error in handle_list_tools: {e}\", file=sys.stderr)\n        import traceback\n\n        traceback.print_exc(file=sys.stderr)\n        return []\n\n\ndef apply_default_behavior(name: str, arguments: dict[str, Any]) -> dict[str, Any]:\n    \"\"\"Apply default behavior rules to tool arguments.\"\"\"\n    # Always set limit to maximum value\n    if \"limit\" in arguments:\n        if name in [\"search_darkweb\", \"search_telegram\"]:\n            arguments[\"limit\"] = 100\n        elif name in [\n            \"search_credentials\",\n            \"search_ransomware\",\n            \"search_compromised_dataset\",\n            \"search_combo_binder\",\n            \"search_ulp_binder\",\n            \"search_government_monitoring\",\n            \"search_leaked_monitoring\",\n        ]:\n            arguments[\"limit\"] = 50\n\n    # Handle indicator defaults for search tools\n    if name in [\"search_darkweb\", \"search_telegram\"]:\n        if \"indicator\" not in arguments or not arguments[\"indicator\"]:\n            arguments[\"indicator\"] = \"keyword\"\n\n    return arguments\n\n\n@server.call_tool()\nasync def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:\n    \"\"\"Handle tool calls with default behavior applied.\"\"\"\n    global client\n\n    if client is None:\n        return [\n            TextContent(\n                type=\"text\",\n                text=\"Error: StealthMole client not initialized. Please check your API credentials.\",\n            )\n        ]\n\n    # Apply default behavior rules\n    arguments = apply_default_behavior(name, arguments)\n\n    # Add system prompt context to response\n    response_prefix = f\"[StealthMole MCP Server]\\n{DEFAULT_SYSTEM_PROMPT}\\n\\n\"\n\n    try:\n        if name == \"search_darkweb\":\n            result = await client.search_darkweb(\n                indicator=arguments[\"indicator\"],\n                text=arguments[\"text\"],\n                target=arguments.get(\"target\", \"all\"),\n                limit=arguments.get(\"limit\", 50),\n                orderType=arguments.get(\"orderType\", \"createDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_telegram\":\n            result = await client.search_telegram(\n                indicator=arguments[\"indicator\"],\n                text=arguments[\"text\"],\n                target=arguments.get(\"target\", \"all\"),\n                limit=arguments.get(\"limit\", 50),\n                orderType=arguments.get(\"orderType\", \"createDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_credentials\":\n            result = await client.search_credentials(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"leakedDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n                start=arguments.get(\"start\"),\n                end=arguments.get(\"end\"),\n            )\n        elif name == \"search_ransomware\":\n            result = await client.search_ransomware(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"get_node_details\":\n            result = await client.get_node_details(\n                service=arguments[\"service\"],\n                node_id=arguments[\"node_id\"],\n                pid=arguments.get(\"pid\"),\n                data_from=arguments.get(\"data_from\", False),\n                include_url=arguments.get(\"include_url\", False),\n                include_contents=arguments.get(\"include_contents\", True),\n            )\n        elif name == \"get_targets\":\n            result = await client.get_targets(\n                service=arguments[\"service\"], indicator=arguments[\"indicator\"]\n            )\n        elif name == \"export_data\":\n            result = await client.export_data(\n                service=arguments[\"service\"],\n                indicator=arguments[\"indicator\"],\n                format=arguments.get(\"format\", \"json\"),\n            )\n        elif name == \"search_compromised_dataset\":\n            result = await client.search_compromised_dataset(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"export_compromised_dataset\":\n            result = await client.export_compromised_dataset(\n                indicator=arguments[\"indicator\"], format=arguments.get(\"format\", \"json\")\n            )\n        elif name == \"get_compromised_dataset_node\":\n            result = await client.get_compromised_dataset_node(\n                node_id=arguments[\"node_id\"]\n            )\n        elif name == \"search_combo_binder\":\n            result = await client.search_combo_binder(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"export_combo_binder\":\n            result = await client.export_combo_binder(\n                indicator=arguments[\"indicator\"], format=arguments.get(\"format\", \"json\")\n            )\n        elif name == \"search_ulp_binder\":\n            result = await client.search_ulp_binder(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"export_ulp_binder\":\n            result = await client.export_ulp_binder(\n                indicator=arguments[\"indicator\"], format=arguments.get(\"format\", \"json\")\n            )\n        elif name == \"search_government_monitoring\":\n            result = await client.search_government_monitoring(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_leaked_monitoring\":\n            result = await client.search_leaked_monitoring(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"download_file\":\n            file_content = await client.download_file(\n                service=arguments[\"service\"], file_hash=arguments[\"file_hash\"]\n            )\n            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"Downloaded file {arguments['file_hash']} from {arguments['service']} service. File size: {len(file_content)} bytes\",\n                )\n            ]\n        elif name == \"search_pagination\":\n            result = await client.search_pagination(\n                service=arguments[\"service\"],\n                search_id=arguments[\"search_id\"],\n                cursor=arguments.get(\"cursor\", 0),\n                limit=arguments.get(\"limit\", 50),\n            )\n        elif name == \"get_user_quotas\":\n            result = await client.get_user_quotas()\n        else:\n            return [TextContent(type=\"text\", text=f\"Unknown tool: {name}\")]\n\n        # Format response with system behavior context\n        response_text = f\"{response_prefix}StealthMole API Results:\\n\\n{result}\\n\\n---\\nWould you like to browse the next page of results?\"\n        return [TextContent(type=\"text\", text=response_text)]\n\n    except asyncio.TimeoutError:\n        return [\n            TextContent(\n                type=\"text\",\n                text=f\"{response_prefix}Request timed out. The API request took too long to complete.\",\n            )\n        ]\n    except Exception as e:\n        error_msg = str(e)\n        if \"timeout\" in error_msg.lower():\n            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"{response_prefix}Timeout error: {error_msg}. Try reducing the result limit or check your network connection.\",\n                )\n            ]\n        return [\n            TextContent(\n                type=\"text\",\n                text=f\"{response_prefix}Error calling StealthMole API: {error_msg}\",\n            )\n        ]\n\n\nasync def run_server():\n    \"\"\"Run the MCP server.\"\"\"\n    global client\n\n    try:\n        print(\"Starting StealthMole MCP server...\", file=sys.stderr)\n\n        # Initialize StealthMole client\n        access_key = os.getenv(\"STEALTHMOLE_ACCESS_KEY\")\n        secret_key = os.getenv(\"STEALTHMOLE_SECRET_KEY\")\n\n        print(f\"Access key: {'SET' if access_key else 'NOT SET'}\", file=sys.stderr)\n        print(f\"Secret key: {'SET' if secret_key else 'NOT SET'}\", file=sys.stderr)\n\n        if not access_key or not secret_key:\n            print(\n                \"Warning: STEALTHMOLE_ACCESS_KEY and STEALTHMOLE_SECRET_KEY environment variables not set\",\n                file=sys.stderr,\n            )\n            print(\"MCP server will start but tools will not function\", file=sys.stderr)\n        else:\n            try:\n                config = StealthMoleConfig(access_key=access_key, secret_key=secret_key)\n                print(\"StealthMole config created\", file=sys.stderr)\n                client = StealthMoleClient(config)\n                print(\"StealthMole client initialized\", file=sys.stderr)\n\n                # API 연결 테스트 (타임아웃 없이 간단히)\n                try:\n                    quotas = await client.get_user_quotas()\n                    print(\n                        f\"✓ API connection successful. Available quotas: {quotas}\",\n                        file=sys.stderr,\n                    )\n                except Exception as api_error:\n                    print(f\"Warning: API test failed: {api_error}\", file=sys.stderr)\n                    print(\"Continuing with server startup...\", file=sys.stderr)\n\n            except Exception as e:\n                print(\n                    f\"Warning: Error creating StealthMole client: {e}\", file=sys.stderr\n                )\n                print(\n                    \"MCP server will start but tools may not function properly\",\n                    file=sys.stderr,\n                )\n                import traceback\n\n                traceback.print_exc(file=sys.stderr)\n\n        print(\"Creating stdio server...\", file=sys.stderr)\n        async with stdio_server() as (read_stream, write_stream):\n            print(\"Starting MCP server...\", file=sys.stderr)\n            try:\n                await server.run(\n                    read_stream,\n                    write_stream,\n                    InitializationOptions(\n                        server_name=\"stealthmole-mcp\",\n                        server_version=\"0.1.0\",\n                        capabilities=server.get_capabilities(\n                            notification_options=NotificationOptions(),\n                            experimental_capabilities={},\n                        ),\n                    ),\n                )\n                print(\"MCP server completed normally\", file=sys.stderr)\n            except Exception as e:\n                print(f\"Error in MCP server.run: {e}\", file=sys.stderr)\n                import traceback\n\n                traceback.print_exc(file=sys.stderr)\n                raise\n    except Exception as e:\n        print(f\"Error in run_server: {e}\", file=sys.stderr)\n        import traceback\n\n        traceback.print_exc(file=sys.stderr)\n\n\ndef main():\n    \"\"\"Main entry point for the MCP server.\"\"\"\n    asyncio.run(run_server())\n\n\nif __name__ == \"__main__\":\n    main()\n","numLines":966,"startLine":1,"totalLines":966}}}
{"parentUuid":"dc2d86cc-2800-4034-ad0d-0ab7b738e43b","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"26b95f0f-af56-4fa2-9e24-f2b4047c0696","version":"1.0.51","message":{"id":"msg_01HaHvzx6kNFupebyEPiggzj","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"MCP 서버에서 default prompt가 응답에 포함되는 설정을 확인했습니다.\n\n**현재 설정된 방식이 맞지 않습니다.** `server.py:726-727`에서 모든 도구 응답에 default prompt를 자동으로 포함시키고 있는데, 이는 다음과 같은 문제를 일으킵니다:\n\n1. **불필요한 반복**: 모든 API 응답마다 동일한 프롬프트가 반복 출력됨\n2. **응답 품질 저하**: 실제 데이터보다 시스템 메시지가 더 많은 공간을 차지\n3. **사용자 혼란**: Neo 관련 지침이 모든 응답에 포함되어 의미가 불분명\n\n**권장 해결 방법:**\n\n1. **기본 시스템 프롬프트 제거**: 도구 응답에서 `DEFAULT_SYSTEM_PROMPT` 자동 추가를 중단\n2. **사용자 안내로 대체**: 필요시 사용자가 직접 지침을 요청할 수 있도록 안내\n3. **도구별 맞춤 응답**: 각 도구의 실제 결과만 반환하여 가독성 향상\n\n`server.py:726-727`, `852`, `859`, `868`, `874` 라인의 `response_prefix` 관련 코드를 제거하는 것이 좋겠습니다."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":11696,"cache_read_input_tokens":14468,"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CR8DFzTtMvigfo19yP38q","type":"assistant","uuid":"987d9a6c-b76c-4ef2-839a-6b922a7009d0","timestamp":"2025-07-15T04:58:02.950Z"}
{"parentUuid":"987d9a6c-b76c-4ef2-839a-6b922a7009d0","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"26b95f0f-af56-4fa2-9e24-f2b4047c0696","version":"1.0.51","type":"user","message":{"role":"user","content":"시스템 초기화시 AI에게 default_system_prompt를 한번 전달하고싶은데 이런경우에는 어떻게 하면 좋을까?"},"uuid":"25605d37-5a8b-4ca1-8224-064e6e268019","timestamp":"2025-07-15T04:59:09.901Z"}
{"parentUuid":"25605d37-5a8b-4ca1-8224-064e6e268019","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"26b95f0f-af56-4fa2-9e24-f2b4047c0696","version":"1.0.51","message":{"id":"msg_01W7NVydx9MEAn8mRp1ZrfAa","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"MCP 서버에서 AI에게 시스템 초기화 시 한번만 default prompt를 전달하려면 **MCP의 Prompt 기능**을 사용하는 것이 가장 적절합니다."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":504,"cache_read_input_tokens":26164,"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CR8DMfS4uqnwBDRN1PFXE","type":"assistant","uuid":"7fed162c-bbec-4f54-a6e5-d860687d812b","timestamp":"2025-07-15T04:59:14.489Z"}
{"parentUuid":"7fed162c-bbec-4f54-a6e5-d860687d812b","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"26b95f0f-af56-4fa2-9e24-f2b4047c0696","version":"1.0.51","message":{"id":"msg_01W7NVydx9MEAn8mRp1ZrfAa","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_017wfz439Fo8qAnHhhUJdKSc","name":"Read","input":{"file_path":"/Users/realsun/data/git/mole-mcp-server/src/server.py","offset":36,"limit":10}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":504,"cache_read_input_tokens":26164,"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CR8DMfS4uqnwBDRN1PFXE","type":"assistant","uuid":"549482a5-4bf2-44bf-aefd-c06fb8420c21","timestamp":"2025-07-15T04:59:15.820Z"}
{"parentUuid":"549482a5-4bf2-44bf-aefd-c06fb8420c21","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"26b95f0f-af56-4fa2-9e24-f2b4047c0696","version":"1.0.51","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017wfz439Fo8qAnHhhUJdKSc","type":"tool_result","content":"    36→@server.list_resources()\n    37→async def handle_list_resources() -> list[Resource]:\n    38→    \"\"\"List available resources.\"\"\"\n    39→    return []\n    40→\n    41→\n    42→@server.read_resource()\n    43→async def handle_read_resource(uri: AnyUrl) -> str:\n    44→    \"\"\"Read a specific resource.\"\"\"\n    45→    raise ValueError(f\"Unknown resource: {uri}\")\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"8e27000e-582d-43cf-8ee6-e816c4c37914","timestamp":"2025-07-15T04:59:15.854Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/realsun/data/git/mole-mcp-server/src/server.py","content":"@server.list_resources()\nasync def handle_list_resources() -> list[Resource]:\n    \"\"\"List available resources.\"\"\"\n    return []\n\n\n@server.read_resource()\nasync def handle_read_resource(uri: AnyUrl) -> str:\n    \"\"\"Read a specific resource.\"\"\"\n    raise ValueError(f\"Unknown resource: {uri}\")","numLines":10,"startLine":36,"totalLines":966}}}
{"parentUuid":"8e27000e-582d-43cf-8ee6-e816c4c37914","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"26b95f0f-af56-4fa2-9e24-f2b4047c0696","version":"1.0.51","message":{"id":"msg_01NnNxRx3Loe7K1vDTDp1qex","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"**권장 해결 방법:**\n\nMCP의 **Prompt 기능**을 사용하여 시스템 초기화 시 AI가 자동으로 읽을 수 있는 프롬프트를 제공하세요:\n\n```python\n@server.list_prompts()\nasync def handle_list_prompts() -> list[Prompt]:\n    \"\"\"List available prompts.\"\"\"\n    return [\n        Prompt(\n            name=\"neo_behavior_guide\",\n            description=\"StealthMole Neo behavior guidelines for search operations\",\n            arguments=[\n                PromptArgument(\n                    name=\"context\",\n                    description=\"Current search context\",\n                    required=False\n                )\n            ]\n        )\n    ]\n\n@server.get_prompt()\nasync def handle_get_prompt(name: str, arguments: dict[str, str] | None = None) -> PromptMessage:\n    \"\"\"Get a specific prompt.\"\"\"\n    if name == \"neo_behavior_guide\":\n        return PromptMessage(\n            role=\"system\",\n            content=TextContent(\n                type=\"text\", \n                text=DEFAULT_SYSTEM_PROMPT\n            )\n        )\n    else:\n        raise ValueError(f\"Unknown prompt: {name}\")\n```\n\n**이 방식의 장점:**\n\n1. **표준 MCP 패턴**: MCP 스펙에 정의된 표준 방식\n2. **선택적 사용**: AI가 필요할 때만 프롬프트를 읽음\n3. **깔끔한 응답**: 도구 응답에 시스템 메시지가 섞이지 않음\n4. **컨텍스트 제어**: AI가 적절한 시점에 가이드라인을 참조 가능\n\n**도구 응답에서는** `response_prefix` 부분을 제거하여 순수한 API 결과만 반환하도록 수정하면 됩니다."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":364,"cache_read_input_tokens":26668,"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CR8DN6q3LGAPK4BhCG1XZ","type":"assistant","uuid":"b58dbc03-f776-4b38-9343-9b018924067e","timestamp":"2025-07-15T04:59:25.937Z"}
{"parentUuid":"b58dbc03-f776-4b38-9343-9b018924067e","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"26b95f0f-af56-4fa2-9e24-f2b4047c0696","version":"1.0.51","type":"user","message":{"role":"user","content":"해당방식으로 수정을 진행해주세요."},"uuid":"15c74e97-908e-487f-981e-169870b9a209","timestamp":"2025-07-15T04:59:47.704Z"}
{"parentUuid":"15c74e97-908e-487f-981e-169870b9a209","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"26b95f0f-af56-4fa2-9e24-f2b4047c0696","version":"1.0.51","message":{"id":"msg_01SwePC1VD5eK1BjeQ9g517q","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01LTsQSmjA8cCfSRiZRGAdJi","name":"TodoWrite","input":{"todos":[{"id":"1","content":"Add MCP prompt handlers for system initialization","status":"pending","priority":"high"},{"id":"2","content":"Remove response_prefix from all tool responses","status":"pending","priority":"high"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":536,"cache_read_input_tokens":27032,"output_tokens":145,"service_tier":"standard"}},"requestId":"req_011CR8DQT7VLTdPjMLoiBxoC","type":"assistant","uuid":"dd2bf469-75a4-4c9c-afb8-fc2c7a9c7b71","timestamp":"2025-07-15T04:59:51.532Z"}
{"parentUuid":"dd2bf469-75a4-4c9c-afb8-fc2c7a9c7b71","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"26b95f0f-af56-4fa2-9e24-f2b4047c0696","version":"1.0.51","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LTsQSmjA8cCfSRiZRGAdJi","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"f73b0060-03bd-4e35-89cc-f2cc2df63f26","timestamp":"2025-07-15T04:59:51.570Z","toolUseResult":{"oldTodos":[],"newTodos":[{"content":"Add MCP prompt handlers for system initialization","status":"pending","priority":"high","id":"1"},{"content":"Remove response_prefix from all tool responses","status":"pending","priority":"high","id":"2"}]}}
{"parentUuid":"f73b0060-03bd-4e35-89cc-f2cc2df63f26","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"26b95f0f-af56-4fa2-9e24-f2b4047c0696","version":"1.0.51","message":{"id":"msg_016W1FtT8gosb2fDvv8uDN3s","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01MVqJskXCVTc1UBNiKq8121","name":"TodoWrite","input":{"todos":[{"id":"1","content":"Add MCP prompt handlers for system initialization","status":"in_progress","priority":"high"},{"id":"2","content":"Remove response_prefix from all tool responses","status":"pending","priority":"high"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":255,"cache_read_input_tokens":27568,"output_tokens":118,"service_tier":"standard"}},"requestId":"req_011CR8DQjVitkWPDiAwJShxj","type":"assistant","uuid":"b82ed893-bf64-40ea-a6e0-45ad404c71c8","timestamp":"2025-07-15T04:59:54.916Z"}
{"parentUuid":"b82ed893-bf64-40ea-a6e0-45ad404c71c8","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"26b95f0f-af56-4fa2-9e24-f2b4047c0696","version":"1.0.51","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MVqJskXCVTc1UBNiKq8121","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"3f541e7a-912f-4603-a10f-bb0ad8fb1061","timestamp":"2025-07-15T04:59:54.955Z","toolUseResult":{"oldTodos":[{"content":"Add MCP prompt handlers for system initialization","status":"pending","priority":"high","id":"1"},{"content":"Remove response_prefix from all tool responses","status":"pending","priority":"high","id":"2"}],"newTodos":[{"content":"Add MCP prompt handlers for system initialization","status":"in_progress","priority":"high","id":"1"},{"content":"Remove response_prefix from all tool responses","status":"pending","priority":"high","id":"2"}]}}
{"parentUuid":"3f541e7a-912f-4603-a10f-bb0ad8fb1061","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"26b95f0f-af56-4fa2-9e24-f2b4047c0696","version":"1.0.51","message":{"id":"msg_016w6LbwKptFxhhFiRm588Ux","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01GtEobTEascbjYA5ik7Eu6R","name":"Edit","input":{"file_path":"/Users/realsun/data/git/mole-mcp-server/src/server.py","old_string":"@server.list_resources()\nasync def handle_list_resources() -> list[Resource]:\n    \"\"\"List available resources.\"\"\"\n    return []\n\n\n@server.read_resource()\nasync def handle_read_resource(uri: AnyUrl) -> str:\n    \"\"\"Read a specific resource.\"\"\"\n    raise ValueError(f\"Unknown resource: {uri}\")","new_string":"@server.list_resources()\nasync def handle_list_resources() -> list[Resource]:\n    \"\"\"List available resources.\"\"\"\n    return []\n\n\n@server.read_resource()\nasync def handle_read_resource(uri: AnyUrl) -> str:\n    \"\"\"Read a specific resource.\"\"\"\n    raise ValueError(f\"Unknown resource: {uri}\")\n\n\n@server.list_prompts()\nasync def handle_list_prompts() -> list[Prompt]:\n    \"\"\"List available prompts.\"\"\"\n    return [\n        Prompt(\n            name=\"neo_behavior_guide\",\n            description=\"StealthMole Neo behavior guidelines for search operations\",\n            arguments=[\n                PromptArgument(\n                    name=\"context\",\n                    description=\"Current search context\",\n                    required=False\n                )\n            ]\n        )\n    ]\n\n\n@server.get_prompt()\nasync def handle_get_prompt(name: str, arguments: dict[str, str] | None = None) -> PromptMessage:\n    \"\"\"Get a specific prompt.\"\"\"\n    if name == \"neo_behavior_guide\":\n        return PromptMessage(\n            role=\"system\",\n            content=TextContent(\n                type=\"text\", \n                text=DEFAULT_SYSTEM_PROMPT\n            )\n        )\n    else:\n        raise ValueError(f\"Unknown prompt: {name}\")"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":261,"cache_read_input_tokens":27823,"output_tokens":22,"service_tier":"standard"}},"requestId":"req_011CR8DQyueVwYh3zAMUVctf","type":"assistant","uuid":"9c6404c9-fcd9-4a51-844f-19cbfee09372","timestamp":"2025-07-15T05:00:03.501Z"}
{"parentUuid":"9c6404c9-fcd9-4a51-844f-19cbfee09372","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"26b95f0f-af56-4fa2-9e24-f2b4047c0696","version":"1.0.51","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GtEobTEascbjYA5ik7Eu6R","type":"tool_result","content":"The file /Users/realsun/data/git/mole-mcp-server/src/server.py has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n    32→    \"0.2.0\",\n    33→)\n    34→\n    35→\n    36→@server.list_resources()\n    37→async def handle_list_resources() -> list[Resource]:\n    38→    \"\"\"List available resources.\"\"\"\n    39→    return []\n    40→\n    41→\n    42→@server.read_resource()\n    43→async def handle_read_resource(uri: AnyUrl) -> str:\n    44→    \"\"\"Read a specific resource.\"\"\"\n    45→    raise ValueError(f\"Unknown resource: {uri}\")\n    46→\n    47→\n    48→@server.list_prompts()\n    49→async def handle_list_prompts() -> list[Prompt]:\n    50→    \"\"\"List available prompts.\"\"\"\n    51→    return [\n    52→        Prompt(\n    53→            name=\"neo_behavior_guide\",\n    54→            description=\"StealthMole Neo behavior guidelines for search operations\",\n    55→            arguments=[\n    56→                PromptArgument(\n    57→                    name=\"context\",\n    58→                    description=\"Current search context\",\n    59→                    required=False\n    60→                )\n    61→            ]\n    62→        )\n    63→    ]\n    64→\n    65→\n    66→@server.get_prompt()\n    67→async def handle_get_prompt(name: str, arguments: dict[str, str] | None = None) -> PromptMessage:\n    68→    \"\"\"Get a specific prompt.\"\"\"\n    69→    if name == \"neo_behavior_guide\":\n    70→        return PromptMessage(\n    71→            role=\"system\",\n    72→            content=TextContent(\n    73→                type=\"text\", \n    74→                text=DEFAULT_SYSTEM_PROMPT\n    75→            )\n    76→        )\n    77→    else:\n    78→        raise ValueError(f\"Unknown prompt: {name}\")\n    79→\n    80→\n    81→@server.list_tools()\n    82→async def handle_list_tools() -> list[Tool]:"}]},"uuid":"ae950f08-c8c1-4a58-8dd9-043ebf60faa6","timestamp":"2025-07-15T05:00:15.952Z","toolUseResult":{"filePath":"/Users/realsun/data/git/mole-mcp-server/src/server.py","oldString":"@server.list_resources()\nasync def handle_list_resources() -> list[Resource]:\n    \"\"\"List available resources.\"\"\"\n    return []\n\n\n@server.read_resource()\nasync def handle_read_resource(uri: AnyUrl) -> str:\n    \"\"\"Read a specific resource.\"\"\"\n    raise ValueError(f\"Unknown resource: {uri}\")","newString":"@server.list_resources()\nasync def handle_list_resources() -> list[Resource]:\n    \"\"\"List available resources.\"\"\"\n    return []\n\n\n@server.read_resource()\nasync def handle_read_resource(uri: AnyUrl) -> str:\n    \"\"\"Read a specific resource.\"\"\"\n    raise ValueError(f\"Unknown resource: {uri}\")\n\n\n@server.list_prompts()\nasync def handle_list_prompts() -> list[Prompt]:\n    \"\"\"List available prompts.\"\"\"\n    return [\n        Prompt(\n            name=\"neo_behavior_guide\",\n            description=\"StealthMole Neo behavior guidelines for search operations\",\n            arguments=[\n                PromptArgument(\n                    name=\"context\",\n                    description=\"Current search context\",\n                    required=False\n                )\n            ]\n        )\n    ]\n\n\n@server.get_prompt()\nasync def handle_get_prompt(name: str, arguments: dict[str, str] | None = None) -> PromptMessage:\n    \"\"\"Get a specific prompt.\"\"\"\n    if name == \"neo_behavior_guide\":\n        return PromptMessage(\n            role=\"system\",\n            content=TextContent(\n                type=\"text\", \n                text=DEFAULT_SYSTEM_PROMPT\n            )\n        )\n    else:\n        raise ValueError(f\"Unknown prompt: {name}\")","originalFile":"\"\"\"StealthMole MCP Server implementation.\"\"\"\n\nimport asyncio\nimport os\nimport sys\nfrom typing import Any, Optional, Sequence\n\nfrom dotenv import load_dotenv\nfrom mcp.server import NotificationOptions, Server\nfrom mcp.server.models import InitializationOptions\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import Prompt, PromptArgument, PromptMessage, Resource, TextContent, Tool\nfrom pydantic import AnyUrl\n\nfrom src.tools import *\nfrom src.utils.client import StealthMoleClient\nfrom src.utils.config import StealthMoleConfig\n\nload_dotenv()\n\n# Global client instance\nclient: Optional[StealthMoleClient] = None\n\n# Default system prompt for Neo behavior\nDEFAULT_SYSTEM_PROMPT = \"\"\"If you don't mention a specific indicator, Neo will default to searching by keyword.\nIf a different indicator is requested, but not explicitly in the form indicator:query, it will say \"Perform additional searches with keyword to gather more information.\" and proceed. \nAlways set limit to the maximum value.\nWe also ask the user if they want to browse the next page:\"\"\"\n\nserver: Server = Server(\n    \"stealthmole-mcp\",\n    \"0.2.0\",\n)\n\n\n@server.list_resources()\nasync def handle_list_resources() -> list[Resource]:\n    \"\"\"List available resources.\"\"\"\n    return []\n\n\n@server.read_resource()\nasync def handle_read_resource(uri: AnyUrl) -> str:\n    \"\"\"Read a specific resource.\"\"\"\n    raise ValueError(f\"Unknown resource: {uri}\")\n\n\n@server.list_tools()\nasync def handle_list_tools() -> list[Tool]:\n    \"\"\"List available StealthMole tools.\"\"\"\n    try:\n        print(\"Returning StealthMole tools list\", file=sys.stderr)\n        return [\n            Tool(\n                name=\"search_darkweb\",\n                description=\"Search dark web content for indicators like domains, IPs, emails, etc.\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type to search for\",\n                            \"enum\": [\n                                \"adsense\",\n                                \"analyticsid\",\n                                \"band\",\n                                \"bitcoin\",\n                                \"blueprint\",\n                                \"creditcard\",\n                                \"cve\",\n                                \"discord\",\n                                \"document\",\n                                \"domain\",\n                                \"email\",\n                                \"ethereum\",\n                                \"exefile\",\n                                \"facebook\",\n                                \"filehosting\",\n                                \"googledrive\",\n                                \"gps\",\n                                \"hash\",\n                                \"hashstring\",\n                                \"i2p\",\n                                \"i2purl\",\n                                \"id\",\n                                \"image\",\n                                \"instagram\",\n                                \"ioc\",\n                                \"ip\",\n                                \"kakaotalk\",\n                                \"keyword\",\n                                \"kssn\",\n                                \"leakedaudio\",\n                                \"leakedemailfile\",\n                                \"leakedvideo\",\n                                \"line\",\n                                \"linkedin\",\n                                \"malware\",\n                                \"monero\",\n                                \"otherfile\",\n                                \"pastebin\",\n                                \"pgp\",\n                                \"serverstatus\",\n                                \"session\",\n                                \"shorten\",\n                                \"sshkey\",\n                                \"sslkey\",\n                                \"tel\",\n                                \"telegram\",\n                                \"tor\",\n                                \"torurl\",\n                                \"twitter\",\n                                \"url\",\n                            ],\n                        },\n                        \"text\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search keyword or data to find. Supports AND, OR, NOT operators (max 3 OR, 5 total operators)\",\n                        },\n                        \"target\": {\n                            \"type\": \"string\",\n                            \"description\": \"Target type to search (default: 'all'). Use comma-separated values for multiple targets\",\n                            \"default\": \"all\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Ordering type\",\n                            \"enum\": [\"createDate\", \"value\"],\n                            \"default\": \"createDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\", \"text\"],\n                },\n            ),\n            Tool(\n                name=\"search_telegram\",\n                description=\"Search Telegram content for indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type to search for\",\n                            \"enum\": [\n                                \"band\",\n                                \"bitcoin\",\n                                \"creditcard\",\n                                \"cve\",\n                                \"discord\",\n                                \"document\",\n                                \"domain\",\n                                \"email\",\n                                \"ethereum\",\n                                \"exefile\",\n                                \"facebook\",\n                                \"filehosting\",\n                                \"googledrive\",\n                                \"gps\",\n                                \"hash\",\n                                \"hashstring\",\n                                \"i2p\",\n                                \"i2purl\",\n                                \"id\",\n                                \"image\",\n                                \"instagram\",\n                                \"ip\",\n                                \"kakaotalk\",\n                                \"keyword\",\n                                \"kssn\",\n                                \"line\",\n                                \"monero\",\n                                \"otherfile\",\n                                \"pastebin\",\n                                \"pgp\",\n                                \"tel\",\n                                \"session\",\n                                \"shorten\",\n                                \"telegram\",\n                                \"telegram.channel\",\n                                \"telegram.message\",\n                                \"telegram.user\",\n                                \"tor\",\n                                \"torurl\",\n                                \"tox\",\n                                \"twitter\",\n                                \"url\",\n                            ],\n                        },\n                        \"text\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search keyword or data to find. Supports AND, OR, NOT operators (max 3 OR, 5 total operators)\",\n                        },\n                        \"target\": {\n                            \"type\": \"string\",\n                            \"description\": \"Target type to search (default: 'all'). Use comma-separated values for multiple targets\",\n                            \"default\": \"all\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Ordering type\",\n                            \"enum\": [\"createDate\", \"value\"],\n                            \"default\": \"createDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\", \"text\"],\n                },\n            ),\n            Tool(\n                name=\"search_credentials\",\n                description=\"Search for leaked credentials using keywords or specific indicators (domain:, email:, id:, password:, after:, before:)\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - can use indicators like 'domain:example.com', 'email:user@domain.com', 'id:username', 'password:pass123', 'after:2023-01', 'before:2024-01' or plain keywords\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\n                                \"leakedDate\",\n                                \"domain\",\n                                \"email\",\n                                \"password\",\n                                \"leakedFrom\",\n                            ],\n                            \"default\": \"leakedDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                        \"start\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Filter data added to the system after start time (UTC timestamp)\",\n                        },\n                        \"end\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Filter data added to the system before end time (UTC timestamp)\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_ransomware\",\n                description=\"Search ransomware monitoring data using torurl: or domain: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'torurl:site.onion' to search ransomware sites or 'domain:victim.com' to search victim websites. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"victim\", \"attackGroup\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"get_node_details\",\n                description=\"Get detailed information about a specific node\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"node_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Node ID to get details for\",\n                        },\n                        \"pid\": {\n                            \"type\": \"string\",\n                            \"description\": \"Parent node ID (optional)\",\n                        },\n                        \"data_from\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Import data source list (default: False)\",\n                            \"default\": False,\n                        },\n                        \"include_url\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Import included URL list (default: False)\",\n                            \"default\": False,\n                        },\n                        \"include_contents\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Include HTML source contents for torurl, i2purl, url (default: True)\",\n                            \"default\": True,\n                        },\n                    },\n                    \"required\": [\"service\", \"node_id\"],\n                },\n            ),\n            Tool(\n                name=\"get_targets\",\n                description=\"Get available search targets for a service and indicator\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type\",\n                        },\n                    },\n                    \"required\": [\"service\", \"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_data\",\n                description=\"Export search results in specified format\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"service\", \"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_compromised_dataset\",\n                description=\"Search compromised data set information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_compromised_dataset\",\n                description=\"Export compromised data set as CSV/JSON\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"get_compromised_dataset_node\",\n                description=\"Get detailed compromised data set node information (Cyber Security Edition required)\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"node_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Node ID to get details for\",\n                        }\n                    },\n                    \"required\": [\"node_id\"],\n                },\n            ),\n            Tool(\n                name=\"search_combo_binder\",\n                description=\"Search leaked ID/Password combo information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_combo_binder\",\n                description=\"Export combo binder data as CSV/JSON\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_ulp_binder\",\n                description=\"Search URL-Login-Password combination information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_ulp_binder\",\n                description=\"Export ULP binder data as CSV/JSON\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_government_monitoring\",\n                description=\"Search government sector threat monitoring data using url: or id: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'url:hackersite.com' to search threat event URLs or 'id:hacker123' to search actor IDs. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"title\", \"author\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_leaked_monitoring\",\n                description=\"Search enterprise sector threat monitoring data using url: or id: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'url:hackersite.com' to search threat event URLs or 'id:hacker123' to search actor IDs. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"title\", \"author\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"download_file\",\n                description=\"Download file by hash from dt or tt service\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt or tt)\",\n                            \"enum\": [\"dt\", \"tt\"],\n                        },\n                        \"file_hash\": {\n                            \"type\": \"string\",\n                            \"description\": \"File hash to download\",\n                        },\n                    },\n                    \"required\": [\"service\", \"file_hash\"],\n                },\n            ),\n            Tool(\n                name=\"search_pagination\",\n                description=\"Pagination search using search ID for dt or tt service\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt or tt)\",\n                            \"enum\": [\"dt\", \"tt\"],\n                        },\n                        \"search_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search ID from previous search\",\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"service\", \"search_id\"],\n                },\n            ),\n            Tool(\n                name=\"get_user_quotas\",\n                description=\"Get API usage quotas by service\",\n                inputSchema={\"type\": \"object\", \"properties\": {}, \"required\": []},\n            ),\n        ]\n    except Exception as e:\n        print(f\"Error in handle_list_tools: {e}\", file=sys.stderr)\n        import traceback\n\n        traceback.print_exc(file=sys.stderr)\n        return []\n\n\ndef apply_default_behavior(name: str, arguments: dict[str, Any]) -> dict[str, Any]:\n    \"\"\"Apply default behavior rules to tool arguments.\"\"\"\n    # Always set limit to maximum value\n    if \"limit\" in arguments:\n        if name in [\"search_darkweb\", \"search_telegram\"]:\n            arguments[\"limit\"] = 100\n        elif name in [\n            \"search_credentials\",\n            \"search_ransomware\",\n            \"search_compromised_dataset\",\n            \"search_combo_binder\",\n            \"search_ulp_binder\",\n            \"search_government_monitoring\",\n            \"search_leaked_monitoring\",\n        ]:\n            arguments[\"limit\"] = 50\n\n    # Handle indicator defaults for search tools\n    if name in [\"search_darkweb\", \"search_telegram\"]:\n        if \"indicator\" not in arguments or not arguments[\"indicator\"]:\n            arguments[\"indicator\"] = \"keyword\"\n\n    return arguments\n\n\n@server.call_tool()\nasync def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:\n    \"\"\"Handle tool calls with default behavior applied.\"\"\"\n    global client\n\n    if client is None:\n        return [\n            TextContent(\n                type=\"text\",\n                text=\"Error: StealthMole client not initialized. Please check your API credentials.\",\n            )\n        ]\n\n    # Apply default behavior rules\n    arguments = apply_default_behavior(name, arguments)\n\n    # Add system prompt context to response\n    response_prefix = f\"[StealthMole MCP Server]\\n{DEFAULT_SYSTEM_PROMPT}\\n\\n\"\n\n    try:\n        if name == \"search_darkweb\":\n            result = await client.search_darkweb(\n                indicator=arguments[\"indicator\"],\n                text=arguments[\"text\"],\n                target=arguments.get(\"target\", \"all\"),\n                limit=arguments.get(\"limit\", 50),\n                orderType=arguments.get(\"orderType\", \"createDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_telegram\":\n            result = await client.search_telegram(\n                indicator=arguments[\"indicator\"],\n                text=arguments[\"text\"],\n                target=arguments.get(\"target\", \"all\"),\n                limit=arguments.get(\"limit\", 50),\n                orderType=arguments.get(\"orderType\", \"createDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_credentials\":\n            result = await client.search_credentials(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"leakedDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n                start=arguments.get(\"start\"),\n                end=arguments.get(\"end\"),\n            )\n        elif name == \"search_ransomware\":\n            result = await client.search_ransomware(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"get_node_details\":\n            result = await client.get_node_details(\n                service=arguments[\"service\"],\n                node_id=arguments[\"node_id\"],\n                pid=arguments.get(\"pid\"),\n                data_from=arguments.get(\"data_from\", False),\n                include_url=arguments.get(\"include_url\", False),\n                include_contents=arguments.get(\"include_contents\", True),\n            )\n        elif name == \"get_targets\":\n            result = await client.get_targets(\n                service=arguments[\"service\"], indicator=arguments[\"indicator\"]\n            )\n        elif name == \"export_data\":\n            result = await client.export_data(\n                service=arguments[\"service\"],\n                indicator=arguments[\"indicator\"],\n                format=arguments.get(\"format\", \"json\"),\n            )\n        elif name == \"search_compromised_dataset\":\n            result = await client.search_compromised_dataset(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"export_compromised_dataset\":\n            result = await client.export_compromised_dataset(\n                indicator=arguments[\"indicator\"], format=arguments.get(\"format\", \"json\")\n            )\n        elif name == \"get_compromised_dataset_node\":\n            result = await client.get_compromised_dataset_node(\n                node_id=arguments[\"node_id\"]\n            )\n        elif name == \"search_combo_binder\":\n            result = await client.search_combo_binder(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"export_combo_binder\":\n            result = await client.export_combo_binder(\n                indicator=arguments[\"indicator\"], format=arguments.get(\"format\", \"json\")\n            )\n        elif name == \"search_ulp_binder\":\n            result = await client.search_ulp_binder(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"export_ulp_binder\":\n            result = await client.export_ulp_binder(\n                indicator=arguments[\"indicator\"], format=arguments.get(\"format\", \"json\")\n            )\n        elif name == \"search_government_monitoring\":\n            result = await client.search_government_monitoring(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_leaked_monitoring\":\n            result = await client.search_leaked_monitoring(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"download_file\":\n            file_content = await client.download_file(\n                service=arguments[\"service\"], file_hash=arguments[\"file_hash\"]\n            )\n            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"Downloaded file {arguments['file_hash']} from {arguments['service']} service. File size: {len(file_content)} bytes\",\n                )\n            ]\n        elif name == \"search_pagination\":\n            result = await client.search_pagination(\n                service=arguments[\"service\"],\n                search_id=arguments[\"search_id\"],\n                cursor=arguments.get(\"cursor\", 0),\n                limit=arguments.get(\"limit\", 50),\n            )\n        elif name == \"get_user_quotas\":\n            result = await client.get_user_quotas()\n        else:\n            return [TextContent(type=\"text\", text=f\"Unknown tool: {name}\")]\n\n        # Format response with system behavior context\n        response_text = f\"{response_prefix}StealthMole API Results:\\n\\n{result}\\n\\n---\\nWould you like to browse the next page of results?\"\n        return [TextContent(type=\"text\", text=response_text)]\n\n    except asyncio.TimeoutError:\n        return [\n            TextContent(\n                type=\"text\",\n                text=f\"{response_prefix}Request timed out. The API request took too long to complete.\",\n            )\n        ]\n    except Exception as e:\n        error_msg = str(e)\n        if \"timeout\" in error_msg.lower():\n            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"{response_prefix}Timeout error: {error_msg}. Try reducing the result limit or check your network connection.\",\n                )\n            ]\n        return [\n            TextContent(\n                type=\"text\",\n                text=f\"{response_prefix}Error calling StealthMole API: {error_msg}\",\n            )\n        ]\n\n\nasync def run_server():\n    \"\"\"Run the MCP server.\"\"\"\n    global client\n\n    try:\n        print(\"Starting StealthMole MCP server...\", file=sys.stderr)\n\n        # Initialize StealthMole client\n        access_key = os.getenv(\"STEALTHMOLE_ACCESS_KEY\")\n        secret_key = os.getenv(\"STEALTHMOLE_SECRET_KEY\")\n\n        print(f\"Access key: {'SET' if access_key else 'NOT SET'}\", file=sys.stderr)\n        print(f\"Secret key: {'SET' if secret_key else 'NOT SET'}\", file=sys.stderr)\n\n        if not access_key or not secret_key:\n            print(\n                \"Warning: STEALTHMOLE_ACCESS_KEY and STEALTHMOLE_SECRET_KEY environment variables not set\",\n                file=sys.stderr,\n            )\n            print(\"MCP server will start but tools will not function\", file=sys.stderr)\n        else:\n            try:\n                config = StealthMoleConfig(access_key=access_key, secret_key=secret_key)\n                print(\"StealthMole config created\", file=sys.stderr)\n                client = StealthMoleClient(config)\n                print(\"StealthMole client initialized\", file=sys.stderr)\n\n                # API 연결 테스트 (타임아웃 없이 간단히)\n                try:\n                    quotas = await client.get_user_quotas()\n                    print(\n                        f\"✓ API connection successful. Available quotas: {quotas}\",\n                        file=sys.stderr,\n                    )\n                except Exception as api_error:\n                    print(f\"Warning: API test failed: {api_error}\", file=sys.stderr)\n                    print(\"Continuing with server startup...\", file=sys.stderr)\n\n            except Exception as e:\n                print(\n                    f\"Warning: Error creating StealthMole client: {e}\", file=sys.stderr\n                )\n                print(\n                    \"MCP server will start but tools may not function properly\",\n                    file=sys.stderr,\n                )\n                import traceback\n\n                traceback.print_exc(file=sys.stderr)\n\n        print(\"Creating stdio server...\", file=sys.stderr)\n        async with stdio_server() as (read_stream, write_stream):\n            print(\"Starting MCP server...\", file=sys.stderr)\n            try:\n                await server.run(\n                    read_stream,\n                    write_stream,\n                    InitializationOptions(\n                        server_name=\"stealthmole-mcp\",\n                        server_version=\"0.1.0\",\n                        capabilities=server.get_capabilities(\n                            notification_options=NotificationOptions(),\n                            experimental_capabilities={},\n                        ),\n                    ),\n                )\n                print(\"MCP server completed normally\", file=sys.stderr)\n            except Exception as e:\n                print(f\"Error in MCP server.run: {e}\", file=sys.stderr)\n                import traceback\n\n                traceback.print_exc(file=sys.stderr)\n                raise\n    except Exception as e:\n        print(f\"Error in run_server: {e}\", file=sys.stderr)\n        import traceback\n\n        traceback.print_exc(file=sys.stderr)\n\n\ndef main():\n    \"\"\"Main entry point for the MCP server.\"\"\"\n    asyncio.run(run_server())\n\n\nif __name__ == \"__main__\":\n    main()\n","structuredPatch":[{"oldStart":45,"oldLines":6,"newStart":45,"newLines":39,"lines":["     raise ValueError(f\"Unknown resource: {uri}\")"," "," ","+@server.list_prompts()","+async def handle_list_prompts() -> list[Prompt]:","+    \"\"\"List available prompts.\"\"\"","+    return [","+        Prompt(","+            name=\"neo_behavior_guide\",","+            description=\"StealthMole Neo behavior guidelines for search operations\",","+            arguments=[","+                PromptArgument(","+                    name=\"context\",","+                    description=\"Current search context\",","+                    required=False","+                )","+            ]","+        )","+    ]","+","+","+@server.get_prompt()","+async def handle_get_prompt(name: str, arguments: dict[str, str] | None = None) -> PromptMessage:","+    \"\"\"Get a specific prompt.\"\"\"","+    if name == \"neo_behavior_guide\":","+        return PromptMessage(","+            role=\"system\",","+            content=TextContent(","+                type=\"text\", ","+                text=DEFAULT_SYSTEM_PROMPT","+            )","+        )","+    else:","+        raise ValueError(f\"Unknown prompt: {name}\")","+","+"," @server.list_tools()"," async def handle_list_tools() -> list[Tool]:","     \"\"\"List available StealthMole tools.\"\"\""]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"ae950f08-c8c1-4a58-8dd9-043ebf60faa6","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"26b95f0f-af56-4fa2-9e24-f2b4047c0696","version":"1.0.51","message":{"id":"msg_01W5WGg1jNNZJ7DTMBKpGAtF","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01TzSbU3xiJ3bv3YACCTDBHr","name":"TodoWrite","input":{"todos":[{"id":"1","content":"Add MCP prompt handlers for system initialization","status":"completed","priority":"high"},{"id":"2","content":"Remove response_prefix from all tool responses","status":"in_progress","priority":"high"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":1077,"cache_read_input_tokens":28084,"output_tokens":23,"service_tier":"standard"}},"requestId":"req_011CR8DSXu2Zd41kCcQa3dXA","type":"assistant","uuid":"b4629526-eacb-40c3-8f6d-69d2d419423f","timestamp":"2025-07-15T05:00:20.458Z"}
{"parentUuid":"b4629526-eacb-40c3-8f6d-69d2d419423f","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"26b95f0f-af56-4fa2-9e24-f2b4047c0696","version":"1.0.51","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TzSbU3xiJ3bv3YACCTDBHr","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"cca8ac62-bdf5-4140-998c-1e4f9c029876","timestamp":"2025-07-15T05:00:20.507Z","toolUseResult":{"oldTodos":[{"content":"Add MCP prompt handlers for system initialization","status":"in_progress","priority":"high","id":"1"},{"content":"Remove response_prefix from all tool responses","status":"pending","priority":"high","id":"2"}],"newTodos":[{"content":"Add MCP prompt handlers for system initialization","status":"completed","priority":"high","id":"1"},{"content":"Remove response_prefix from all tool responses","status":"in_progress","priority":"high","id":"2"}]}}
{"parentUuid":"cca8ac62-bdf5-4140-998c-1e4f9c029876","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"26b95f0f-af56-4fa2-9e24-f2b4047c0696","version":"1.0.51","message":{"id":"msg_01RZAkyJQudx4xV65vU6LSTG","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01SKjBzh5MT579kaznjKjPwL","name":"MultiEdit","input":{"file_path":"/Users/realsun/data/git/mole-mcp-server/src/server.py","edits":[{"old_string":"    # Add system prompt context to response\n    response_prefix = f\"[StealthMole MCP Server]\\n{DEFAULT_SYSTEM_PROMPT}\\n\\n\"","new_string":""},{"old_string":"        # Format response with system behavior context\n        response_text = f\"{response_prefix}StealthMole API Results:\\n\\n{result}\\n\\n---\\nWould you like to browse the next page of results?\"\n        return [TextContent(type=\"text\", text=response_text)]","new_string":"        # Format response\n        response_text = f\"StealthMole API Results:\\n\\n{result}\\n\\n---\\nWould you like to browse the next page of results?\"\n        return [TextContent(type=\"text\", text=response_text)]"},{"old_string":"        return [\n            TextContent(\n                type=\"text\",\n                text=f\"{response_prefix}Request timed out. The API request took too long to complete.\",\n            )\n        ]","new_string":"        return [\n            TextContent(\n                type=\"text\",\n                text=\"Request timed out. The API request took too long to complete.\",\n            )\n        ]"},{"old_string":"            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"{response_prefix}Timeout error: {error_msg}. Try reducing the result limit or check your network connection.\",\n                )\n            ]","new_string":"            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"Timeout error: {error_msg}. Try reducing the result limit or check your network connection.\",\n                )\n            ]"},{"old_string":"        return [\n            TextContent(\n                type=\"text\",\n                text=f\"{response_prefix}Error calling StealthMole API: {error_msg}\",\n            )\n        ]","new_string":"        return [\n            TextContent(\n                type=\"text\",\n                text=f\"Error calling StealthMole API: {error_msg}\",\n            )\n        ]"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":261,"cache_read_input_tokens":29161,"output_tokens":23,"service_tier":"standard"}},"requestId":"req_011CR8DSsJayejjojhh2p7jL","type":"assistant","uuid":"27c03d5c-baee-4706-8b0d-6d409a2379e9","timestamp":"2025-07-15T05:00:32.489Z"}
{"parentUuid":"27c03d5c-baee-4706-8b0d-6d409a2379e9","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"26b95f0f-af56-4fa2-9e24-f2b4047c0696","version":"1.0.51","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SKjBzh5MT579kaznjKjPwL","type":"tool_result","content":"Applied 5 edits to /Users/realsun/data/git/mole-mcp-server/src/server.py:\n1. Replaced \"    # Add system prompt context to response\n    re...\" with \"\"\n2. Replaced \"        # Format response with system behavior con...\" with \"        # Format response\n        response_text = ...\"\n3. Replaced \"        return [\n            TextContent(\n        ...\" with \"        return [\n            TextContent(\n        ...\"\n4. Replaced \"            return [\n                TextContent(\n...\" with \"            return [\n                TextContent(\n...\"\n5. Replaced \"        return [\n            TextContent(\n        ...\" with \"        return [\n            TextContent(\n        ...\""}]},"uuid":"585e974b-7d78-49e2-96cd-9e3e3f08cfaa","timestamp":"2025-07-15T05:00:33.957Z","toolUseResult":{"filePath":"/Users/realsun/data/git/mole-mcp-server/src/server.py","edits":[{"old_string":"    # Add system prompt context to response\n    response_prefix = f\"[StealthMole MCP Server]\\n{DEFAULT_SYSTEM_PROMPT}\\n\\n\"","new_string":"","replace_all":false},{"old_string":"        # Format response with system behavior context\n        response_text = f\"{response_prefix}StealthMole API Results:\\n\\n{result}\\n\\n---\\nWould you like to browse the next page of results?\"\n        return [TextContent(type=\"text\", text=response_text)]","new_string":"        # Format response\n        response_text = f\"StealthMole API Results:\\n\\n{result}\\n\\n---\\nWould you like to browse the next page of results?\"\n        return [TextContent(type=\"text\", text=response_text)]","replace_all":false},{"old_string":"        return [\n            TextContent(\n                type=\"text\",\n                text=f\"{response_prefix}Request timed out. The API request took too long to complete.\",\n            )\n        ]","new_string":"        return [\n            TextContent(\n                type=\"text\",\n                text=\"Request timed out. The API request took too long to complete.\",\n            )\n        ]","replace_all":false},{"old_string":"            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"{response_prefix}Timeout error: {error_msg}. Try reducing the result limit or check your network connection.\",\n                )\n            ]","new_string":"            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"Timeout error: {error_msg}. Try reducing the result limit or check your network connection.\",\n                )\n            ]","replace_all":false},{"old_string":"        return [\n            TextContent(\n                type=\"text\",\n                text=f\"{response_prefix}Error calling StealthMole API: {error_msg}\",\n            )\n        ]","new_string":"        return [\n            TextContent(\n                type=\"text\",\n                text=f\"Error calling StealthMole API: {error_msg}\",\n            )\n        ]","replace_all":false}],"originalFileContents":"\"\"\"StealthMole MCP Server implementation.\"\"\"\n\nimport asyncio\nimport os\nimport sys\nfrom typing import Any, Optional, Sequence\n\nfrom dotenv import load_dotenv\nfrom mcp.server import NotificationOptions, Server\nfrom mcp.server.models import InitializationOptions\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import Prompt, PromptArgument, PromptMessage, Resource, TextContent, Tool\nfrom pydantic import AnyUrl\n\nfrom src.tools import *\nfrom src.utils.client import StealthMoleClient\nfrom src.utils.config import StealthMoleConfig\n\nload_dotenv()\n\n# Global client instance\nclient: Optional[StealthMoleClient] = None\n\n# Default system prompt for Neo behavior\nDEFAULT_SYSTEM_PROMPT = \"\"\"If you don't mention a specific indicator, Neo will default to searching by keyword.\nIf a different indicator is requested, but not explicitly in the form indicator:query, it will say \"Perform additional searches with keyword to gather more information.\" and proceed. \nAlways set limit to the maximum value.\nWe also ask the user if they want to browse the next page:\"\"\"\n\nserver: Server = Server(\n    \"stealthmole-mcp\",\n    \"0.2.0\",\n)\n\n\n@server.list_resources()\nasync def handle_list_resources() -> list[Resource]:\n    \"\"\"List available resources.\"\"\"\n    return []\n\n\n@server.read_resource()\nasync def handle_read_resource(uri: AnyUrl) -> str:\n    \"\"\"Read a specific resource.\"\"\"\n    raise ValueError(f\"Unknown resource: {uri}\")\n\n\n@server.list_prompts()\nasync def handle_list_prompts() -> list[Prompt]:\n    \"\"\"List available prompts.\"\"\"\n    return [\n        Prompt(\n            name=\"neo_behavior_guide\",\n            description=\"StealthMole Neo behavior guidelines for search operations\",\n            arguments=[\n                PromptArgument(\n                    name=\"context\",\n                    description=\"Current search context\",\n                    required=False\n                )\n            ]\n        )\n    ]\n\n\n@server.get_prompt()\nasync def handle_get_prompt(name: str, arguments: dict[str, str] | None = None) -> PromptMessage:\n    \"\"\"Get a specific prompt.\"\"\"\n    if name == \"neo_behavior_guide\":\n        return PromptMessage(\n            role=\"system\",\n            content=TextContent(\n                type=\"text\", \n                text=DEFAULT_SYSTEM_PROMPT\n            )\n        )\n    else:\n        raise ValueError(f\"Unknown prompt: {name}\")\n\n\n@server.list_tools()\nasync def handle_list_tools() -> list[Tool]:\n    \"\"\"List available StealthMole tools.\"\"\"\n    try:\n        print(\"Returning StealthMole tools list\", file=sys.stderr)\n        return [\n            Tool(\n                name=\"search_darkweb\",\n                description=\"Search dark web content for indicators like domains, IPs, emails, etc.\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type to search for\",\n                            \"enum\": [\n                                \"adsense\",\n                                \"analyticsid\",\n                                \"band\",\n                                \"bitcoin\",\n                                \"blueprint\",\n                                \"creditcard\",\n                                \"cve\",\n                                \"discord\",\n                                \"document\",\n                                \"domain\",\n                                \"email\",\n                                \"ethereum\",\n                                \"exefile\",\n                                \"facebook\",\n                                \"filehosting\",\n                                \"googledrive\",\n                                \"gps\",\n                                \"hash\",\n                                \"hashstring\",\n                                \"i2p\",\n                                \"i2purl\",\n                                \"id\",\n                                \"image\",\n                                \"instagram\",\n                                \"ioc\",\n                                \"ip\",\n                                \"kakaotalk\",\n                                \"keyword\",\n                                \"kssn\",\n                                \"leakedaudio\",\n                                \"leakedemailfile\",\n                                \"leakedvideo\",\n                                \"line\",\n                                \"linkedin\",\n                                \"malware\",\n                                \"monero\",\n                                \"otherfile\",\n                                \"pastebin\",\n                                \"pgp\",\n                                \"serverstatus\",\n                                \"session\",\n                                \"shorten\",\n                                \"sshkey\",\n                                \"sslkey\",\n                                \"tel\",\n                                \"telegram\",\n                                \"tor\",\n                                \"torurl\",\n                                \"twitter\",\n                                \"url\",\n                            ],\n                        },\n                        \"text\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search keyword or data to find. Supports AND, OR, NOT operators (max 3 OR, 5 total operators)\",\n                        },\n                        \"target\": {\n                            \"type\": \"string\",\n                            \"description\": \"Target type to search (default: 'all'). Use comma-separated values for multiple targets\",\n                            \"default\": \"all\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Ordering type\",\n                            \"enum\": [\"createDate\", \"value\"],\n                            \"default\": \"createDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\", \"text\"],\n                },\n            ),\n            Tool(\n                name=\"search_telegram\",\n                description=\"Search Telegram content for indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type to search for\",\n                            \"enum\": [\n                                \"band\",\n                                \"bitcoin\",\n                                \"creditcard\",\n                                \"cve\",\n                                \"discord\",\n                                \"document\",\n                                \"domain\",\n                                \"email\",\n                                \"ethereum\",\n                                \"exefile\",\n                                \"facebook\",\n                                \"filehosting\",\n                                \"googledrive\",\n                                \"gps\",\n                                \"hash\",\n                                \"hashstring\",\n                                \"i2p\",\n                                \"i2purl\",\n                                \"id\",\n                                \"image\",\n                                \"instagram\",\n                                \"ip\",\n                                \"kakaotalk\",\n                                \"keyword\",\n                                \"kssn\",\n                                \"line\",\n                                \"monero\",\n                                \"otherfile\",\n                                \"pastebin\",\n                                \"pgp\",\n                                \"tel\",\n                                \"session\",\n                                \"shorten\",\n                                \"telegram\",\n                                \"telegram.channel\",\n                                \"telegram.message\",\n                                \"telegram.user\",\n                                \"tor\",\n                                \"torurl\",\n                                \"tox\",\n                                \"twitter\",\n                                \"url\",\n                            ],\n                        },\n                        \"text\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search keyword or data to find. Supports AND, OR, NOT operators (max 3 OR, 5 total operators)\",\n                        },\n                        \"target\": {\n                            \"type\": \"string\",\n                            \"description\": \"Target type to search (default: 'all'). Use comma-separated values for multiple targets\",\n                            \"default\": \"all\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Ordering type\",\n                            \"enum\": [\"createDate\", \"value\"],\n                            \"default\": \"createDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\", \"text\"],\n                },\n            ),\n            Tool(\n                name=\"search_credentials\",\n                description=\"Search for leaked credentials using keywords or specific indicators (domain:, email:, id:, password:, after:, before:)\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - can use indicators like 'domain:example.com', 'email:user@domain.com', 'id:username', 'password:pass123', 'after:2023-01', 'before:2024-01' or plain keywords\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\n                                \"leakedDate\",\n                                \"domain\",\n                                \"email\",\n                                \"password\",\n                                \"leakedFrom\",\n                            ],\n                            \"default\": \"leakedDate\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                        \"start\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Filter data added to the system after start time (UTC timestamp)\",\n                        },\n                        \"end\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Filter data added to the system before end time (UTC timestamp)\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_ransomware\",\n                description=\"Search ransomware monitoring data using torurl: or domain: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'torurl:site.onion' to search ransomware sites or 'domain:victim.com' to search victim websites. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 50,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"victim\", \"attackGroup\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"get_node_details\",\n                description=\"Get detailed information about a specific node\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"node_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Node ID to get details for\",\n                        },\n                        \"pid\": {\n                            \"type\": \"string\",\n                            \"description\": \"Parent node ID (optional)\",\n                        },\n                        \"data_from\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Import data source list (default: False)\",\n                            \"default\": False,\n                        },\n                        \"include_url\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Import included URL list (default: False)\",\n                            \"default\": False,\n                        },\n                        \"include_contents\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Include HTML source contents for torurl, i2purl, url (default: True)\",\n                            \"default\": True,\n                        },\n                    },\n                    \"required\": [\"service\", \"node_id\"],\n                },\n            ),\n            Tool(\n                name=\"get_targets\",\n                description=\"Get available search targets for a service and indicator\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator type\",\n                        },\n                    },\n                    \"required\": [\"service\", \"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_data\",\n                description=\"Export search results in specified format\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt, tt, cl, rm, etc.)\",\n                        },\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"service\", \"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_compromised_dataset\",\n                description=\"Search compromised data set information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_compromised_dataset\",\n                description=\"Export compromised data set as CSV/JSON\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"get_compromised_dataset_node\",\n                description=\"Get detailed compromised data set node information (Cyber Security Edition required)\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"node_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Node ID to get details for\",\n                        }\n                    },\n                    \"required\": [\"node_id\"],\n                },\n            ),\n            Tool(\n                name=\"search_combo_binder\",\n                description=\"Search leaked ID/Password combo information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_combo_binder\",\n                description=\"Export combo binder data as CSV/JSON\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_ulp_binder\",\n                description=\"Search URL-Login-Password combination information\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to search for\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"export_ulp_binder\",\n                description=\"Export ULP binder data as CSV/JSON\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"The indicator to export data for\",\n                        },\n                        \"format\": {\n                            \"type\": \"string\",\n                            \"description\": \"Export format (json or csv)\",\n                            \"enum\": [\"json\", \"csv\"],\n                            \"default\": \"json\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_government_monitoring\",\n                description=\"Search government sector threat monitoring data using url: or id: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'url:hackersite.com' to search threat event URLs or 'id:hacker123' to search actor IDs. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"title\", \"author\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"search_leaked_monitoring\",\n                description=\"Search enterprise sector threat monitoring data using url: or id: indicators\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"indicator\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query - use 'url:hackersite.com' to search threat event URLs or 'id:hacker123' to search actor IDs. Leave empty for recent list.\",\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"orderType\": {\n                            \"type\": \"string\",\n                            \"description\": \"Order type\",\n                            \"enum\": [\"detectionTime\", \"title\", \"author\"],\n                            \"default\": \"detectionTime\",\n                        },\n                        \"order\": {\n                            \"type\": \"string\",\n                            \"description\": \"Sort order\",\n                            \"enum\": [\"asc\", \"desc\"],\n                            \"default\": \"desc\",\n                        },\n                    },\n                    \"required\": [\"indicator\"],\n                },\n            ),\n            Tool(\n                name=\"download_file\",\n                description=\"Download file by hash from dt or tt service\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt or tt)\",\n                            \"enum\": [\"dt\", \"tt\"],\n                        },\n                        \"file_hash\": {\n                            \"type\": \"string\",\n                            \"description\": \"File hash to download\",\n                        },\n                    },\n                    \"required\": [\"service\", \"file_hash\"],\n                },\n            ),\n            Tool(\n                name=\"search_pagination\",\n                description=\"Pagination search using search ID for dt or tt service\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"service\": {\n                            \"type\": \"string\",\n                            \"description\": \"Service type (dt or tt)\",\n                            \"enum\": [\"dt\", \"tt\"],\n                        },\n                        \"search_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search ID from previous search\",\n                        },\n                        \"cursor\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pagination cursor (default: 0)\",\n                            \"default\": 0,\n                            \"minimum\": 0,\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results (default: 50)\",\n                            \"default\": 50,\n                            \"minimum\": 1,\n                            \"maximum\": 100,\n                        },\n                    },\n                    \"required\": [\"service\", \"search_id\"],\n                },\n            ),\n            Tool(\n                name=\"get_user_quotas\",\n                description=\"Get API usage quotas by service\",\n                inputSchema={\"type\": \"object\", \"properties\": {}, \"required\": []},\n            ),\n        ]\n    except Exception as e:\n        print(f\"Error in handle_list_tools: {e}\", file=sys.stderr)\n        import traceback\n\n        traceback.print_exc(file=sys.stderr)\n        return []\n\n\ndef apply_default_behavior(name: str, arguments: dict[str, Any]) -> dict[str, Any]:\n    \"\"\"Apply default behavior rules to tool arguments.\"\"\"\n    # Always set limit to maximum value\n    if \"limit\" in arguments:\n        if name in [\"search_darkweb\", \"search_telegram\"]:\n            arguments[\"limit\"] = 100\n        elif name in [\n            \"search_credentials\",\n            \"search_ransomware\",\n            \"search_compromised_dataset\",\n            \"search_combo_binder\",\n            \"search_ulp_binder\",\n            \"search_government_monitoring\",\n            \"search_leaked_monitoring\",\n        ]:\n            arguments[\"limit\"] = 50\n\n    # Handle indicator defaults for search tools\n    if name in [\"search_darkweb\", \"search_telegram\"]:\n        if \"indicator\" not in arguments or not arguments[\"indicator\"]:\n            arguments[\"indicator\"] = \"keyword\"\n\n    return arguments\n\n\n@server.call_tool()\nasync def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:\n    \"\"\"Handle tool calls with default behavior applied.\"\"\"\n    global client\n\n    if client is None:\n        return [\n            TextContent(\n                type=\"text\",\n                text=\"Error: StealthMole client not initialized. Please check your API credentials.\",\n            )\n        ]\n\n    # Apply default behavior rules\n    arguments = apply_default_behavior(name, arguments)\n\n    # Add system prompt context to response\n    response_prefix = f\"[StealthMole MCP Server]\\n{DEFAULT_SYSTEM_PROMPT}\\n\\n\"\n\n    try:\n        if name == \"search_darkweb\":\n            result = await client.search_darkweb(\n                indicator=arguments[\"indicator\"],\n                text=arguments[\"text\"],\n                target=arguments.get(\"target\", \"all\"),\n                limit=arguments.get(\"limit\", 50),\n                orderType=arguments.get(\"orderType\", \"createDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_telegram\":\n            result = await client.search_telegram(\n                indicator=arguments[\"indicator\"],\n                text=arguments[\"text\"],\n                target=arguments.get(\"target\", \"all\"),\n                limit=arguments.get(\"limit\", 50),\n                orderType=arguments.get(\"orderType\", \"createDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_credentials\":\n            result = await client.search_credentials(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"leakedDate\"),\n                order=arguments.get(\"order\", \"desc\"),\n                start=arguments.get(\"start\"),\n                end=arguments.get(\"end\"),\n            )\n        elif name == \"search_ransomware\":\n            result = await client.search_ransomware(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"get_node_details\":\n            result = await client.get_node_details(\n                service=arguments[\"service\"],\n                node_id=arguments[\"node_id\"],\n                pid=arguments.get(\"pid\"),\n                data_from=arguments.get(\"data_from\", False),\n                include_url=arguments.get(\"include_url\", False),\n                include_contents=arguments.get(\"include_contents\", True),\n            )\n        elif name == \"get_targets\":\n            result = await client.get_targets(\n                service=arguments[\"service\"], indicator=arguments[\"indicator\"]\n            )\n        elif name == \"export_data\":\n            result = await client.export_data(\n                service=arguments[\"service\"],\n                indicator=arguments[\"indicator\"],\n                format=arguments.get(\"format\", \"json\"),\n            )\n        elif name == \"search_compromised_dataset\":\n            result = await client.search_compromised_dataset(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"export_compromised_dataset\":\n            result = await client.export_compromised_dataset(\n                indicator=arguments[\"indicator\"], format=arguments.get(\"format\", \"json\")\n            )\n        elif name == \"get_compromised_dataset_node\":\n            result = await client.get_compromised_dataset_node(\n                node_id=arguments[\"node_id\"]\n            )\n        elif name == \"search_combo_binder\":\n            result = await client.search_combo_binder(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"export_combo_binder\":\n            result = await client.export_combo_binder(\n                indicator=arguments[\"indicator\"], format=arguments.get(\"format\", \"json\")\n            )\n        elif name == \"search_ulp_binder\":\n            result = await client.search_ulp_binder(\n                indicator=arguments[\"indicator\"], limit=arguments.get(\"limit\", 50)\n            )\n        elif name == \"export_ulp_binder\":\n            result = await client.export_ulp_binder(\n                indicator=arguments[\"indicator\"], format=arguments.get(\"format\", \"json\")\n            )\n        elif name == \"search_government_monitoring\":\n            result = await client.search_government_monitoring(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"search_leaked_monitoring\":\n            result = await client.search_leaked_monitoring(\n                indicator=arguments[\"indicator\"],\n                limit=arguments.get(\"limit\", 50),\n                cursor=arguments.get(\"cursor\", 0),\n                orderType=arguments.get(\"orderType\", \"detectionTime\"),\n                order=arguments.get(\"order\", \"desc\"),\n            )\n        elif name == \"download_file\":\n            file_content = await client.download_file(\n                service=arguments[\"service\"], file_hash=arguments[\"file_hash\"]\n            )\n            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"Downloaded file {arguments['file_hash']} from {arguments['service']} service. File size: {len(file_content)} bytes\",\n                )\n            ]\n        elif name == \"search_pagination\":\n            result = await client.search_pagination(\n                service=arguments[\"service\"],\n                search_id=arguments[\"search_id\"],\n                cursor=arguments.get(\"cursor\", 0),\n                limit=arguments.get(\"limit\", 50),\n            )\n        elif name == \"get_user_quotas\":\n            result = await client.get_user_quotas()\n        else:\n            return [TextContent(type=\"text\", text=f\"Unknown tool: {name}\")]\n\n        # Format response with system behavior context\n        response_text = f\"{response_prefix}StealthMole API Results:\\n\\n{result}\\n\\n---\\nWould you like to browse the next page of results?\"\n        return [TextContent(type=\"text\", text=response_text)]\n\n    except asyncio.TimeoutError:\n        return [\n            TextContent(\n                type=\"text\",\n                text=f\"{response_prefix}Request timed out. The API request took too long to complete.\",\n            )\n        ]\n    except Exception as e:\n        error_msg = str(e)\n        if \"timeout\" in error_msg.lower():\n            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"{response_prefix}Timeout error: {error_msg}. Try reducing the result limit or check your network connection.\",\n                )\n            ]\n        return [\n            TextContent(\n                type=\"text\",\n                text=f\"{response_prefix}Error calling StealthMole API: {error_msg}\",\n            )\n        ]\n\n\nasync def run_server():\n    \"\"\"Run the MCP server.\"\"\"\n    global client\n\n    try:\n        print(\"Starting StealthMole MCP server...\", file=sys.stderr)\n\n        # Initialize StealthMole client\n        access_key = os.getenv(\"STEALTHMOLE_ACCESS_KEY\")\n        secret_key = os.getenv(\"STEALTHMOLE_SECRET_KEY\")\n\n        print(f\"Access key: {'SET' if access_key else 'NOT SET'}\", file=sys.stderr)\n        print(f\"Secret key: {'SET' if secret_key else 'NOT SET'}\", file=sys.stderr)\n\n        if not access_key or not secret_key:\n            print(\n                \"Warning: STEALTHMOLE_ACCESS_KEY and STEALTHMOLE_SECRET_KEY environment variables not set\",\n                file=sys.stderr,\n            )\n            print(\"MCP server will start but tools will not function\", file=sys.stderr)\n        else:\n            try:\n                config = StealthMoleConfig(access_key=access_key, secret_key=secret_key)\n                print(\"StealthMole config created\", file=sys.stderr)\n                client = StealthMoleClient(config)\n                print(\"StealthMole client initialized\", file=sys.stderr)\n\n                # API 연결 테스트 (타임아웃 없이 간단히)\n                try:\n                    quotas = await client.get_user_quotas()\n                    print(\n                        f\"✓ API connection successful. Available quotas: {quotas}\",\n                        file=sys.stderr,\n                    )\n                except Exception as api_error:\n                    print(f\"Warning: API test failed: {api_error}\", file=sys.stderr)\n                    print(\"Continuing with server startup...\", file=sys.stderr)\n\n            except Exception as e:\n                print(\n                    f\"Warning: Error creating StealthMole client: {e}\", file=sys.stderr\n                )\n                print(\n                    \"MCP server will start but tools may not function properly\",\n                    file=sys.stderr,\n                )\n                import traceback\n\n                traceback.print_exc(file=sys.stderr)\n\n        print(\"Creating stdio server...\", file=sys.stderr)\n        async with stdio_server() as (read_stream, write_stream):\n            print(\"Starting MCP server...\", file=sys.stderr)\n            try:\n                await server.run(\n                    read_stream,\n                    write_stream,\n                    InitializationOptions(\n                        server_name=\"stealthmole-mcp\",\n                        server_version=\"0.1.0\",\n                        capabilities=server.get_capabilities(\n                            notification_options=NotificationOptions(),\n                            experimental_capabilities={},\n                        ),\n                    ),\n                )\n                print(\"MCP server completed normally\", file=sys.stderr)\n            except Exception as e:\n                print(f\"Error in MCP server.run: {e}\", file=sys.stderr)\n                import traceback\n\n                traceback.print_exc(file=sys.stderr)\n                raise\n    except Exception as e:\n        print(f\"Error in run_server: {e}\", file=sys.stderr)\n        import traceback\n\n        traceback.print_exc(file=sys.stderr)\n\n\ndef main():\n    \"\"\"Main entry point for the MCP server.\"\"\"\n    asyncio.run(run_server())\n\n\nif __name__ == \"__main__\":\n    main()\n","structuredPatch":[{"oldStart":756,"oldLines":8,"newStart":756,"newLines":6,"lines":["     # Apply default behavior rules","     arguments = apply_default_behavior(name, arguments)"," ","-    # Add system prompt context to response","-    response_prefix = f\"[StealthMole MCP Server]\\n{DEFAULT_SYSTEM_PROMPT}\\n\\n\""," ","     try:","         if name == \"search_darkweb\":"]},{"oldStart":881,"oldLines":15,"newStart":879,"newLines":15,"lines":["         else:","             return [TextContent(type=\"text\", text=f\"Unknown tool: {name}\")]"," ","-        # Format response with system behavior context","-        response_text = f\"{response_prefix}StealthMole API Results:\\n\\n{result}\\n\\n---\\nWould you like to browse the next page of results?\"","+        # Format response","+        response_text = f\"StealthMole API Results:\\n\\n{result}\\n\\n---\\nWould you like to browse the next page of results?\"","         return [TextContent(type=\"text\", text=response_text)]"," ","     except asyncio.TimeoutError:","         return [","             TextContent(","                 type=\"text\",","-                text=f\"{response_prefix}Request timed out. The API request took too long to complete.\",","+                text=\"Request timed out. The API request took too long to complete.\",","             )","         ]","     except Exception as e:"]},{"oldStart":898,"oldLines":13,"newStart":896,"newLines":13,"lines":["             return [","                 TextContent(","                     type=\"text\",","-                    text=f\"{response_prefix}Timeout error: {error_msg}. Try reducing the result limit or check your network connection.\",","+                    text=f\"Timeout error: {error_msg}. Try reducing the result limit or check your network connection.\",","                 )","             ]","         return [","             TextContent(","                 type=\"text\",","-                text=f\"{response_prefix}Error calling StealthMole API: {error_msg}\",","+                text=f\"Error calling StealthMole API: {error_msg}\",","             )","         ]"," "]}],"userModified":false}}
{"parentUuid":"585e974b-7d78-49e2-96cd-9e3e3f08cfaa","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"26b95f0f-af56-4fa2-9e24-f2b4047c0696","version":"1.0.51","message":{"id":"msg_01Bfa8wonhfbvsHWiWABLrrh","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01GADN4dK5tJYBQbqeM4uoiK","name":"TodoWrite","input":{"todos":[{"id":"1","content":"Add MCP prompt handlers for system initialization","status":"completed","priority":"high"},{"id":"2","content":"Remove response_prefix from all tool responses","status":"completed","priority":"high"}]}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":838,"cache_read_input_tokens":29422,"output_tokens":116,"service_tier":"standard"}},"requestId":"req_011CR8DTs3yth6SVopx8wUFp","type":"assistant","uuid":"2f20f3fc-7986-4458-8a35-63bda5d2f14b","timestamp":"2025-07-15T05:00:38.283Z"}
{"parentUuid":"2f20f3fc-7986-4458-8a35-63bda5d2f14b","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"26b95f0f-af56-4fa2-9e24-f2b4047c0696","version":"1.0.51","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GADN4dK5tJYBQbqeM4uoiK","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"ee25011a-e546-45f0-b0f9-9ecf9c956a64","timestamp":"2025-07-15T05:00:38.343Z","toolUseResult":{"oldTodos":[{"content":"Add MCP prompt handlers for system initialization","status":"completed","priority":"high","id":"1"},{"content":"Remove response_prefix from all tool responses","status":"in_progress","priority":"high","id":"2"}],"newTodos":[{"content":"Add MCP prompt handlers for system initialization","status":"completed","priority":"high","id":"1"},{"content":"Remove response_prefix from all tool responses","status":"completed","priority":"high","id":"2"}]}}
{"parentUuid":"ee25011a-e546-45f0-b0f9-9ecf9c956a64","isSidechain":false,"userType":"external","cwd":"/Users/realsun/data/git/mole-mcp-server","sessionId":"26b95f0f-af56-4fa2-9e24-f2b4047c0696","version":"1.0.51","message":{"id":"msg_01DvZjd661hms81qgj6AgBTV","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"수정 완료되었습니다.\n\n**변경 사항:**\n\n1. **MCP Prompt 핸들러 추가** (`server.py:48-78`):\n   - `@server.list_prompts()`: `neo_behavior_guide` 프롬프트 제공\n   - `@server.get_prompt()`: AI가 요청 시 시스템 가이드라인 반환\n\n2. **도구 응답에서 시스템 프롬프트 제거** (`server.py:726-876`):\n   - 모든 `response_prefix` 관련 코드 제거\n   - 순수한 API 결과만 반환하도록 개선\n\n**사용 방법:**\n- AI는 초기화 시 `neo_behavior_guide` 프롬프트를 읽어 StealthMole 검색 동작 가이드라인을 확인할 수 있습니다\n- 도구 응답은 이제 깔끔하게 실제 데이터만 포함됩니다"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":257,"cache_read_input_tokens":30260,"output_tokens":288,"service_tier":"standard"}},"requestId":"req_011CR8DUBbSptDuQhU3sBrx6","type":"assistant","uuid":"d9677920-f9c9-4541-8750-7c0982ea7c9f","timestamp":"2025-07-15T05:00:45.569Z"}
